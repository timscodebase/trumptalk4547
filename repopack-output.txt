This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-25T07:11:35.455Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  lib/
    components/
      Analylitics.svelte
      Avengers.svelte
      BlogLink.svelte
      BuyMeACoffee.svelte
      CookieConsent.svelte
      DarkModeToggle.svelte
      ElectionCountDown.svelte
      ExternalLink.svelte
      Footer.svelte
      Header.svelte
      Image.svelte
      ImageSlider.svelte
      Meta.svelte
      Nav.svelte
      Posts.svelte
      SponsorLink.svelte
      Sponsors.svelte
      USAFacts.svelte
    config.ts
    index.ts
    types.ts
    utils.test.ts
    utils.ts
  posts/
    cory-comperatore.md
    enemies-within.md
    ice-detention-and-enforcement.md
    kamalas-coep.md
    no-wars-proxy-wars-forever-wars.md
    road-to-270.md
    three-stool-plan.md
    trump-childhood.md
    trump-ear.md
    trumps-return-to-buttler.md
    visa-pelosi.md
    walz-lies.md
  routes/
    about/
      +page.svelte
    api/
      posts/
        +server.ts
    blog/
      [slug]/
        +page.svelte
        +page.ts
      +page.svelte
      +page.ts
    contact/
      +page.server.ts
      +page.svelte
      +page.ts
    rss.xml/
      +server.ts
    +error.svelte
    +layout.svelte
    +page.svelte
    +page.ts
  service-worker/
    index.ts
    service-worker.ts
  app.d.ts
  app.html
  index.test.ts
static/
  ~partytown/
    debug/
      partytown-atomics.js
      partytown-media.js
      partytown-sandbox-sw.js
      partytown-sw.js
      partytown-ww-atomics.js
      partytown-ww-sw.js
      partytown.js
    partytown-atomics.js
    partytown-media.js
    partytown-sw.js
    partytown.js
  css/
    banner.css
    consent.css
    main.css
    typograpy.css
  favicon/
    browserconfig.xml
    manifest.json
    safari-pinned-tab.svg
  js/
    cookieconsent-config.js
  ads.txt
  robots.txt
.gitattributes
.gitignore
.npmrc
.prettierignore
.prettierrc
eslint.config.js
main.py
package.json
README.md
SECURITY.md
svelte.config.js
tsconfig.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: src/lib/components/Analylitics.svelte
================
<script lang="ts">
	import { page } from '$app/stores'

	$effect(() => {
		if (typeof gtag !== 'undefined') {
			gtag('config', 'G-FZH87M6DDV', {
				page_title: document.title,
				page_path: $page.url.pathname
			})
		}
	})
</script>

================
File: src/lib/components/Avengers.svelte
================
<script lang="ts">
	import Image from './Image.svelte'
</script>

<section>
	<Image
		src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727583704/trumps-avengers_z2945x.png"
		alt="Trump's Avengers"
	/>
</section>

================
File: src/lib/components/BlogLink.svelte
================
<script lang="ts">
	import type { Post } from '$lib/types'
	import { Image } from '$lib'
	import { formatDate } from '$lib/utils'
	let { post } = $props() as { post: Post }
</script>

<article>
	<div>
		<a href={`/blog/${post.slug}`} class="title">
			<img src={post.image} alt={post.title} loading="lazy" />
			<h2>{post.title}</h2>

			<div class="meta">
				<p class="date">{formatDate(post.date)}</p>
				<p class="description">{post.description}</p>
			</div>
		</a>
	</div>
</article>

<style>
	article {
		display: grid;
		grid-template-columns: 1fr;
		place-items: center;
		gap: 0;
		overflow: hidden;
		border: 2px solid var(--color-accent);
	}

	a {
		display: block;
		padding: 0;
		background: var(--color-text);

		&:hover {
			text-decoration: none;
		}

		&:visited {
			color: var(--color-text-op);
		}

		h2 {
			display: block;
			font-size: clamp(0.9rem, 3vw, 2.5rem);
			padding: 0.5rem 5px;
			color: var(--color-accent);
		}
	}

	p {
		margin: 0;
		padding: 1rem;
	}

	h2 {
		margin: 0;
		padding: 10px 0;
		text-align: center;
	}
	.meta {
		color: var(--color-text);
	}

	img {
		height: auto;
		max-width: 100%;
		object-fit: contain;
	}

	@media (max-width: 1000px) {
		a {
			display: grid;
			place-content: center;
			padding-bottom: 0;

			h2 {
				display: inline-block;
				width: 100%;
				overflow-wrap: break-word;
				text-align: center;
				padding-bottom: 16px;
				margin-bottom: 0;
			}
		}

		p {
			font-size: 0.75rem;
			padding: 0.2rem 0.5rem;
		}
	}

	.meta {
		color: var(--color-text-op);
		background: var(--color-surface-op);

		.date {
			font-weight: bold;
			padding-bottom: 0;
		}
	}
</style>

================
File: src/lib/components/BuyMeACoffee.svelte
================
<a href="https://www.buymeacoffee.com/trumptalk4547" target="_blank"
	><img
		src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png"
		alt="Buy Me A Coffee"
		style="height: 60px !important;width: 217px !important;"
	/></a
>

================
File: src/lib/components/CookieConsent.svelte
================
<script>
	import GdprBanner from '@beyonk/gdpr-cookie-consent-banner'

	function initAnalytics() {
		// do something with segment.io or google analytics etc
	}
</script>

<GdprBanner
	cookieName="Cookie Consent"
	description="We don't use many cookies, but we do use analytics."
	on:analytics={initAnalytics}
/>

================
File: src/lib/components/DarkModeToggle.svelte
================
<script lang="ts">
	let isDarkMode = $state(true)

	$effect(() => {
		const toggleSwitch = document.querySelector(
			'.theme-switch input[type="checkbox"]'
		) as HTMLInputElement
		const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null

		if (currentTheme) {
			document.documentElement.setAttribute('data-theme', currentTheme)

			if (currentTheme === 'dark') {
				if (toggleSwitch) {
					toggleSwitch.checked = true
				}
			}
		}

		function switchTheme(e: any) {
			if (e.target.checked) {
				document.documentElement.setAttribute('data-theme', 'dark')
				localStorage.setItem('theme', 'dark')
				isDarkMode = true
			} else {
				document.documentElement.setAttribute('data-theme', 'light')
				localStorage.setItem('theme', 'light')
				isDarkMode = false
			}
		}

		toggleSwitch?.addEventListener('change', switchTheme, false)
	})
</script>

<div class="theme-switch-wrapper">
	{#if isDarkMode}
		<em><iconify-icon icon="fe:sunny-o"></iconify-icon></em>
	{:else}
		<em><iconify-icon icon="fe:moon"></iconify-icon></em>
	{/if}
	<label class="theme-switch" for="checkbox">
		<input type="checkbox" id="checkbox" />
		<div class="slider round"></div>
	</label>
</div>

<style>
	.theme-switch-wrapper {
		display: grid;
		place-items: center;
		justify-content: center;
		grid-template-columns: auto 1fr;

		em {
			display: grid;
			place-items: center;
			justify-content: center;
			margin-right: 10px;
			font-size: 1.5rem;
			color: var(--color-accent);
			font-weight: 600;
		}
	}
	.theme-switch {
		display: inline-block;
		height: 24px;
		position: relative;
		width: 40px;
	}

	@media (max-width: 1000px) {
		.theme-switch {
			margin: 10px 0;
			height: 36px;
			width: 60px;
		}

		.theme-switch-wrapper {
			em {
				font-size: 2rem;
			}
		}
	}

	.theme-switch input {
		display: none;
	}

	.slider {
		background-color: var(--color-toggle-light);
		bottom: 0;
		cursor: pointer;
		left: 0;
		position: absolute;
		right: 0;
		top: 0;
		transition: 0.4s;
	}

	.slider:before {
		--offset: 2px;
		--size: 20px;

		position: absolute;
		left: var(--offset);
		bottom: var(--offset);

		content: '';
		transition: 0.4s;
		width: var(--size);
		height: var(--size);
		font-size: calc(var(--size) / 2);
		background-color: var(--color-accent);
	}

	@media (max-width: 1000px) {
		.slider:before {
			--offset: 3px;
			--size: 30px;
		}
	}

	input:checked + .slider {
		background-color: var(--color-toggle);
	}

	input:checked + .slider:before {
		transform: translateX(16px);
	}

	@media (max-width: 1000px) {
		input:checked + .slider:before {
			transform: translateX(24px);
		}
	}

	.slider.round {
		border-radius: 34px;
	}

	.slider.round:before {
		border-radius: 50%;
	}
</style>

================
File: src/lib/components/ElectionCountDown.svelte
================
<script lang="ts">
	import { daysUntilFutureDate } from '$lib/utils'

	const electionDay = new Date('2024-11-05')
	const inaugurationDay = new Date('2025-01-20')
</script>

<section>
	<span class="header">Countdown To The Election</span>
	<p class="blue bold op-shadow">
		Only <span class="red mono">{daysUntilFutureDate(electionDay)}</span> days left!!
	</p>
	<span class="reminder">ELECTION DAY IS THE LAST DAY TO VOTE, VOTE NOW!</span>
	<span class="header">Countdown To Inauguration Day</span>
	<p class="blue bold op-shadow">
		<span class="red mono">{daysUntilFutureDate(inaugurationDay)}</span>
	</p>
</section>

<style>
	.header {
		font-size: 1.8rem;
		font-weight: bold;
		color: var(--color-text);
	}
	section {
		display: grid;
		place-content: center;
		text-align: center;
		background-image: linear-gradient(45deg, rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.15)),
			linear-gradient(
				to right,
				rgba(196, 0, 0, 0.65),
				rgba(197, 197, 197, 0.45),
				rgba(0, 35, 173, 0.65)
			),
			url('https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727595366/American_Flag_vgd5il.webp');
		background-size: cover;
		text-shadow: 0px 2px 2px var(--color-text-op);
		border: 2px solid var(--color-accent);

		p {
			display: inline-block;
			width: 100%;
			font-size: 2rem;
			padding: 0;
			margin: 0;
			text-shadow: 2px 2px 2px var(--color-text-op);
		}
	}
</style>

================
File: src/lib/components/ExternalLink.svelte
================
<script lang="ts">
	interface Props {
		children: any
		href: string
		text?: string
	}
	let { children, href, text } = $props() as Props
</script>

<a {href} target="_blank" rel="noopener noreferrer">
	{#if text}
		{text}
	{:else}
		{@render children()}
	{/if}
	<iconify-icon icon="fe:link-external"></iconify-icon>
</a>

<style>
	a {
		display: inline-flex;
		text-decoration: none;
		color: var(--color-text);
		border-bottom: 2px dotted var(--color-accent);

		&:hover {
			color: var(--color-text);
			border-bottom: 2px solid var(--color-accent);
		}
	}
</style>

================
File: src/lib/components/Footer.svelte
================
<script>
	import { description } from '$lib/config'
	import { BuyMeACoffee } from '$lib'
</script>

<footer>
	<span class="logo-span header-font">
		<span class="red">Trump</span>
		<span class="op-shadow">Talk</span>
		<span class="blue">45/47</span>
	</span>
	<p>&copy; {new Date().getFullYear()}</p>
	<ul>
		<li>
			<a aria-label="Youtube" href="http://www.youtube.com/@TrumpTalk4547">
				<iconify-icon icon="fa6-brands:youtube"></iconify-icon>
			</a>
		</li>
		<li>
			<a aria-label="X" href="https://x.com/TrumpTalk4547">
				<iconify-icon icon="fa6-brands:x-twitter"></iconify-icon>
			</a>
		</li>
		<li>
			<a aria-label="Spotify" href="https://open.spotify.com/show/7wBMRk8wLKJIrQjmLHE0jy">
				<iconify-icon icon="fa6-brands:spotify"></iconify-icon>
			</a>
		</li>
		<li>
			<a aria-label="Patreon" href="https://www.patreon.com/TrumpTalk4547">
				<iconify-icon icon="fa6-brands:patreon"></iconify-icon>
			</a>
		</li>
		<li>
			<a aria-label="Discord" href="https://discord.gg/pB4DCCyC">
				<iconify-icon icon="fa6-brands:discord"></iconify-icon>
			</a>
		</li>
	</ul>
	<BuyMeACoffee />
</footer>

<style>
	footer {
		display: flex;
		justify-content: space-around;
		align-items: center;
		border-top: 2px solid var(--color-accent);
		margin-top: 2rem;
		padding: 2rem 1rem;
		text-align: center;

		p {
			font-size: 1rem;
			margin: 0;
		}

		ul {
			display: flex;
			list-style: none;
			margin: 0;
			padding: 0;
			gap: 1rem;

			a {
				color: var(--color-text);
				font-size: 1rem;
			}
		}
	}

	@media (max-width: 1000px) {
		footer {
			flex-direction: column;

			ul {
				margin-top: 1rem;
				flex-wrap: wrap;
				justify-content: center;
			}
		}
	}
</style>

================
File: src/lib/components/Header.svelte
================
<script>
	import * as config from '$lib/config'
	import { Image, Meta, Nav } from '$lib'

	const links = config.nav_links
</script>

<Meta />

<header>
	<a href="/">
		<Image
			src="https://res.cloudinary.com/tithos/image/upload/c_scale,q_auto:eco,w_150/v1729009614/Trump_Talk_Logo_rrlvas.svg"
			alt="Trump Talk 45/47"
			width="200"
			className="logo"
		/>
		<p>{config.description}</p>
	</a>
	<Nav {links} />
</header>

<style>
	header {
		display: flex;
		justify-content: space-between;
		align-items: end;
		padding-top: 1.5rem;
		border-bottom: 3px solid var(--color-accent);
		margin-bottom: 2rem;
		padding-bottom: 1rem;

		margin-bottom: 1rem;

		a {
			display: flex;
			place-items: end;
			gap: 0.5rem;
			text-decoration: none;
			color: var(--text);
		}

		p {
			font-size: 1rem;
			margin: 0;
			padding: 0;
		}
	}

	@media (max-width: 1000px) {
		header {
			flex-direction: column;
		}

		a {
			flex-direction: column;
			justify-content: center;
			margin: 0 auto;

			:global(.logo) {
				margin: 0 auto;
			}
		}

		p {
			text-align: center;
			line-height: 2rem;
		}
	}
</style>

================
File: src/lib/components/Image.svelte
================
<script lang="ts">
	type Props = {
		alt: string
		border?: boolean
		padding?: boolean
		width?: number
		src: string
		className?: string
	}

	let { alt, border = true, padding = 0, width = '100%', src, className = '' } = $props() as Props
</script>

<img
	style={`width: ${width}px; padding: ${padding ? '0 1rem' : 0}`}
	class={className}
	{src}
	{alt}
	loading="lazy"
/>

<style>
	img {
		height: auto;
		max-width: 100%;
		object-fit: contain;
	}
</style>

================
File: src/lib/components/ImageSlider.svelte
================
<script lang="ts">
	import type { Image } from '$lib/types'

	type Props = {
		images: Image[]
		text?: string
	}

	let { images, text = '' } = $props() as Props
</script>

<section id="sectionPin">
	<div class="pin-wrap-sticky">
		<div class="pin-wrap">
			<p class="imageText">{text}</p>
			{#each images as { src, alt }}
				<img {src} {alt} />
			{/each}
		</div>
	</div>
</section>

<style>
	@keyframes move {
		to {
			/* Move horizontally so that right edge is aligned against the viewport */
			transform: translateX(calc(-100% + 100vw));
		}
	}

	#sectionPin {
		/* Stretch it out, so that we create room for the horizontal scroll animation */
		height: 500vh;
		overflow: visible; /* To make position sticky work … */

		view-timeline-name: --section-pin-tl;
		view-timeline-axis: block;
	}

	.pin-wrap-sticky {
		/* Stick to Top */
		height: 100vh;
		width: 1000px;
		position: sticky;
		top: 0;
		overflow-x: hidden;
	}

	.pin-wrap {
		display: flex;
		align-items: center;
		height: 100vh;
		width: fit-content;

		/* Hook animation */
		will-change: transform;
		animation: linear move forwards;

		/* Link animation to view-timeline */
		animation-timeline: --section-pin-tl;
		animation-range: contain 0% contain 100%;
	}

	p {
		text-align: center;
	}

	img {
		height: 100%;
		width: auto;
		object-fit: contain;
		scroll-snap-align: center;
		scroll-snap-align: start;
	}

	@media (max-width: 1000px) {
		#sectionPin {
			width: 100% !important;
			height: fit-content !important;
			overflow: visible !important;
		}
		img {
			max-width: 100% !important;
			height: auto !important;
		}

		.pin-wrap-sticky {
			position: relative;
		}

		.pin-wrap {
			flex-direction: column;
		}
	}
</style>

================
File: src/lib/components/Meta.svelte
================
<script>
	import { author, name, description, keywords } from '$lib/config'
</script>

<svelte:head>
	<title>{name}</title>
	<meta name="description" content={description} />
	<meta name="keywords" content={keywords} />
	<meta name="author" content={author} />
</svelte:head>

================
File: src/lib/components/Nav.svelte
================
<script>
	import { page } from '$app/stores'
	let links = $props()
</script>

<nav>
	<ul>
		{#each links.links as { url, text }}
			<li><a href={url} class:active={$page.url.pathname === url}>{text}</a></li>
		{/each}
	</ul>
</nav>

<style>
	ul {
		display: flex;
		list-style: none;
		margin: 0;
		padding: 0;
		gap: 1rem;
	}

	@media (max-width: 1000px) {
		nav {
			margin: 5px auto 0 auto;
			font-size: 1.25rem;
		}
	}

	:global(.active) {
		text-decoration: underline;
		text-decoration-color: var(--color-accent);
		text-decoration-thickness: 3px;
	}
</style>

================
File: src/lib/components/Posts.svelte
================
<script lang="ts">
	import type { Post } from '$lib/types'
	import BlogLink from './BlogLink.svelte'

	const { posts } = $props() as { posts: Post[] }
</script>

<section>
	<ul class="posts">
		{#each posts as post, i}
			<li class="post" style={`--transition-name: post-${post.slug}`}>
				<BlogLink {post} />
			</li>
		{/each}
	</ul>
</section>

<style>
	.posts {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
		gap: 1rem;

		li {
			padding: 0;
			margin: 0;
		}
	}

	@media (max-width: 1000px) {
		.posts {
			gap: 0.5rem;
		}
	}
</style>

================
File: src/lib/components/SponsorLink.svelte
================
<script lang="ts">
	interface Props {
		children: any
		href: string
		text?: string
	}
	let { children, href, text } = $props() as Props
</script>

<a {href} target="_blank" rel="noopener noreferrer">
	{#if text}
		{text}
	{:else}
		<span>{@render children()}</span>
	{/if}
</a>

<style>
	a {
		display: inline-flex;
		text-decoration: none;
		color: var(--color-text);
		border-bottom: 2px dotted var(--color-accent);

		&:hover {
			color: var(--color-text);
			border-bottom: 2px solid var(--color-accent);
		}
	}

	span {
		font-size: clamp(1.5rem, 3vw, 2.5rem);
		margin: 0.5rem 0;
		color: var(--color-text);
	}
</style>

================
File: src/lib/components/Sponsors.svelte
================
<script lang="ts">
	import { Image, SponsorLink, USAFacts } from '$lib'
</script>

<section>
	<h2>Links and other resources</h2>

	<div class="resources">
		<SponsorLink href="https://swampthevoteusa.com">
			<Image
				src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728170297/Swamp_the_Vote_Logo_utbuob.png"
				alt="Swamp the Vote Logo"
				className="logo"
			/>
		</SponsorLink>
		<SponsorLink href="https://petition.theamericapac.org">
			<Image
				src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728530480/American-pac_vjzl3k.jpg"
				alt="America PAC Logo"
				className="logo"
			/>
		</SponsorLink>
		<SponsorLink href="https://www.faithfulelections.org/rcv">
			<Image
				src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728877798/rank-choice-voting_fogo0l.png"
				alt="No rank Choice Voting Logo"
				className="logo"
			/>
		</SponsorLink>

		<SponsorLink href="https://www.rev.com/blog/transcript-category/donald-trump-transcripts">
			Donald Trump Transcripts
		</SponsorLink>

		<a class="external" href="https://usafacts.org" target="_blank" rel="noopener noreferrer">
			<svg class="svg-logo" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 182 23">
				<path
					fill="currentColor"
					d="m56.098.535-9.466 20.92h1.996l2.51-5.598h11.799l.054.124 2.426 5.474h2.117L58.07.535zm-4.205 13.587.13-.291 5.033-11.226 5.13 11.517zM16.048 12.794c0 2.326-.59 4.126-1.752 5.348-1.168 1.228-2.796 1.85-4.842 1.85-2.087 0-3.743-.65-4.92-1.929-1.169-1.274-1.762-3.097-1.762-5.42V.688H.793v12.109c0 2.857.785 5.093 2.33 6.648C4.67 21 6.779 21.787 9.392 21.787c2.633 0 4.752-.793 6.298-2.358 1.546-1.568 2.33-3.861 2.33-6.816V.685h-1.976v12.109zM39.263 12.272c-1.066-.909-2.802-1.633-5.159-2.15-2.29-.493-3.806-1.041-4.637-1.672-.846-.643-1.276-1.543-1.276-2.676 0-1.05.443-1.934 1.32-2.628.858-.683 2.002-1.028 3.395-1.028 2.172 0 4.215.743 6.076 2.21l1.142-1.512C38.047 1.203 35.639.383 32.967.383c-1.96 0-3.593.535-4.86 1.587-1.257 1.041-1.894 2.393-1.894 4.015 0 1.641.539 2.915 1.604 3.79 1.09.89 2.887 1.617 5.343 2.15 2.19.454 3.642.982 4.442 1.612.815.644 1.228 1.533 1.228 2.644 0 1.132-.465 2.07-1.383 2.78-.897.702-2.089 1.057-3.543 1.057-1.459 0-2.783-.25-3.941-.744-1.105-.467-2.213-1.195-3.3-2.163l-1.215 1.437c2.434 2.126 5.25 3.204 8.365 3.204 2.058 0 3.767-.539 5.073-1.604 1.296-1.054 1.953-2.47 1.953-4.21.002-1.538-.529-2.772-1.576-3.666M76.478 21.085h4.537V13.1h9.84V8.974h-9.84V4.585h11.167V.46H76.478zM103.116.313l-8.839 20.772h4.626l1.885-4.626h8.722l1.885 4.626h4.743L107.299.313zm-.706 12.14 2.739-6.69 2.739 6.69zM130.403 17.255c-3.535 0-5.982-2.946-5.982-6.483v-.056c0-3.537 2.504-6.424 5.982-6.424 2.063 0 3.683.882 5.274 2.328l2.887-3.33c-1.915-1.885-4.243-3.183-8.132-3.183-6.335 0-10.755 4.802-10.755 10.667v.059c0 5.922 4.509 10.606 10.578 10.606 3.979 0 6.335-1.413 8.457-3.682l-2.889-2.918c-1.618 1.474-3.061 2.416-5.42 2.416M143.46 4.644h6.276v16.441h4.539V4.644h6.274V.459H143.46zM174.551 8.74c-3.566-.914-4.45-1.357-4.45-2.711v-.057c0-1.002.913-1.798 2.652-1.798s3.535.768 5.363 2.033l2.356-3.417c-2.091-1.68-4.656-2.624-7.661-2.624-4.213 0-7.219 2.476-7.219 6.217v.059c0 4.095 2.68 5.243 6.837 6.306 3.448.883 4.154 1.472 4.154 2.622v.059c0 1.208-1.119 1.945-2.976 1.945-2.356 0-4.302-.971-6.156-2.504l-2.683 3.213c2.476 2.21 5.628 3.3 8.752 3.3 4.448 0 7.572-2.3 7.572-6.396v-.058c-.002-3.596-2.359-5.1-6.541-6.19"
				></path>
			</svg>
		</a>

		<a class="external" href="https://tuckercarlson.com" target="_blank" rel="noopener noreferrer">
			<svg xmlns="http://www.w3.org/2000/svg" class="svg-logo" viewBox="0 0 105 47" fill="none"
				><g clip-path="url(#clip0_5202_1200)"
					><mask maskUnits="userSpaceOnUse" x="0" y="0" width="157" height="47"
						><path d="M157 0.863281H0V46.8633H157V0.863281Z" fill="white"></path></mask
					><g mask="url(#mask0_5202_1200)"
						><path
							d="M81.6371 0.863281H22.948C10.2752 0.863281 0 11.161 0 23.8614C0 36.5619 10.2752 46.8595 22.948 46.8595H81.6371C94.3099 46.8595 104.585 36.5619 104.585 23.8614C104.585 11.161 94.3099 0.863281 81.6371 0.863281ZM31.5295 38.5422H23.9755V14.85H15.1042V8.7657H42.3128V8.81851C39.712 10.2745 37.5779 12.3416 36.0837 14.8462H31.5295V38.5384V38.5422ZM59.8296 18.0638L59.2763 18.7201C57.3229 16.3362 54.4361 14.85 51.8051 14.85C47.0928 14.85 43.5285 18.5919 43.5285 23.4842C43.5285 28.3765 47.0928 32.2466 51.8051 32.2466C54.3081 32.2466 57.1949 30.8849 59.2763 28.7575L59.8296 29.3459V36.4412C57.2213 37.9688 54.2516 38.8817 51.425 38.8817C42.4709 38.8817 35.8052 32.2881 35.8052 23.5672C35.8052 14.8462 42.6403 8.5092 51.6772 8.5092C54.4775 8.5092 57.3455 9.29756 59.8296 10.6593V18.0638ZM89.3266 38.5422H82.6647L68.9983 20.2101V38.5422H61.911V8.7657H68.5729L82.2808 27.1393V8.7657H89.3266V38.5422Z"
							fill="#B91414"
						></path></g
					></g
				><defs
					><clipPath id="clip0_5202_1200"
						><rect width="105" height="47" fill="white"></rect></clipPath
					></defs
				></svg
			>
		</a>

		<SponsorLink href="https://deltarescue.org">
			<Image
				src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1729252729/white-logo_pbjded.png"
				alt="Delta Rescue Logo"
				className="logo"
			/>
		</SponsorLink>
	</div>
	<!-- svelte-ignore a11y_missing_attribute -->
	<iframe
		allow="autoplay *; encrypted-media *;"
		frameborder="0"
		style="color-scheme:dark light;width:100%;height:450px;overflow:hidden;background:transparent;"
		sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation"
		src="https://embed.music.apple.com/us/playlist/sounds-of-maga/pl.u-76oN9ABT1gZVV"
	></iframe>
</section>

<style>
	.resources {
		display: grid;
		grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
		gap: 1rem;
		padding-bottom: 1rem;
	}

	.svg-logo {
		width: 100%;
		height: auto;
	}

	@media (max-width: 1000px) {
		.resources {
			flex-wrap: wrap;
			gap: 0.5rem;
		}
	}

	a.external {
		display: inline-flex;
		text-decoration: none;
		color: var(--color-text);
		padding: 0.25rem 0.5rem;
		border-bottom: 2px dotted var(--color-accent);

		&:hover {
			color: var(--color-text);
			border-bottom: 2px solid var(--color-accent);
		}
	}
</style>

================
File: src/lib/components/USAFacts.svelte
================
<svg
	xmlns="http://www.w3.org/2000/svg"
	fill="none"
	viewBox="0 0 182 23"
	id="icon-usafacts-logo-basic"
	class="w-[7.5rem] text-magenta-600"
>
	<path
		fill="currentColor"
		d="m56.098.535-9.466 20.92h1.996l2.51-5.598h11.799l.054.124 2.426 5.474h2.117L58.07.535zm-4.205 13.587.13-.291 5.033-11.226 5.13 11.517zM16.048 12.794c0 2.326-.59 4.126-1.752 5.348-1.168 1.228-2.796 1.85-4.842 1.85-2.087 0-3.743-.65-4.92-1.929-1.169-1.274-1.762-3.097-1.762-5.42V.688H.793v12.109c0 2.857.785 5.093 2.33 6.648C4.67 21 6.779 21.787 9.392 21.787c2.633 0 4.752-.793 6.298-2.358 1.546-1.568 2.33-3.861 2.33-6.816V.685h-1.976v12.109zM39.263 12.272c-1.066-.909-2.802-1.633-5.159-2.15-2.29-.493-3.806-1.041-4.637-1.672-.846-.643-1.276-1.543-1.276-2.676 0-1.05.443-1.934 1.32-2.628.858-.683 2.002-1.028 3.395-1.028 2.172 0 4.215.743 6.076 2.21l1.142-1.512C38.047 1.203 35.639.383 32.967.383c-1.96 0-3.593.535-4.86 1.587-1.257 1.041-1.894 2.393-1.894 4.015 0 1.641.539 2.915 1.604 3.79 1.09.89 2.887 1.617 5.343 2.15 2.19.454 3.642.982 4.442 1.612.815.644 1.228 1.533 1.228 2.644 0 1.132-.465 2.07-1.383 2.78-.897.702-2.089 1.057-3.543 1.057-1.459 0-2.783-.25-3.941-.744-1.105-.467-2.213-1.195-3.3-2.163l-1.215 1.437c2.434 2.126 5.25 3.204 8.365 3.204 2.058 0 3.767-.539 5.073-1.604 1.296-1.054 1.953-2.47 1.953-4.21.002-1.538-.529-2.772-1.576-3.666M76.478 21.085h4.537V13.1h9.84V8.974h-9.84V4.585h11.167V.46H76.478zM103.116.313l-8.839 20.772h4.626l1.885-4.626h8.722l1.885 4.626h4.743L107.299.313zm-.706 12.14 2.739-6.69 2.739 6.69zM130.403 17.255c-3.535 0-5.982-2.946-5.982-6.483v-.056c0-3.537 2.504-6.424 5.982-6.424 2.063 0 3.683.882 5.274 2.328l2.887-3.33c-1.915-1.885-4.243-3.183-8.132-3.183-6.335 0-10.755 4.802-10.755 10.667v.059c0 5.922 4.509 10.606 10.578 10.606 3.979 0 6.335-1.413 8.457-3.682l-2.889-2.918c-1.618 1.474-3.061 2.416-5.42 2.416M143.46 4.644h6.276v16.441h4.539V4.644h6.274V.459H143.46zM174.551 8.74c-3.566-.914-4.45-1.357-4.45-2.711v-.057c0-1.002.913-1.798 2.652-1.798s3.535.768 5.363 2.033l2.356-3.417c-2.091-1.68-4.656-2.624-7.661-2.624-4.213 0-7.219 2.476-7.219 6.217v.059c0 4.095 2.68 5.243 6.837 6.306 3.448.883 4.154 1.472 4.154 2.622v.059c0 1.208-1.119 1.945-2.976 1.945-2.356 0-4.302-.971-6.156-2.504l-2.683 3.213c2.476 2.21 5.628 3.3 8.752 3.3 4.448 0 7.572-2.3 7.572-6.396v-.058c-.002-3.596-2.359-5.1-6.541-6.19"
	></path>
</svg>

================
File: src/lib/config.ts
================
import { dev } from '$app/environment'

export const url = dev ? 'http://localhost:5713' : 'https://trumptalk4547.com'

export const name = 'Trump Talk 45/47'
export const description = "News, Analysis, and Speeches for President Donald J. Trump"
export const author = 'Tim Smith <gonad2019@gmail.com>'
export const keywords = ['svelte', 'kit', 'sveltekit', 'site', 'template']
export const nav_links = [
	{ url: '/', text: 'Home' },
	{ url: '/about', text: 'About' },
	{ url: '/blog', text: 'Blog' },
	{ url: '/contact', text: 'Contact' }
]

================
File: src/lib/index.ts
================
import Analylitics from './components/Analylitics.svelte'
import BlogLink from './components/BlogLink.svelte'
import BuyMeACoffee from './components/BuyMeACoffee.svelte'
import CookieConsent from './components/CookieConsent.svelte'
import DarkModeToggle from './components/DarkModeToggle.svelte'
import ElectionCountDown from './components/ElectionCountDown.svelte'
import ExternalLink from './components/ExternalLink.svelte'
import Footer from './components/Footer.svelte'
import Header from './components/Header.svelte'
import Image from './components/Image.svelte'
import ImageSlider from './components/ImageSlider.svelte'
import Meta from './components/Meta.svelte'
import Nav from './components/Nav.svelte'
import Posts from './components/Posts.svelte'
import SponsorLink from './components/SponsorLink.svelte'
import Sponsors from './components/Sponsors.svelte'
import USAFacts from './components/USAFacts.svelte'

export {
	Analylitics,
	BlogLink,
	BuyMeACoffee,
	CookieConsent,
	DarkModeToggle,
	ElectionCountDown,
	ExternalLink,
	Footer,
	Header,
	Image,
	ImageSlider,
	Meta,
	Nav,
	Posts,
	SponsorLink,
	Sponsors,
	USAFacts
}

================
File: src/lib/types.ts
================
export type Categories = 'sveltekit' | 'svelte'
export type Post = {
	title: string
	slug: string
	description: string
	date: string
	image: string
	categories: Categories[]
	published: boolean
	featured: boolean
}

export type Image = {
	src: string
	alt: string
}

================
File: src/lib/utils.test.ts
================
import { describe, it, expect } from 'vitest'
import { slugify } from './utils'

describe('slugify', () => {
	it('should convert text to lowercase', () => {
		expect(slugify('Hello World')).toBe('hello-world')
	})

	it('should replace spaces with hyphens', () => {
		expect(slugify('Hello World')).toBe('hello-world')
	})

	it('should remove special characters', () => {
		expect(slugify('Hello, World!')).toBe('hello-world')
	})

	it('should replace multiple spaces with a single hyphen', () => {
		expect(slugify('Hello    World')).toBe('hello-world')
	})

	it('should trim leading and trailing hyphens', () => {
		expect(slugify('---Hello World---')).toBe('hello-world')
	})

	it('should replace multiple hyphens with a single hyphen', () => {
		expect(slugify('Hello---World')).toBe('hello-world')
	})

	it('should handle empty strings', () => {
		expect(slugify('')).toBe('')
	})

	it('should handle strings with only special characters', () => {
		expect(slugify('!@#$%^&*()')).toBe('')
	})
})

================
File: src/lib/utils.ts
================
type DateStyle = Intl.DateTimeFormatOptions['dateStyle']

export const formatDate = (date: string, dateStyle: DateStyle = 'medium', locales = 'en') => {
	// Safari is mad about dashes in the date
	const dateToFormat = new Date(date.replaceAll('-', '/'))
	const dateFormatter = new Intl.DateTimeFormat(locales, { dateStyle })
	return dateFormatter.format(dateToFormat)
}

export const slugify = (text: string) => {
	return text
		.toString()
		.trim()
		.toLowerCase()
		.replace(/\s+/g, '-')
		.replace(/[^\w-]+/g, '')
		.replace(/--+/g, '-')
		.replace(/^-+/, '')
		.replace(/-+$/, '')
}

export function daysUntilFutureDate(futureDate: Date): number {
	const currentDate = new Date()
	const timeDifference = futureDate.getTime() - currentDate.getTime()
	const daysDifference = Math.ceil(timeDifference / (1000 * 60 * 60 * 24))
	return daysDifference
}

================
File: src/posts/cory-comperatore.md
================
---
title: Remembering Corey Comperatore - A Hero's Legacy
description: Corey Comperatore, a 50-year-old firefighter and former fire chief from Sarver, Pennsylvania, tragically lost his life during an attempted assassination of former President Donald Trump at a rally in Butler, Pennsylvania, on July 13, 2024. Corey's heroic actions during the attack, where he shielded his family from gunfire, epitomize his lifelong commitment to protecting others.
date: '2024-10-05'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728161471/Fire_House_Tribute_s9xyqg.webp'
categories:
  - Corey Comperatore
  - Butter, PA
  - Donald J Trump
published: true
featured: true
---

<script>
  import { ExternalLink, Image } from '../lib';
</script>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728161471/Fire_House_Tribute_s9xyqg.webp"
  alt="Corey Comperatore memorial jacket and his fire station."
/>

## A Dedicated Firefighter and Family Man

Corey Comperatore, a 50-year-old firefighter and former fire chief from Sarver, Pennsylvania, tragically lost his life during an attempted assassination of former President Donald Trump at a rally in Butler, Pennsylvania, on July 13, 2024. Corey's heroic actions during the attack, where he shielded his family from gunfire, epitomize his lifelong commitment to protecting others.

## A Life of Service and Sacrifice

Corey's life was marked by dedication and service. He graduated from Freeport High School in 1992 and served as a 10-year veteran of the US Army Reserves. His career as a project and tooling engineer at JSP, a plastics manufacturing company, showcased his expertise and work ethic. Beyond his professional accomplishments, Corey was deeply committed to his family and faith. He was known for his regular church attendance and was passionate about spending time with his wife, Helen, and their two daughters, Allyson and Kaylee. Corey's love for his family extended to his two Doberman pinschers, who were also an important part of his life.

## The Tragic Rally Incident

On the fateful day of July 13, 2024, Corey attended a rally in Butler, Pennsylvania, where a gunman attempted to assassinate former President Donald Trump. In a moment of selflessness, Corey protected his family from the gunfire, ultimately sacrificing his life. The attacker was neutralized by Secret Service agents at the scene, but the event left a lasting impact on the community. Two other attendees, David Dutch and James Copenhaver, were injured but survived the attack. The FBI is currently investigating the incident as an assassination attempt.

## Community Mourning and Honors

Corey Comperatore's death has deeply affected the community of Sarver and beyond. Pennsylvania Governor Josh Shapiro praised Corey as a hero, recognizing his bravery and sacrifice. A GoFundMe campaign launched for Corey's family has raised over $1.1 million, reflecting the public's support and appreciation for his actions. Memorials in Corey's honor include flags flown at half-staff and a commemorative service held by his fire company. Friends, neighbors, and local officials have shared heartfelt tributes, remembering Corey as a dedicated, kind, and heroic individual. In the wake of this tragedy, community leaders have called for unity and an end to political violence, hoping to honor Corey's legacy by fostering peace and solidarity.

## Corey's Enduring Legacy

Corey Comperatore's life and actions are a testament to his unwavering commitment to protecting others and serving his community. His legacy of bravery, dedication, and love will continue to inspire and guide those who knew him and the broader community. As we remember Corey, we celebrate a hero whose life was defined by service and sacrifice, and whose memory will forever be cherished.

For more details on Corey's life and the impact of his heroic actions, you can explore the following resources:

- <ExternalLink href="https://www.cbsnews.com/pittsburgh/news/trump-to-honor-family-corey-comperatore-butler-rally/" text="Sister of Corey Comperatore speaks out ahead of Trump's rally" />
- <ExternalLink href="https://www.youtube.com/watch?v=PFU6VZQi_8M" text="Family of Corey Comperatore, Elon Musk among guests at memorial" />

================
File: src/posts/enemies-within.md
================
---
title: The "Enemies Within"
description: Donald Trump did not coin the phrase "enemies within". The concept has been a recurring theme in US history, highlighting the importance of addressing internal threats alongside external ones. This phenomenon has influenced the country's strategic thinking, policy-making, and national security approaches..
date: '2024-10-18'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728161471/Fire_House_Tribute_s9xyqg.webp'
categories:
  - Corey Comperatore
  - Butter, PA
  - Donald J Trump
published: true
featured: true
---

<script>
  import { ExternalLink, Image } from '../lib';
</script>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728161471/Fire_House_Tribute_s9xyqg.webp"
  alt="Corey Comperatore memorial jacket and his fire station."
/>

Donald Trump did not coin the phrase "enemies within". The concept has been a recurring theme in US history, highlighting the importance of addressing internal threats alongside external ones. This phenomenon has influenced the country's strategic thinking, policy-making, and national security approaches.

* **Domestic Insurgencies**: The US has faced various domestic insurgencies, such as the Whiskey Rebellion (1794), the Mormon War (1857-1858), and the Haymarket Affair (1886). These internal conflicts have shaped the country's approach to maintaining law and order, as well as its understanding of the role of government in addressing social and economic grievances.
* **Communist Infiltration**: During the Cold War, the US government perceived communist infiltration as an internal threat. The Red Scare of the 1940s and 1950s led to widespread paranoia and the persecution of suspected communists, including the infamous House Un-American Activities Committee (HUAC) hearings. This period highlights the tension between national security concerns and civil liberties.
* **Domestic Terrorism**: The 1960s and 1970s saw the rise of domestic terrorist groups, such as the Weather Underground and the Symbionese Liberation Army. The FBI's COINTELPRO program, aimed at disrupting and dismantling these groups, raised concerns about government overreach and violations of civil rights.
* **Right-Wing Extremism**: In recent decades, the US has faced threats from right-wing extremist groups, including white supremacists and anti-government militias. The Oklahoma City bombing (1995) and the Charleston church shooting (2015) are notable examples of domestic terrorism linked to these ideologies.
* **Homegrown Jihadism**: The post-9/11 era has seen a growing concern about homegrown jihadist terrorism, with individuals inspired by extremist ideologies and often radicalized online. This phenomenon has led to a shift in US counterterrorism strategies, emphasizing community engagement, online surveillance, and deradicalization efforts.

Throughout its history, the US has struggled to balance the need to address internal threats with the protection of civil liberties and the prevention of government overreach. This ongoing challenge has influenced the development of US national security policies, law enforcement strategies, and community engagement initiatives.

**Key Takeaways**

1. The concept of "enemies within" has been a recurring theme in US history, highlighting the importance of addressing internal threats alongside external ones.
2. Domestic insurgencies, communist infiltration, domestic terrorism, right-wing extremism, and homegrown jihadism have all contributed to this concept's evolution.
3. The US has struggled to balance national security concerns with civil liberties and the prevention of government overreach.
4. This ongoing challenge has influenced US national security policies, law enforcement strategies, and community engagement initiatives.

================
File: src/posts/ice-detention-and-enforcement.md
================
---
title: ICE Detention and Enforcement
description: New ICE report reveals the Biden-Harris administration has let in 425,000 illegal immigrants who are convicted criminals.
date: '2024-09-28'
image: 'https://res.cloudinary.com/tithos/image/upload/c_scale,f_auto,q_auto:eco,w_1000/v1727555109/border-crisis-hero_qbayoz.webp'
categories:
  - Kamala Harris
  - Border Czar
  - Border Crisis
published: true
featured: true
---

<script>
  import { Image } from '../lib';
</script>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727555109/border-crisis-2_hczyd4.png"
  alt="Collin Rugg: New ICE report reveals the Biden-Harris administration has let in 425,000 illegal immigrants who are convicted criminals."
/>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727555109/border-crisis-3_zozn30.png"
  alt="This was the graph the New York Times accused of being false. It's literally just raw data sourced from the CBP nationwide encounters dataset."
/>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727555109/border-crisis-1_rbfpyy.png"
  alt="Yesterday, Mark Cuban joined CNBC and said Kamala Harris was doing a great job protecting the southern border."
/>

# ICE Detention and Enforcement: Key Statistics and Insights

## Detained Individuals

As of September 8, 2024, U.S. Immigration and Customs Enforcement (ICE) held 37,395 individuals in detention. This number reflects the ongoing efforts of ICE to manage and process individuals through its detention system.

## No Criminal Record

A significant portion of those detained by ICE have no criminal record. Specifically, 60.1% of ICE detainees, or 22,471 individuals, have no criminal history. This statistic underscores the diverse nature of the population held in detention, which includes many individuals without prior criminal convictions.

## August 2024 Bookings

In August 2024 alone, 24,696 people were booked into ICE detention. This monthly figure highlights the volume of individuals entering the detention system and the continuous operational demands on ICE facilities and resources.

## Alternatives to Detention (ATD) Programs

In addition to traditional detention, ICE monitors 176,886 individuals through its Alternatives to Detention (ATD) programs. These programs offer various forms of supervision and monitoring, providing an alternative approach to detention for eligible individuals.

## State with Most Detainees

Texas has the highest number of ICE detainees, with 11,641 individuals held in the state. This concentration reflects Texas's significant role in U.S. immigration enforcement due to its geographic location and population.

## Arrests

In August 2024, ICE arrested 8,188 individuals. Additionally, U.S. Customs and Border Protection (CBP) arrested 16,508 individuals during the same period. These arrest figures illustrate the enforcement activities carried out by both agencies as part of their immigration control efforts.

## Historical Data on Arrests

The Enforcement and Removal Operations (ERO) division of ICE most commonly arrests individuals with convictions involving DUI, drug possession, assault, and criminal traffic offenses. This historical data provides insight into the types of criminal offenses that are prevalent among those apprehended by ICE.

## Country of Citizenship

ICE arrests are categorized by country of citizenship and criminal history, including those with U.S. criminal convictions and pending charges. This breakdown helps in understanding the demographics and legal status of individuals targeted by enforcement actions.

## Areas of Responsibility

ICE’s Enforcement and Removal Operations (ERO) has 25 field offices across the United States, each headed by a field office director. These offices are responsible for managing and executing ICE’s mission within their respective jurisdictions.

## Detention Facilities

ICE utilizes approximately 190 facilities across the nation to house detainees. These facilities are essential for the operation of ICE’s detention and removal programs, providing the necessary infrastructure to hold individuals securely.

---

## Removals and Expulsions

### Removals

In Fiscal Year 2023, ICE removed 142,580 individuals from the United States. These removals are part of ICE's broader mandate to enforce immigration laws and ensure public safety.

### Title 42 Expulsions

There were 62,545 Title 42 expulsions in Fiscal Year 2023. These expulsions were conducted under the Title 42 authority, which was guided by the Centers for Disease Control and Prevention (CDC) and ended on May 11, 2023.

### Countries

ICE conducted removals to more than 170 countries worldwide, showcasing the global reach of its enforcement activities. This broad scope emphasizes the international dimensions of immigration enforcement.

### High-Profile Removals

High-profile removals include fugitives wanted for serious crimes such as homicide, gang-related offenses, and terrorism. These cases often attract significant attention due to the severity of the crimes involved.

### Historical Context

Title 42 expulsions were a public health measure implemented during the COVID-19 pandemic, allowing for the rapid expulsion of individuals to prevent the spread of the virus. This policy, guided by the CDC, was in place until May 11, 2023, when it officially ended.

================
File: src/posts/kamalas-coep.md
================
---
title: Kamala Harris Nominated Without Primary Votes
description: Kamala Harris was nominated for the Democratic presidential candidacy without participating in primary elections, a unique scenario resulting from President Joe Biden stepping down. The Democratic Party swiftly rallied behind Harris, demonstrating a strategic move to maintain unity. Notably, influential party figures like Nancy Pelosi played a significant role in consolidating support for Harris.
date: '2024-10-06'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728221958/Kamala_Harris_2024-grad_atlibu.png'
categories:
  - Kamala Harris
  - Nancy Peloci
  - DNC
  - Joe Biden
published: true
featured: true
---

<script>
  import { ExternalLink, Image } from '../lib';
</script>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728221958/Kamala_Harris_2024-grad_atlibu.png"
  alt="Kamala Harris waving on stage after a bloodless coep on President Joe Biden."
/>

## An Unconventional Nomination Process

Kamala Harris was nominated for the Democratic presidential candidacy without participating in primary elections, a unique scenario resulting from President Joe Biden stepping down. The Democratic Party swiftly rallied behind Harris, demonstrating a strategic move to maintain unity. Notably, influential party figures like Nancy Pelosi played a significant role in consolidating support for Harris.

## Delegate Support and Virtual Voting

Harris secured her nomination by gaining the support of 99% of the Democratic delegates through a virtual voting process. This method bypassed the traditional primary elections, showcasing the party’s commitment to a unified front. The Democratic National Committee (DNC) endorsed Harris as the sole candidate, ensuring a seamless transition and avoiding a competitive primary process. Remarkably, the entire nomination process was expedited, taking only 32 hours for Harris to secure the necessary delegate endorsements after Biden's withdrawal. Nancy Pelosi's endorsement was pivotal, leveraging her influence to rally delegates behind Harris.

## Historical Context

This expedited and centralized approach to nomination is reminiscent of earlier, less democratic processes where party leaders had more control over candidate selection. Historically, party leaders often selected candidates without primary elections. The primary system was introduced to give voters more influence, but party leaders still hold significant sway. The 2024 nomination reflects a return to more centralized decision-making by party elites.

## Delegate Support and Party Strategy

Harris received overwhelming support from the delegates, securing 99% of their votes and ensuring her nomination without primary elections. Initially pledged to Joe Biden, many delegates shifted their support to Harris following his withdrawal. The DNC played a crucial role in organizing the delegate voting process, which party officials described as transparent and democratic despite bypassing traditional primaries. Nancy Pelosi's role was particularly significant, as her influence and strategic planning helped to quickly consolidate delegate support for Harris.

## Public and Media Reaction

The nomination of Kamala Harris without primary votes has sparked significant public and media interest. Articles and analyses from various sources provide insights into the process and its implications:

- [How did Kamala Harris wrap up the Democratic nomination?](https://www.brookings.edu/)
- [Democratic Party's choice of Harris was undemocratic](https://www.theconversation.com/)
- [Kamala Harris has earned enough votes to win the nomination](https://www.cnn.com/)

## Conclusion

Kamala Harris's nomination for the Democratic presidential candidacy marks a significant moment in political history, highlighting the evolving nature of party dynamics and electoral processes. While it bypasses traditional primary elections, the swift and decisive support from delegates underscores the party's strategic emphasis on unity and stability heading into the general election. The involvement of influential figures like Nancy Pelosi illustrates the power of party leadership in shaping the nomination process.

================
File: src/posts/no-wars-proxy-wars-forever-wars.md
================
---
title: No Wars, Proxy Wars, Forever Wars
description: A synopsis of the state of war over the past 16 years
date: '2024-09-29'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727595366/Designer_image_dzyumn.webp'
categories:
  - Donald Trump
  - Barack Obama
  - Kamala Harris
  - No Wars
  - Proxy Wars
  - Forever Wars
published: true
featured: true
---

<script>
  import { ExternalLink, Image } from '../lib';
</script>

<Image src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727595366/Designer_image_dzyumn.webp" alt="No Wars, Proxy Wars, Forever Wars" />

## No New Wars

During Donald Trump's first term as President of the United States, one notable aspect of his foreign policy was his avoidance of starting any new wars. This sets him apart from several predecessors, as maintaining a non-interventionist stance in terms of initiating conflicts is a significant deviation in modern U.S. history. However, Trump is not alone in this respect; other modern presidents, such as Jimmy Carter, Gerald Ford, and Richard Nixon, also did not start new wars during their terms.

While Trump refrained from launching new military conflicts, his administration did escalate existing ones. For instance, there was a notable increase in airstrikes in Afghanistan, and his administration provided substantial support to the Saudi-led war in Yemen. These actions highlighted a complex approach to military engagement, where new conflicts were avoided but existing ones were intensified.

Trump's tenure also witnessed several near-misses regarding potential new conflicts. The most prominent of these were with North Korea and Iran, where tensions reached significant heights but ultimately did not result in full-scale wars. Despite these close calls, Trump frequently touted his record of not starting new wars, using it as a point of pride in his farewell address and other public statements.

---

## US Proxy Wars Involving Israel and Gaza

The United States has long been involved in various proxy wars, including the ongoing conflict in Gaza. U.S. involvement has primarily come through substantial military and political support for Israel. This support has positioned the U.S. as a key player in the region, influencing the dynamics of the conflict significantly.

On the other side, Iran, along with its proxies such as Hezbollah and Hamas, has played a significant role in opposing U.S. and Israeli interests in Gaza. This involvement has contributed to a cycle of escalation, with various regional actors, including Iran, the U.S., and their respective allies, continually intensifying the conflict.

Recent events have further complicated the situation. Since October 7, 2023, the war in Gaza has intensified dramatically, leading to significant regional implications. The increased attacks on U.S. and Israeli targets by Iranian proxies have underscored the volatile nature of the conflict. This escalation has not only affected international relations but has also had a domestic impact in the U.S. The conflict has become a contentious issue, particularly on college campuses, where pro-Palestinian and pro-Israeli groups have frequently clashed.

---

## Key Aspects and Impacts of US 'Forever Wars'

The term 'forever wars' refers to the prolonged and seemingly indefinite military engagements that the U.S. has been involved in since the early 2000s. A significant factor in these ongoing conflicts is the Authorization for Use of Military Force (AUMF) passed in 2001 and 2002. These AUMFs gave the U.S. president broad authority to wage war against perceived enemies, leading to extended military actions without clear endpoints.

The financial cost of these wars has been staggering. For example, the Afghanistan War alone has cost over $2.6 trillion, placing a significant burden on the U.S. economy. Beyond the financial implications, the human cost has been profound. These wars have resulted in substantial civilian casualties, and thousands of U.S. troops have been killed, wounded, or left traumatized.

The global impact of these 'forever wars' is far-reaching, affecting international relations and global security. The U.S.'s prolonged military presence in various regions has reshaped geopolitical landscapes and influenced the policies of numerous countries. The indefinite nature of these conflicts has led to a state of perpetual warfare, with no clear end in sight, highlighting the complex and enduring challenges of U.S. military engagement on the global stage.

---

### Top Search Results

- <ExternalLink href="https://www.brennancenter.org/our-work/analysis-opinion/ending-post-911-forever-wars" text="Ending the Post-9/11 Forever Wars" />
- <ExternalLink href="https://www.justsecurity.org/88131/finally-ending-americas-forever-war-part-i-diagnosis/" text="Finally Ending America's Forever War, Part I: Diagnosis" />
- <ExternalLink href="https://thewarhorse.org/american-legacy-of-forever-wars-lives-on-in-its-casualties/" text="American Legacy of Forever Wars Lives on in Its Casualties" />

================
File: src/posts/road-to-270.md
================
---
title: Road to 270 - Sean Spicer - Youtube
description: They are unpacking the 7 states that lead to the White House like never before! I am bringing in a special guest from each of the battleground states to give us up-to-date election information. We are going to discuss voter registration, early turn out, the ground game, and election predictions. You do not want to miss this very special edition of the Sean Spicer Show!
date: '2024-10-15'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1729004091/open-road-20_a0ncji.png'
categories:
  - US Election
  - Polling
  - Sean Spicer
  - Swing States
published: true
featured: true
---

<script>
  import { ExternalLink, Image } from '../lib';
</script>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1729004091/open-road-20_a0ncji.png"
  alt="Road to 270"
/>

## Live! Road To 270 Special Edition

<iframe width="100%" style="aspect-ratio: 16 / 9" src="https://www.youtube.com/embed/68d29T3aWV8?si=CVKXENe_6-ojQQF4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### GEORGIA
[Chip Lake](https://x.com/LakeChip)
Principal | Glendale Strategies

### NORTH CAROLINA
[Stephen Wiley](https://x.com/StephenBWiley)
Executive Director | North Carolina House GOP

### ARIZONA
[George Khalaf](https://x.com/George_Khalaf)
President | [Data Orbital](https://x.com/Data_Orbital)


### NEVADA
[Jeremy Hughes](https://x.com/jeremybhughes)
Consultant | [November Inc.](https://www.novemberinc.com)

### WISCONSIN
[Megan Novak](https://x.com/meganjnovak)
Senior Advisor | [Americans For Prosperity Action Wisconsin](https://x.com/afpwi)

### PENNSYLVANIA
[Scott Presler](https://x.com/ScottPresler)
President | [Early Vote Action](https://earlyvoteaction.com)

### [Emily Greene](https://x.com/EmilyRoseGreene)
Senior Advisor | [Americans For Prosperity Action Pennsylvania](https://x.com/afppennsylvania)

================
File: src/posts/three-stool-plan.md
================
---
title: Trump's Three Legged Stool
description: An easy three point plan of Former Pres. Donald J. Trump to Make America Great Again
date: '2024-09-28'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727639079/the-powerpuff-girls-stool-2_pobppg.webp'
categories:
  - Donald Trump
  - Maga
  - Domestic Policy
published: true
featured: true
---

<script>
  import { ExternalLink, Image } from '../lib';
</script>

<Image src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727639079/the-powerpuff-girls-stool-2_pobppg.webp" alt="Donald J Trump's 3 legged stool to Make America Great Again" />

## Strong Border

A strong sovereign border is essential for a nation’s security, economic stability, and cultural identity. Ensuring the integrity of a country's borders provides multiple benefits that are crucial for maintaining a well-functioning society.

### National Security

A well-protected border is fundamental to national security. It helps prevent the entry of hostile forces, weapons, and contraband, allowing for better control over who enters the country. This control ensures that immigrants enter legally and do not pose a threat to national security.

### Economic Stability

Borders play a crucial role in regulating trade and commerce. A strong border helps prevent illegal smuggling, which can undermine domestic industries and disrupt the economy. By ensuring that goods entering the country are subject to proper inspection and taxation, economic stability is maintained.

### Cultural Identity

Borders define a nation’s territory and help preserve its unique cultural heritage. They provide a sense of belonging and security for citizens, reinforcing national identity and cohesion.

### Rule of Law

A strong sovereign border upholds the rule of law by ensuring that the government has the authority to control its territory and enforce its laws. This enforcement is crucial for maintaining order and protecting the rights of citizens.

While a strong border is essential, it should be balanced with the need for humanitarian assistance and international cooperation. A nation’s immigration policies should strike a balance between security and compassion, ensuring both the safety and the humanitarian needs of individuals.

### Sources and Related Content

- <ExternalLink href="https://www.hoover.org/research/erosion-border-control-and-its-threat-national-sovereignty" text="The Erosion of Border Control and Its Threat to National Sovereignty - Hoover Institution" />
- <ExternalLink href="https://www.cbp.gov/newsroom/stats" text="Stats and Summaries - U.S. Customs and Border Protection" />
- <ExternalLink href="https://www.dhs.gov/topics/border-security#:~:text=Land%2C%20sea%2C%20and%20air%20borders,States'%20first%20unified%20border%20agency." text="Border Security" />
- <ExternalLink href="https://www.dhs.gov/archive/news/2020/10/29/border-wall-system-deployed-effective-and-disrupting-criminals-and-smugglers#:~:text=The%20results%20speak%20for%20themselves,areas%20where%20barriers%20are%20deployed." text="The Border Wall System is Deployed, Effective, and Disrupting Criminals and Smugglers" />
- <ExternalLink href="https://www.republicanleader.senate.gov/newsroom/remarks/sovereign-borders-matter-at-home-and-abroad" text="Sovereign Borders Matter At Home And Abroad - Republican Leader" />

---

### Free and Fair Elections

Free and fair elections are the cornerstone of democratic societies. They provide a mechanism for citizens to express their will, hold their leaders accountable, and shape the direction of their government.

### Accountability

Elections ensure that leaders are accountable to the people they represent. If a leader performs poorly, citizens have the power to vote them out of office, reinforcing the principle of government by the people.

### Representation

Free and fair elections allow for the representation of diverse viewpoints and interests within a society. This inclusivity helps ensure that the government is responsive to the needs of all citizens, promoting a more equitable and just society.

### Legitimacy

Elections legitimize the government in the eyes of the people. When elections are free and fair, citizens are more likely to accept the results and trust their government, which is vital for maintaining social cohesion and political stability.

### Peace and Stability

Free and fair elections can help prevent political instability and violence. When people feel that they have a say in how their government is run, they are less likely to resort to violence, fostering a more peaceful society.

### Economic Development

Free and fair elections promote economic development by creating a stable and predictable political environment. This stability encourages investment and growth, benefiting the overall economy.

In summary, free and fair elections are essential for the functioning of a democratic society. They ensure accountability, representation, legitimacy, peace, and stability, all of which contribute to the well-being and progress of the nation.

---

### The Honest American Press: A Pillar of Democracy

An honest American press plays a crucial role in maintaining a healthy democracy. Here's why:

### Holding Power to Account

Journalists act as watchdogs, investigating and reporting on government actions, corporate practices, and social issues. Their independent scrutiny can expose wrongdoing, corruption, and abuse of power, ensuring that those in positions of authority are held accountable.

### Informing the Public

A reliable press provides citizens with accurate and unbiased information, enabling them to make informed decisions about their lives, communities, and government. This flow of information is essential for a well-informed electorate.

### Promoting Civic Engagement

By shedding light on important issues and fostering public discourse, a free press encourages citizens to participate in the democratic process and hold their elected officials accountable. This engagement is vital for the health of a democracy.

### Protecting Individual Rights

A free press helps safeguard individual rights by exposing violations and advocating for justice. Journalists often bring attention to cases of injustice, prompting action and reform.

### Fostering Innovation and Progress

An honest press can stimulate critical thinking, challenge the status quo, and inspire new ideas, contributing to societal progress and innovation. By providing a platform for diverse voices and perspectives, the press plays a key role in driving forward societal change.

In essence, a free and honest press is essential for a functioning democracy. It serves as a check on power, informs the public, and promotes civic engagement, ultimately ensuring that government remains accountable to the people it represents.

================
File: src/posts/trump-childhood.md
================
---
title: Donald J. Trump's Childhood
description: Donald John Trump was born on June 14, 1946, at Jamaica Hospital in Queens, New York City.
date: '2024-09-25'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727330685/Donald_Trump_2016_Biography_bgtjcg.webp'
categories:
  - Donald Trump
  - Childhood
published: true
featured: false
---

<script>
  import { ExternalLink, Image, ImageSlider } from '../lib';
  const images = [
    { src: "https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727334680/Donald_Trump_Biography_Photos_rroysh.webp", alt: "Young Donald Trump with family" },
    { src: "https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727334680/Donald_Trump_2016_Biography_Photos_1_pjh0af.webp", alt: "Young Donald Trump as a ball player" },
    { src: "https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727334680/Donald_Trump_2016_Biography_Photos_tzfabu.webp", alt: "Donald Trump at military academy" },
    { src: "https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727334680/Donald_Trump_2016_Biography_1_oahr0u.webp", alt: "Donald Trump with his father" }
  ];
</script>

<Image src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727330685/Donald_Trump_2016_Biography_bgtjcg.webp" alt="Donald J Trump as a child" />

**Birth** — Donald John Trump was born on June 14, 1946, at Jamaica Hospital in Queens, New York City.

**Family** — He was the fourth of five children born to Fred Trump, a successful real estate developer, and Mary Anne MacLeod Trump, a Scottish immigrant.

**Neighborhood** — Trump grew up in the upscale Jamaica Estates neighborhood of Queens.

**Early Education** — He attended the private Kew-Forest School from kindergarten through seventh grade.

**Religious Upbringing** — Trump went to Sunday school and was confirmed in 1959 at the First Presbyterian Church in Jamaica, Queens.

**Military Academy** — At age 13, he was enrolled in the New York Military Academy, a private boarding school.

**Higher Education** — Trump attended Fordham University for two years before transferring to the Wharton School of the University of Pennsylvania, where he graduated with a Bachelor of Science in economics in 1968.

<ImageSlider {images} />

## Family Background

**Parents** — Fred Trump was a successful real estate developer, and Mary Anne MacLeod Trump was a Scottish immigrant who came to the U.S. in 1930.

**Siblings** — Trump had four siblings: Maryanne, Fred Jr., Elizabeth, and Robert.

**Neighborhood** — The family lived in Jamaica Estates, an upscale community in Queens, New York.

**Father's Business** — Fred Trump owned a real estate company that developed middle-class rental housing in New York City's outer boroughs.

**Ancestry** — Fred Trump was the son of German immigrants, while Mary Anne MacLeod Trump hailed from Scotland.

### Further reading...

<ExternalLink href="https://en.wikipedia.org/wiki/Donald_Trump" text="Donald Trump - Wikipedia" />

<ExternalLink href="https://millercenter.org/president/trump/life-presidency" text="Donald Trump: Life before the presidency" />

<ExternalLink href="https://www.whitehouse.gov/about-the-white-house/presidents/donald-j-trump/" text="Donald J. Trump (White House)" />

================
File: src/posts/trump-ear.md
================
---
title: Donald J. Trump's Ear
description: Trump sustained a minor injury to his right ear, described as a 'half-moon shape' wound that did not require stitches.
date: '2024-09-27'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727451101/trumps-ear_qwd1xd.webp'
categories:
  - Donald Trump
  - Assasination Attempt
  - Ear
published: true
featured: false
---

<script>
  import { Image, ImageSlider } from '../lib';
  const images = [
    { src: "https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727334680/Donald_Trump_Biography_Photos_rroysh.webp", alt: "Young Donald Trump with family" },
    { src: "https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727334680/Donald_Trump_2016_Biography_Photos_1_pjh0af.webp", alt: "Young Donald Trump as a ball player" },
    { src: "https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727334680/Donald_Trump_2016_Biography_Photos_tzfabu.webp", alt: "Donald Trump at military academy" },
    { src: "https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727334680/Donald_Trump_2016_Biography_1_oahr0u.webp", alt: "Donald Trump with his father" }
  ];
</script>

<Image src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727451102/trumps-ear-3_gurqsc.avif" alt="Trump's bloody right ear after first assasination attempt" />

On July 13, 2024, former President Donald Trump was the target of an assassination attempt during a rally in Butler, Pennsylvania. The event, meant to rally his supporters, quickly turned chaotic as gunfire erupted. Amidst the commotion, Trump sustained a minor injury to his right ear. The wound, described as a ‘half-moon shape,’ did not require stitches but did necessitate medical attention.

Former White House physician Ronny Jackson took charge of treating Trump’s injury. He diligently applied antibiotic ointment and gauze to the wound daily, ensuring it healed without complications. Despite the gravity of the situation, media outlets reported that Trump’s ear appeared relatively unscathed, minimizing initial public concern about the severity of his injury.

The FBI swiftly launched an investigation into the incident. Initial reports were conflicting, with uncertainty about whether Trump’s injury was caused by a bullet or shrapnel. The FBI later confirmed that a bullet or fragments had indeed struck Trump’s ear, clarifying the nature of the injury and the seriousness of the attack. This revelation highlighted the vulnerability of even high-profile figures during public events and raised questions about the adequacy of security measures.

The gunman, identified as Thomas Crooks, was shot and killed after opening fire during the rally. His actions resulted in further tragedy, with one spectator killed and two others critically injured. These casualties underscored the random and devastating impact such acts of violence can have on innocent bystanders.

The media quickly picked up on the incident, with various outlets providing extensive coverage. Articles ranged from detailed accounts of the event to analyses of its broader implications. Notable pieces included discussions on the apparent minimal damage to Trump’s ear and more reflective pieces on the incident's impact on Trump personally and politically. For instance, independent.co.uk noted how Trump’s ear appeared to have ‘gone through less,’ while nymag.com delved into a more personal examination of Trump’s resilience.

This assassination attempt and its aftermath serve as a stark reminder of the persistent threats faced by public figures. It underscores the importance of robust security measures at public events to protect not only the individuals in the spotlight but also their supporters. The incident has sparked renewed discussions about the balance between public accessibility and security, a critical issue in maintaining the safety and integrity of democratic processes.

For those interested in more detailed accounts and analyses of the incident, notable articles include:

- [“Trump’s ear looks like it couldn’t have ‘gone through less’ …”](https://www.independent.co.uk)
- [“I Examined Donald Trump’s Ear — and His Soul”](https://www.nymag.com)
- [“FBI confirms that a bullet struck Trump’s ear during …”](https://www.nbcnews.com)

In conclusion, the assassination attempt on Donald Trump highlights the ongoing risks associated with public life. It serves as a poignant reminder of the need for vigilance and enhanced security measures to safeguard public figures and the democratic events they participate in.

================
File: src/posts/trumps-return-to-buttler.md
================
---
title: Donald J Trump's Triumphant Return to Buttler, PA
description: Donald J Trump, J.D. Vance, Lara Trump, Eric Trump, Elon Musk and others speak at a ralley in Buttler PA. Corey Comperatore was honored and remembered for his heroic sacrifice.
date: '2024-10-05'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728166120/IMG_3043_o5a6ht.png'
categories:
  - Donald J Trump
  - J.D. Vance
  - Lara Trump
  - Eric Trump
  - Elon Musk
  - Corey Comperatore
  - Butter, PA
published: true
featured: true
---

<script>
  import { ExternalLink, Image } from '../lib';
</script>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728166120/IMG_3043_o5a6ht.png"
  alt="Trump dancing while back in Buttler, PA"
/>

<iframe style="width: 100%; height: 550px;" width="560" height="315" src="https://www.youtube.com/embed/Q0JtLHHggAE?si=rWppuUJPuj-wL9WO" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

"FIGHT FIGHT FIGHT, VOTE VOTE VOTE!!" - Elon Musk

"Don't take you registation for grated, check your voter regestration" - Elon Musk

================
File: src/posts/visa-pelosi.md
================
---
title: Controversy Over Nancy Pelosi's Husband's Visa Stock Trades
description: Paul Pelosi, husband of Nancy Pelosi, sold 2,000 shares of Visa stock worth between $500,000 and $1 million on July 1, 2024.
date: '2024-09-27'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727598017/paul-pelosi_nawalj.webp'
categories:
  - Donald Trump
  - Childhood
published: true
featured: true
---

<script>
  import { ExternalLink, Image, ImageSlider } from '../lib';
</script>

<Image src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727598017/paul-pelosi_nawalj.webp" alt="Paul and Nancy Pelosi" />

On July 1, 2024, Paul Pelosi, the husband of former House Speaker Nancy Pelosi, sold 2,000 shares of Visa stock valued between $500,000 and $1 million. This transaction became a focal point of controversy following a significant legal action by the U.S. Department of Justice (DOJ). On September 24, 2024, the DOJ filed an antitrust lawsuit against Visa, accusing the company of monopolizing the debit card market. The announcement of this lawsuit caused Visa's stock price to plummet by 5.5%.

The timing of Paul Pelosi's stock sale, just two months before the DOJ's lawsuit, drew immediate scrutiny. The sale was disclosed in a congressional filing on July 3, 2024, and marked as a transaction by Paul Pelosi. This disclosure raised questions and led to various reactions, both from the public and political figures.

## Stock Sale Details

Paul Pelosi’s sale of 2,000 Visa shares on July 1, 2024, valued between $500,000 and $1 million, was officially disclosed in a congressional filing two days later. The transaction was marked as ‘SP,’ indicating it was conducted by the spouse of a member of Congress. This was not the first time Paul Pelosi's trades have garnered attention; his history includes other well-timed trades, such as the sale of Google shares in December 2022, just before another antitrust lawsuit.

## DOJ Antitrust Lawsuit

On September 24, 2024, the DOJ filed a lawsuit against Visa, alleging that the company had unlawfully monopolized the debit card market. According to Attorney General Merrick B. Garland, Visa's conduct had enabled it to amass power and extract excessive fees, earning approximately $7 billion annually in debit swipe fees. Visa's dominant position in the market, holding about a 60% share of debit payments, was central to the DOJ's case.

The immediate impact of the lawsuit's announcement was a 5.5% drop in Visa’s stock price, underscoring the market's reaction to the legal challenges facing the company.

## Public and Political Reactions

The timing of Paul Pelosi’s stock sale led to significant public and political reactions. Former President Donald Trump was vocal in his criticism, calling for Nancy Pelosi to be prosecuted. Trump suggested that she had prior knowledge of the DOJ lawsuit and had tipped off her husband, accusations that have fueled further debate and scrutiny.

Nancy Pelosi's spokesperson has firmly denied these allegations, reiterating that she does not own any stocks and has no involvement in her husband's financial transactions. Despite this defense, critics argue that the timing of the stock sale is suspicious and indicative of potential insider trading.

## Legislative and Public Responses

The incident has reignited discussions about the need for stricter regulations on stock trading by lawmakers and their spouses. There are growing calls for legislation to ban such trades, aiming to prevent conflicts of interest and ensure public trust in governmental processes.

The ‘Nancy Pelosi Stock Tracker’ on X flagged the Visa stock sale, bringing additional public attention to the issue. This tool, which monitors trades by lawmakers and their families, highlights ongoing concerns about the potential for insider knowledge influencing stock market transactions.

## Previous Scrutiny

This is not the first time Paul Pelosi’s stock trades have faced scrutiny. In 2022, his trade involving Nvidia stocks also drew attention, raising similar concerns about the appropriateness and legality of trades conducted by those closely associated with high-ranking government officials.

For those seeking more detailed coverage and varied perspectives on the incident, the following articles provide comprehensive insights:

In conclusion, the controversy surrounding Paul Pelosi’s Visa stock sale and the subsequent DOJ lawsuit against Visa highlights the complexities and potential conflicts of interest inherent in stock trading by individuals closely connected to government officials. This incident has prompted renewed calls for legislative reforms to ensure transparency and maintain public trust in the integrity of elected officials and their families.

### Source Links

- <ExternalLink
    href="https://timesofindia.indiatimes.com/world/us/she-should-be-prosecuted-trump-on-nancy-pelosi-and-husbands-500k-visa-stock-trades/articleshow/113746033.cms"
    text="'She should be prosecuted': Trump on Nancy Pelosi and husband’s $500K visa stock trades"
  />

- <ExternalLink
    href="https://www.csmonitor.com/USA/Latest-News-Wires/2011/1115/Did-Nancy-Pelosi-profit-from-Visa-stock-purchases" text="Did Nancy Pelosi profit from Visa stock purchases?"
  />

- <ExternalLink
    href="https://finance.yahoo.com/news/nancy-pelosi-husband-sold-visa-104400425.html"
    text="Nancy Pelosi’s husband sold Visa shares 2 months before a DOJ lawsuit — some say the trade shouldn't have been allowed"
  />

- <ExternalLink
    href="https://nypost.com/video/pelosis-husband-sold-500k-of-visa-stock-weeks-before-dojs-antitrust-lawsuit-reporter-replay/"
    text="Pelosi’s husband sold $500K of Visa stock weeks before DOJ’s antitrust lawsuit | Reporter Replay"
  />

- <ExternalLink
    href="https://www.dailymotion.com/video/x96ci6a"
    text="Trump Wants Nancy Pelosi Prosecuted Over Husband Paul's Visa Stock Sale Before DOJ Lawsuit: 'You Think It Was Luck? I Don't Think So'"
  />

- <ExternalLink
    href="https://www.skynews.com.au/business/nancy-pelosis-husband-sold-more-than-724000-worth-of-visa-stock-just-weeks-before-us-department-of-justice-antitrust-lawsuit/news-story/4a70e2f017bd08389a3d2b9d52f212f9"
    text="Nancy Pelosi’s husband sold more than $724,000 worth of Visa stock - just weeks before US Department of Justice antitrust lawsuit"
  />

- <ExternalLink
    href="https://nypost.com/2024/09/27/us-news/trump-calls-for-nancy-pelosi-to-be-prosecuted-over-visa-stock-trade"
    text="Nancy Pelosi’s husband sold more than $500K worth of Visa stock — just weeks before DOJ’s antitrust lawsuit"
  />

- <ExternalLink
    href="https://www.aol.com/nancy-pelosi-husband-sold-more-194245405.html"
    text="Nancy Pelosi’s husband sold more than $500K worth of Visa stock — just weeks before DOJ’s antitrust lawsuit"
  />

- <ExternalLink
    href="https://www.reddit.com/r/wallstreetbets/comments/1fppaw3/nancy_pelosis_husband_sold_more_than_500k_worth/"
    text="Nancy Pelosi's husband sold more than $500K in Visa stock ahead of DOJ action"
  />

- <ExternalLink
    href="https://www.foxbusiness.com/politics/nancy-pelosis-husband-sold-more-than-500k-visa-stock-ahead-doj-action"
    text="Nancy Pelosi's husband sold more than $500K in Visa stock ahead of DOJ action"
  />

- <ExternalLink
    href="https://www.youtube.com/watch?v=hQ1i1h6YeXw"
    text="Visa Stock Falls After DOJ Lawsuit, Nancy Pelosi Sold Again (Video)"
  />

- <ExternalLink
    href="https://nypost.com/2024/09/27/us-news/trump-calls-for-nancy-pelosi-to-be-prosecuted-over-visa-stock-trade"
    text="Trump calls for Nancy Pelosi to be ‘prosecuted’ over husband’s $500K Visa stock trade "
  />

- <ExternalLink
    href="https://thehill.com/video/nancy-pelosis-husband-dumps-500k-of-visa-stock-before-massive-doj-lawsuit/10074223/"
    text="Nancy Pelosi's husband dumps $500k of Visa stock before massive DOJ lawsuit"
  />

- <ExternalLink
    href="https://www.youtube.com/watch?v=nJb4xpKjaj0"
    text="Report: Paul Pelosi sold over $500K in Visa stock before DOJ antitrust lawsuit (Video)"
  />

- <ExternalLink
    href="https://represent.us/action/insider-trading"
    text="Congress Cashes in on Insider Trading"
  />

- <ExternalLink
    href="https://www.ibtimes.com/donald-trump-wages-war-against-nancy-pelosi-congressional-insider-trading-3744722"
    text="Donald Trump Wages War Against Nancy Pelosi Congressional Insider Trading"
  />

================
File: src/posts/walz-lies.md
================
---
title: Tim Walz Addresses Past False Statements
description: Tim Walz, the Democratic vice-presidential candidate, recently addressed past false statements during an interview with Shannon Bream on Fox News Sunday. This interview provided Walz with a platform to confront criticisms and clarify misunderstandings that have arisen from his previous statements.
date: '2024-10-06'
image: 'https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728245581/IMG_3115_k88a46.webp'
categories:
  - Shannon Bream
  - Tim Walz
  - Fox News
published: true
featured: true
---

<script>
  import { ExternalLink, Image } from '../lib';
</script>

<Image
  src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1728245581/IMG_3115_k88a46.webp"
  alt="Kamala Harris waving on stage after a bloodless coep on President Joe Biden."
/>

## Interview Context

Tim Walz, the Democratic vice-presidential candidate, recently addressed past false statements during an interview with Shannon Bream on Fox News Sunday. This interview provided Walz with a platform to confront criticisms and clarify misunderstandings that have arisen from his previous statements.

## False Statements and Clarifications

Walz has faced criticism for several inaccuracies, including details about his military rank, a visit to Hong Kong, and his family's use of fertility treatments. During the interview, Walz admitted to misspeaking and emphasized that voters are more concerned with broader political issues than these inaccuracies.

## Military Rank

Walz had inaccurately used his retired military rank in public statements, which became a point of contention. He publicly acknowledged this mistake and expressed his willingness to own up to his errors.

## Hong Kong Visit

He also claimed to have been in Hong Kong during the Tiananmen Square protests, but it was later revealed that he was not in the region until months after the events. Walz addressed this discrepancy, admitting his error and clarifying his timeline.

## Fertility Treatment

Regarding his family's use of fertility treatments, Walz initially stated that they used IVF. He later clarified that they actually used IUI, a different fertility treatment. This correction was part of his effort to be transparent and accurate about his personal life.

Political Impact and Defense
Walz argued that these issues are less significant to voters compared to other political concerns such as the economy and abortion rights. He stated that while his past inaccuracies are important to address, they should not overshadow the broader political issues that matter more to the electorate.

## Interview Highlights

Key Topics
The interview covered Walz's past statements, abortion laws, and broader political issues. Walz defended Minnesota's abortion laws and criticized Trump's stance on a national abortion ban. He also discussed his stance on potential military actions in the Middle East, particularly regarding Iran.

### Media Strategy

This interview is part of a broader media strategy by the Harris-Walz campaign to increase visibility before the election. By addressing these issues head-on, Walz aims to refocus the conversation on the pressing concerns facing the nation.

### Top Search Results

- [Tim Walz Outmaneuvers Fox News Host as He's Grilled on Past Statements](https://thedailybeast.com/)
- [Walz Downplays Past False Statements in Rare Interview](https://politico.com/)
- [Tim Walz Rebuffs Fox News Host Over Minnesota Abortion Laws](https://newsweek.com/)

In conclusion, Tim Walz's interview on Fox News Sunday was a strategic move to address past inaccuracies and refocus on key political issues. By admitting his mistakes and clarifying the truth, Walz aims to demonstrate transparency and accountability, qualities that he believes are essential for earning voters' trust.

================
File: src/routes/about/+page.svelte
================
<script>
	import { Image } from '$lib'
	import { name } from '$lib/config'

	const size = '350px'
</script>

<svelte:head>
	<title>{name} | About</title>
</svelte:head>

<h1><strong>Who is this guy</strong>, and why should I listem ti him?</h1>

<section style="min-height: calc({size} + 20px);">
	<Image
		border={false}
		{size}
		width="350"
		src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1703907649/me_f8wxaa.png"
		alt="The website's creator, Tim Smith"
		className="flow-text"
	/>

	<p>
		Hi everyone! My name's Tim Smith, and I'm a Maryland native with a deep interest in American
		politics. My upbringing fostered a unique perspective: my father, a Republican and successful
		banker, instilled in me a respect for entrepreneurship and strong leadership, while my teacher
		mother, a Democrat, emphasized social responsibility and education. Despite a different path
		from my academically and athletically inclined siblings, I've always gravitated towards
		understanding the world through a different lens.
	</p>

	<p>
		That's where Donald Trump comes in. His unconventional approach to politics resonated deeply
		with me. Through this website, I aim to share news and insights related to Donald Trump, along
		with engaging discussions through my podcast and YouTube channel. Whether you're a longtime
		supporter or a curious observer, I invite you to join the conversation and explore different
		perspectives.
	</p>
</section>

================
File: src/routes/api/posts/+server.ts
================
import { json } from '@sveltejs/kit'
import type { Post } from '$lib/types'

async function getPosts() {
	let posts: Post[] = []

	const paths = import.meta.glob('/src/posts/*.md', { eager: true })

	for (const path in paths) {
		const file = paths[path]
		const slug = path.split('/').at(-1)?.replace('.md', '')

		if (file && typeof file === 'object' && 'metadata' in file && slug) {
			const metadata = file.metadata as Omit<Post, 'slug'>
			const post = { ...metadata, slug } satisfies Post
			post.published && posts.push(post)
		}
	}

	posts = posts.sort(
		(first, second) => new Date(second.date).getTime() - new Date(first.date).getTime()
	)

	return posts
}
export async function GET() {
	const posts = await getPosts()
	return json(posts)
}

================
File: src/routes/blog/[slug]/+page.svelte
================
<script lang="ts">
	import { Utterances } from '@codewithshin/svelte-utterances'
	import { formatDate, slugify } from '$lib/utils'
	import * as config from '$lib/config'
	import Partytown from 'partytown-sveltekit/Partytown.svelte'

	let { data } = $props()
	const { content, metadata: meta } = data
</script>

<svelte:head>
	<title>{config.name} | {meta.title}</title>

	<meta name="robots" content="index, follow" />
	<meta property="og:locale" content="en_US" />
	<meta property="og:site_name" content={config.name} />
	<meta property="og:title" content={meta.title} />
	<meta property="og:description" content={meta.description} />
	<meta property="og:image" content={meta.image} />
	<meta property="og:url" content={`${config.url}/blog/${slugify(meta.title)}`} />
	<meta property="og:type" content="article" />

	<meta name="twitter:creator" content="@TrumpTalk4547" />
	<meta name="twitter:card" content="summary_large_image" />
	<meta name="twitter:site" content="@TrumpTalk4547" />
	<meta name="twitter:title" content={meta.title} />
	<meta name="twitter:description" content={meta.description} />
	<meta name="twitter:image" content={meta.image} />
	<meta name="twitter:url" content={`${config.url}/blog/${slugify(meta.title)}`} />
</svelte:head>

<article>
	<hgroup>
		<h1 style={`--transition-name: post-${slugify(meta.title)}`}>{meta.title}</h1>
		<p class="date">Published at {formatDate(meta.date)}</p>

		<div class="tags">
			{#each meta.categories as category}
				<span class="surface-4">&num;{category}</span>
			{/each}
		</div>
	</hgroup>

	<section class="content">
		{@render content()}
		<Utterances
			reponame="timscodebase/trumptalk4547"
			issue-term="pathname"
			theme="dark-blue"
			crossorigin="anonymous"
			async
		/>
	</section>
</article>

<style>
	article {
		margin-inline: auto;
	}

	.content {
		content-visibility: auto;
		contain-intrinsic-size: 1000px; /* Explained in the next section. */
	}

	h1 {
		text-transform: capitalize;
	}

	h1 + p {
		margin-top: var(--size-2);
		color: var(--text);
		opacity: 0.7;
	}

	.date,
	.tags {
		font-family: var(--font-mono);
	}

	.date {
		margin: 0;
		padding: 0;
	}

	.tags {
		display: flex;
		gap: 5px;
		padding-bottom: 1rem;
	}

	@media (max-width: 1000px) {
		.tags {
			flex-wrap: wrap;
		}
	}
</style>

================
File: src/routes/blog/[slug]/+page.ts
================
import type { PageLoad } from './$types'
import { error } from '@sveltejs/kit'

export const load = (async ({ params }: { params: { slug: string } }) => {
	try {
		const post = await import(`../../../posts/${params.slug}.md`)
		const { default: content, metadata } = post

		return {
			content,
			metadata
		}
	} catch (e) {
		error(404, `Could not find ${params.slug}`)
	}
}) satisfies PageLoad

================
File: src/routes/blog/+page.svelte
================
<script>
	import { ElectionCountDown, Image, Posts } from '$lib'
	import * as config from '$lib/config'

	let data = $props()
	const posts = data.data.posts
</script>

<svelte:head>
	<title>{config.name}</title>
</svelte:head>

<h2>Blog</h2>

<Posts {posts} />

================
File: src/routes/blog/+page.ts
================
import type { PageServerLoad } from './$types'
import type { Post } from '$lib/types'

export const load = (async ({ fetch }) => {
	const response = await fetch('api/posts')
	const posts: Post[] = await response.json()
	return { posts }
}) satisfies PageServerLoad

================
File: src/routes/contact/+page.server.ts
================
import type { PageLoad } from './$types'
import { fail } from '@sveltejs/kit'
import nodemailer from 'nodemailer'
import { SECRET_GMAIL_USERNAME, SECRET_GMAIL_PASSWORD } from '$env/static/private'

export const load = (async () => {
	return {}
}) satisfies PageLoad

/** @type {import('./$types').Actions} */
export const actions = {
	contact: async ({ cookies, request, url }) => {
		try {
			const data = await request.formData()
			const name = data.get('name')
			const email = data.get('email')
			const message = data.get('message')

			if (!name) {
				return fail(400, { name, missing: true })
			}

			if (!email) {
				return fail(400, { email, missing: true })
			}

			if (!message) {
				return fail(400, { message, missing: true })
			}

			const transporter = nodemailer.createTransport({
				host: 'smtp.gmail.com.com',
				port: 465,
				secure: true,
				auth: {
					user: 'trumptalk4547',
					pass: 'WSX2345xcvb9!!'
				}
			})

			const mail_options = {
				from: `"${name}" <${email}>`,
				to: email,
				subject: 'Thanks for reaching out to Trump Talk 45/47',
				text: message
			}

			const info = await transporter.sendMail(mail_options)

			return {
				status: 200,
				body: {
					message: 'Email sent successfully',
					messageId: info.messageId
				}
			}
		} catch (error: any) {
			return fail(500, {
				error: `Internal server error ${error.message}`
			})
		}
	}
}

================
File: src/routes/contact/+page.svelte
================
<script>
	import { name } from './../../lib/config.ts'
	import * as config from '$lib/config'

	let { data, form } = $props()
</script>

<svelte:head>
	<title>{config.name} | Contact</title>
</svelte:head>

<section class="form_wrap">
	<h1>Contact</h1>
	<form method="POST" action="?/contact">
		{#if form?.success}
			<!-- this message is ephemeral; it exists because the page was rendered in
				response to a form submission. it will vanish if the user reloads -->
			<p>Thanks for reaching out {data.name}</p>
		{/if}
		<label>
			<p>Name:</p>
			<input type="text" name="name" />
		</label>
		<label>
			<p>Email:</p>
			<input name="email" type="email" value={form?.email ?? ''} />
		</label>
		<label>
			<p>Message:</p>
			<textarea name="message" rows="5"></textarea>
		</label>
		<button type="submit">Submit</button>
		{#if form?.missing}<p class="error">All fields are required.</p>{/if}
	</form>
</section>

<style>
	.error {
		color: red;
		font-weight: bold;
	}

	.form_wrap {
		max-width: 1000px;
		margin: 0 auto;
	}

	form {
		display: grid;
		gap: 1rem;
		padding: 1rem;
		border-radius: var(--radius-3);
		/* border: 2px solid var(--color-accent); */

		label {
			display: grid;
			grid-template-columns: 100px 1fr;
			gap: 1rem;
			font-size: 1.25rem;

			p {
				margin: 0;
				padding: 0;
			}

			input,
			textarea {
				border-radius: var(--radius-2);
				border: 1px solid var(--color-accent);
				background-color: transparent;
				padding: 0.5rem;
				color: var(--color-text);
				font-size: 1.25rem;
			}
		}

		button {
			background-color: var(--color-accent);
			color: var(--color-text);
			border: none;
			border-radius: var(--radius-2);
			padding: 0.5rem 1rem;
			font-weight: bold;
			cursor: pointer;
		}
	}

	@media (max-width: 1000px) {
		form {
			gap: 0.5rem;
		}

		label {
			grid-template-columns: 1fr;
		}
	}
</style>

================
File: src/routes/contact/+page.ts
================
import type { PageLoad } from './$types'
export const prerender = false

export const load = (async () => {
	return {}
}) satisfies PageLoad

================
File: src/routes/rss.xml/+server.ts
================
import * as config from '$lib/config'
import type { Post } from '$lib/types'

export async function GET({ fetch }) {
	const response = await fetch('api/posts')
	const posts: Post[] = await response.json()

	const headers = { 'Content-Type': 'application/xml' }

	const xml = `
		<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
			<channel>
				<title>${config.name}</title>
				<description>${config.description}</description>
				<link>${config.url}</link>
				<atom:link href="${config.url}/rss.xml" rel="self" type="application/rss+xml"/>
				${posts
					.map(
						(post) => `
						<item>
							<title>${post.title}</title>
							<description>${post.description}</description>
							<link>${config.url}/${post.slug}</link>
							<image>
								<url>${post.image}</url>
								<title>${post.title}</title>
								<link>${config.url}/${post.slug}</link>
							</image>
							<guid isPermaLink="true">${config.url}/${post.slug}</guid>
							<pubDate>${new Date(post.date).toUTCString()}</pubDate>
						</item>
					`
					)
					.join('')}
			</channel>
		</rss>
	`.trim()

	return new Response(xml, { headers })
}

================
File: src/routes/+error.svelte
================
<script>
	import { page } from '$app/stores'
</script>

<div class="error">
	<h1>{$page.status}: {$page.error?.message}</h1>
</div>

<style>
	.error {
		height: 100%;
		display: grid;
		place-content: center;
	}
</style>

================
File: src/routes/+layout.svelte
================
<script lang="ts">
	import 'iconify-icon'
	import { Analylitics, CookieConsent, Footer, Header } from '$lib'
	import { injectSpeedInsights } from '@vercel/speed-insights/sveltekit'
	import { inject } from '@vercel/analytics'
	import PartytownSnippet from 'partytown-sveltekit/PartytownSnippet.svelte'

	injectSpeedInsights()

	let { children } = $props()
	$effect(() => {
		const root = document.documentElement || document.body

		window.addEventListener('pagereveal', async (e) => {
			if (e.viewTransition) {
				const transitionType = determineTransitionType(
					navigation.activation.from,
					navigation.activation.entry
				)
				e.viewTransition.types.add(transitionType)
			}
		})
	})
</script>

<Analylitics />

<div class="wrapper">
	<Header />
	<main>
		<video autoplay muted loop>
			<source
				src="https://res.cloudinary.com/tithos/video/upload/e_vibrance:20,f_auto,q_auto:eco/v1728514925/flag-bg-3_gvjtlm.mp4"
				type="video/mp4"
			/>
		</video>
		{@render children()}
	</main>
	<Footer />
</div>

<CookieConsent />

<PartytownSnippet />

<style>
	.wrapper {
		max-width: 1000px;
		margin-inline: auto;
	}

	video {
		position: fixed;
		top: 0;
		left: 0;
		min-width: 100%;
		min-height: 100%;
		background-size: cover;
		opacity: 0.08;
		z-index: -1;
	}

	@media (max-width: 1000px) {
		.wrapper {
			padding-inline: 1rem;
		}
	}

	:global(:where(p)) {
		padding: 0.5rem 0;
		line-height: 1.75;
		max-inline-size: 100%;
	}
</style>

================
File: src/routes/+page.svelte
================
<script>
	import { ElectionCountDown, Image, Posts, Sponsors } from '$lib'
	import * as config from '$lib/config'

	let data = $props()
	const posts = data.data.posts
</script>

<svelte:head>
	<title>{config.name}</title>
</svelte:head>

<section>
	<p>
		Trump Talk 45/47 is your premier source for comprehensive news, insightful analysis, and
		powerful speeches from President Donald J. Trump. Whether you are looking for the latest updates
		on his initiatives, in-depth breakdowns of his policies, or recordings of his most impactful
		speeches, you'll find it all here. Our goal is to keep you informed and engaged with the
		developments and perspectives of the 45th and 47th President of the United States.
	</p>

	<Image
		src="https://res.cloudinary.com/tithos/image/upload/f_auto,q_auto:eco/v1727323076/Untitled_Sept_25_2024_vm1jwu.png"
		alt="Iconic Donald J Trump picture"
	/>

	<h2>Stay Informed with Our News and Analysis</h2>

	<p>
		Our dedicated team of journalists and analysts provide timely and accurate news coverage of
		President Trump's activities and the broader political landscape. We dive deep into the key
		issues, offering detailed analysis and commentary to help you understand the implications and
		significance of current events. From legislative updates to political rallies, we cover it all
		to ensure you never miss a beat.
	</p>

	<h3>Engage with Our Multimedia Content</h3>

	<p>
		In addition to written content, Trump Talk 45/47 features a podcast and a YouTube channel where
		we discuss the latest news and provide exclusive interviews and commentary. Tune in to our
		podcast for in-depth discussions and insights, or watch our YouTube videos for visual and
		engaging content. Subscribe to stay connected and be part of the conversation surrounding
		President Trump's ongoing influence and legacy.
	</p>

	<ElectionCountDown />
</section>

<Posts {posts} />

<a class="more-articles" href="/blog">More articles &rarr;</a>

<Sponsors />

<style>
	h1 {
		color: var(--color-accent);
		padding-bottom: 10px;
		text-shadow: 2px 2px var(--color-text-op);
	}

	.more-articles {
		display: block;
		color: var(--color-text);
		padding-top: 1.5rem;
		font-weight: bold;

		&:hover {
			text-decoration: none;
		}
	}
</style>

================
File: src/routes/+page.ts
================
import type { PageServerLoad } from './$types'
import type { Post } from '$lib/types'

export const load = (async ({ fetch }) => {
	const response = await fetch('api/posts')
	const posts: Post[] = await response.json()
	const featuredPosts: Post[] = posts.filter((post) => post.featured)

	return { posts: featuredPosts }
}) satisfies PageServerLoad

================
File: src/service-worker/index.ts
================
if ('serviceWorker' in navigator) {
	addEventListener('load', function () {
		navigator.serviceWorker.register('./path/to/service-worker.js')
	})
}

================
File: src/service-worker/service-worker.ts
================
/// <reference types="@sveltejs/kit" />
import { build, files, version } from '$service-worker'

// Create a unique cache name for this deployment
const CACHE = `cache-${version}`

const ASSETS = [
	...build, // the app itself
	...files // everything in `static`
]

self.addEventListener('install', (event) => {
	// Create a new cache and add all files to it
	async function addFilesToCache() {
		const cache = await caches.open(CACHE)
		await cache.addAll(ASSETS)
	}

	event.waitUntil(addFilesToCache())
})

self.addEventListener('activate', (event) => {
	// Remove previous cached data from disk
	async function deleteOldCaches() {
		for (const key of await caches.keys()) {
			if (key !== CACHE) await caches.delete(key)
		}
	}

	event.waitUntil(deleteOldCaches())
})

self.addEventListener('fetch', (event) => {
	// ignore POST requests etc
	if (event.request.method !== 'GET') return

	async function respond() {
		const url = new URL(event.request.url)
		const cache = await caches.open(CACHE)

		// `build`/`files` can always be served from the cache
		if (ASSETS.includes(url.pathname)) {
			const response = await cache.match(url.pathname)

			if (response) {
				return response
			}
		}

		// for everything else, try the network first, but
		// fall back to the cache if we're offline
		try {
			const response = await fetch(event.request)

			// if we're offline, fetch can return a value that is not a Response
			// instead of throwing - and we can't pass this non-Response to respondWith
			if (!(response instanceof Response)) {
				throw new Error('invalid response from fetch')
			}

			if (response.status === 200) {
				cache.put(event.request, response.clone())
			}

			return response
		} catch (err) {
			const response = await cache.match(event.request)

			if (response) {
				return response
			}

			// if there's no cache, then just error out
			// as there is nothing we can do to respond to this request
			throw err
		}
	}

	event.respondWith(respond())
})

================
File: src/app.d.ts
================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {}

================
File: src/app.html
================
<!doctype html>
<html lang="en" data-theme="dark">
	<head>
		<meta charset="utf-8" />
		<link rel="stylesheet" href="%sveltekit.assets%/css/main.css" />
		<link rel="alternate" type="application/atom+xml" href="/rss.xml" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link
			rel="apple-touch-icon"
			sizes="180x180"
			href="%sveltekit.assets%/favicon/apple-touch-icon.png"
		/>
		<link
			rel="icon"
			type="image/png"
			sizes="32x32"
			href="%sveltekit.assets%/favicon/favicon-32x32.png"
		/>
		<link
			rel="icon"
			type="image/png"
			sizes="16x16"
			href="%sveltekit.assets%/favicon/favicon-16x16.png"
		/>
		<link rel="manifest" href="%sveltekit.assets%/favicon/manifest.json" />
		<link rel="mask-icon" href="%sveltekit.assets%/favicon/safari-pinned-tab.svg" color="#0339a6" />
		<meta name="msapplication-TileColor" content="#0339A6" />
		<meta name="theme-color" content="#0339A6" />
		<meta name="google-adsense-account" content="ca-pub-2145750142271743" />
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-FZH87M6DDV">
		</script>
		<script>
			window.dataLayer = window.dataLayer || []

			function gtag() {
				dataLayer.push(arguments)
			}

			gtag('js', new Date())
			gtag('config', 'G-FZH87M6DDV')
		</script>

		<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2145750142271743"
     	crossorigin="anonymous">{}</script>

		<title>Trump Talk 45/47 🇺🇸🇺🇸</title>
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>

		<!-- Test 1 -->
		<ins class="adsbygoogle"
				style="display:block"
				data-ad-client="ca-pub-2145750142271743"
				data-ad-slot="4387845955"
				data-ad-format="auto"
				data-full-width-responsive="true"></ins>
		<script>
				(adsbygoogle = window.adsbygoogle || []).push({});
		</script>
	</body>
</html>

================
File: src/index.test.ts
================
import { describe, it, expect } from 'vitest'

describe('sum test', () => {
	it('adds 1 + 2 to equal 3', () => {
		expect(1 + 2).toBe(3)
	})
})

================
File: static/~partytown/debug/partytown-atomics.js
================
/* Partytown 0.10.2 - MIT builder.io */
;((window) => {
	const isPromise = (v) => 'object' == typeof v && v && v.then
	const noop = () => {}
	const len = (obj) => obj.length
	const getConstructorName = (obj) => {
		var _a, _b, _c
		try {
			const constructorName =
				null === (_a = null == obj ? void 0 : obj.constructor) || void 0 === _a ? void 0 : _a.name
			if (constructorName) {
				return constructorName
			}
		} catch (e) {}
		try {
			const zoneJsConstructorName =
				null ===
					(_c =
						null === (_b = null == obj ? void 0 : obj.__zone_symbol__originalInstance) ||
						void 0 === _b
							? void 0
							: _b.constructor) || void 0 === _c
					? void 0
					: _c.name
			if (zoneJsConstructorName) {
				return zoneJsConstructorName
			}
		} catch (e) {}
		return ''
	}
	const startsWith = (str, val) => str.startsWith(val)
	const isValidMemberName = (memberName) =>
		!(
			startsWith(memberName, 'webkit') ||
			startsWith(memberName, 'toJSON') ||
			startsWith(memberName, 'constructor') ||
			startsWith(memberName, 'toString') ||
			startsWith(memberName, '_')
		)
	const getNodeName = (node) => (11 === node.nodeType && node.host ? '#s' : node.nodeName)
	const randomId = () => Math.round(Math.random() * Number.MAX_SAFE_INTEGER).toString(36)
	const defineConstructorName = (Cstr, value) =>
		((obj, memberName, descriptor) =>
			Object.defineProperty(obj, memberName, {
				...descriptor,
				configurable: true
			}))(Cstr, 'name', {
			value: value
		})
	const htmlConstructorTags = {
		Anchor: 'a',
		DList: 'dl',
		Image: 'img',
		OList: 'ol',
		Paragraph: 'p',
		Quote: 'q',
		TableCaption: 'caption',
		TableCell: 'td',
		TableCol: 'colgroup',
		TableRow: 'tr',
		TableSection: 'tbody',
		UList: 'ul'
	}
	const svgConstructorTags = {
		Graphics: 'g',
		SVG: 'svg'
	}
	const defaultPartytownForwardPropertySettings = {
		preserveBehavior: false
	}
	const arrayMethods = Object.freeze(
		((obj) => {
			const properties = new Set()
			let currentObj = obj
			do {
				Object.getOwnPropertyNames(currentObj).forEach((item) => {
					'function' == typeof currentObj[item] && properties.add(item)
				})
			} while ((currentObj = Object.getPrototypeOf(currentObj)) !== Object.prototype)
			return Array.from(properties)
		})([])
	)
	const InstanceIdKey = Symbol()
	const CreatedKey = Symbol()
	const instances = new Map()
	const mainRefs = new Map()
	const winCtxs = {}
	const windowIds = new WeakMap()
	const getAndSetInstanceId = (instance, instanceId) => {
		if (instance) {
			if ((instanceId = windowIds.get(instance))) {
				return instanceId
			}
			;(instanceId = instance[InstanceIdKey]) || setInstanceId(instance, (instanceId = randomId()))
			return instanceId
		}
	}
	const getInstance = (winId, instanceId, win, doc, docId) => {
		if ((win = winCtxs[winId]) && win.$window$) {
			if (winId === instanceId) {
				return win.$window$
			}
			doc = win.$window$.document
			docId = instanceId.split('.').pop()
			if ('d' === docId) {
				return doc
			}
			if ('e' === docId) {
				return doc.documentElement
			}
			if ('h' === docId) {
				return doc.head
			}
			if ('b' === docId) {
				return doc.body
			}
		}
		return instances.get(instanceId)
	}
	const setInstanceId = (instance, instanceId, now) => {
		if (instance) {
			instances.set(instanceId, instance)
			instance[InstanceIdKey] = instanceId
			instance[CreatedKey] = now = Date.now()
			if (now > lastCleanup + 5e3) {
				instances.forEach((storedInstance, instanceId) => {
					storedInstance[CreatedKey] < lastCleanup &&
						storedInstance.nodeType &&
						!storedInstance.isConnected &&
						instances.delete(instanceId)
				})
				lastCleanup = now
			}
		}
	}
	let lastCleanup = 0
	const mainWindow = window.parent
	const docImpl = document.implementation.createHTMLDocument()
	const config = mainWindow.partytown || {}
	const libPath = (config.lib || '/~partytown/') + 'debug/'
	const logMain = (msg) => {
		console.debug.apply(console, [
			'%cMain 🌎',
			'background: #717171; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;',
			msg
		])
	}
	const winIds = []
	const normalizedWinId = (winId) => {
		winIds.includes(winId) || winIds.push(winId)
		return winIds.indexOf(winId) + 1
	}
	const defineCustomElement = (winId, worker, ceData) => {
		const Cstr = defineConstructorName(
			class extends winCtxs[winId].$window$.HTMLElement {},
			ceData[0]
		)
		const ceCallbackMethods =
			'connectedCallback,disconnectedCallback,attributeChangedCallback,adoptedCallback'.split(',')
		ceCallbackMethods.map(
			(callbackMethodName) =>
				(Cstr.prototype[callbackMethodName] = function (...args) {
					worker.postMessage([15, winId, getAndSetInstanceId(this), callbackMethodName, args])
				})
		)
		Cstr.observedAttributes = ceData[1]
		return Cstr
	}
	const serializeForWorker = ($winId$, value, added, type, cstrName, prevInstanceId) =>
		void 0 !== value && (type = typeof value)
			? 'string' === type || 'number' === type || 'boolean' === type || null == value
				? [0, value]
				: 'function' === type
					? [6]
					: (added = added || new Set()) && Array.isArray(value)
						? added.has(value)
							? [1, []]
							: added.add(value) && [1, value.map((v) => serializeForWorker($winId$, v, added))]
						: 'object' === type
							? serializedValueIsError(value)
								? [
										14,
										{
											name: value.name,
											message: value.message,
											stack: value.stack
										}
									]
								: '' === (cstrName = getConstructorName(value))
									? [2, {}]
									: 'Window' === cstrName
										? [3, [$winId$, $winId$]]
										: 'HTMLCollection' === cstrName || 'NodeList' === cstrName
											? [7, Array.from(value).map((v) => serializeForWorker($winId$, v, added)[1])]
											: cstrName.endsWith('Event')
												? [5, serializeObjectForWorker($winId$, value, added)]
												: 'CSSRuleList' === cstrName
													? [12, Array.from(value).map(serializeCssRuleForWorker)]
													: startsWith(cstrName, 'CSS') && cstrName.endsWith('Rule')
														? [11, serializeCssRuleForWorker(value)]
														: 'CSSStyleDeclaration' === cstrName
															? [13, serializeObjectForWorker($winId$, value, added)]
															: 'Attr' === cstrName
																? [10, [value.name, value.value]]
																: value.nodeType
																	? [
																			3,
																			[
																				$winId$,
																				getAndSetInstanceId(value),
																				getNodeName(value),
																				prevInstanceId
																			]
																		]
																	: [2, serializeObjectForWorker($winId$, value, added, true, true)]
							: void 0
			: value
	const serializeObjectForWorker = (
		winId,
		obj,
		added,
		includeFunctions,
		includeEmptyStrings,
		serializedObj,
		propName,
		propValue
	) => {
		serializedObj = {}
		if (!added.has(obj)) {
			added.add(obj)
			for (propName in obj) {
				if (isValidMemberName(propName)) {
					propValue =
						'path' === propName && getConstructorName(obj).endsWith('Event')
							? obj.composedPath()
							: obj[propName]
					;(includeFunctions || 'function' != typeof propValue) &&
						(includeEmptyStrings || '' !== propValue) &&
						(serializedObj[propName] = serializeForWorker(winId, propValue, added))
				}
			}
		}
		return serializedObj
	}
	const serializeCssRuleForWorker = (cssRule) => {
		let obj = {}
		let key
		for (key in cssRule) {
			validCssRuleProps.includes(key) && (obj[key] = String(cssRule[key]))
		}
		return obj
	}
	let ErrorObject = null
	const serializedValueIsError = (value) => {
		var _a
		ErrorObject = (null === (_a = window.top) || void 0 === _a ? void 0 : _a.Error) || ErrorObject
		return value instanceof ErrorObject
	}
	const deserializeFromWorker = (worker, serializedTransfer, serializedType, serializedValue) => {
		if (serializedTransfer) {
			serializedType = serializedTransfer[0]
			serializedValue = serializedTransfer[1]
			return 0 === serializedType
				? serializedValue
				: 4 === serializedType
					? deserializeRefFromWorker(worker, serializedValue)
					: 1 === serializedType
						? serializedValue.map((v) => deserializeFromWorker(worker, v))
						: 3 === serializedType
							? getInstance(serializedValue[0], serializedValue[1])
							: 5 === serializedType
								? constructEvent(deserializeObjectFromWorker(worker, serializedValue))
								: 2 === serializedType
									? deserializeObjectFromWorker(worker, serializedValue)
									: 8 === serializedType
										? serializedValue
										: 9 === serializedType
											? new window[serializedTransfer[2]](serializedValue)
											: void 0
		}
	}
	const deserializeRefFromWorker = (
		worker,
		{ $winId$: $winId$, $instanceId$: $instanceId$, $refId$: $refId$ },
		ref
	) => {
		ref = mainRefs.get($refId$)
		if (!ref) {
			ref = function (...args) {
				worker.postMessage([
					9,
					{
						$winId$: $winId$,
						$instanceId$: $instanceId$,
						$refId$: $refId$,
						$thisArg$: serializeForWorker($winId$, this),
						$args$: serializeForWorker($winId$, args)
					}
				])
			}
			mainRefs.set($refId$, ref)
		}
		return ref
	}
	const constructEvent = (eventProps) =>
		new ('detail' in eventProps ? CustomEvent : Event)(eventProps.type, eventProps)
	const deserializeObjectFromWorker = (worker, serializedValue, obj, key) => {
		obj = {}
		for (key in serializedValue) {
			obj[key] = deserializeFromWorker(worker, serializedValue[key])
		}
		return obj
	}
	const validCssRuleProps =
		'cssText,selectorText,href,media,namespaceURI,prefix,name,conditionText'.split(',')
	const mainAccessHandler = async (worker, accessReq) => {
		let accessRsp = {
			$msgId$: accessReq.$msgId$
		}
		let totalTasks = len(accessReq.$tasks$)
		let i = 0
		let task
		let winId
		let applyPath
		let instance
		let rtnValue
		let isLast
		for (; i < totalTasks; i++) {
			try {
				isLast = i === totalTasks - 1
				task = accessReq.$tasks$[i]
				winId = task.$winId$
				applyPath = task.$applyPath$
				!winCtxs[winId] &&
					winId.startsWith('f_') &&
					(await new Promise((resolve) => {
						let check = 0
						let callback = () => {
							winCtxs[winId] || check++ > 1e3 ? resolve() : requestAnimationFrame(callback)
						}
						callback()
					}))
				if (1 === applyPath[0] && applyPath[1] in winCtxs[winId].$window$) {
					setInstanceId(
						new winCtxs[winId].$window$[applyPath[1]](
							...deserializeFromWorker(worker, applyPath[2])
						),
						task.$instanceId$
					)
				} else {
					instance = getInstance(winId, task.$instanceId$)
					if (instance) {
						rtnValue = applyToInstance(
							worker,
							winId,
							instance,
							applyPath,
							isLast,
							task.$groupedGetters$
						)
						task.$assignInstanceId$ &&
							('string' == typeof task.$assignInstanceId$
								? setInstanceId(rtnValue, task.$assignInstanceId$)
								: (winCtxs[task.$assignInstanceId$.$winId$] = {
										$winId$: task.$assignInstanceId$.$winId$,
										$window$: {
											document: rtnValue
										}
									}))
						if (isPromise(rtnValue)) {
							rtnValue = await rtnValue
							isLast && (accessRsp.$isPromise$ = true)
						}
						isLast &&
							(accessRsp.$rtnValue$ = serializeForWorker(
								winId,
								rtnValue,
								void 0,
								void 0,
								void 0,
								task.$instanceId$
							))
					} else {
						accessRsp.$error$ = `Error finding instance "${task.$instanceId$}" on window ${normalizedWinId(winId)}`
						console.error(accessRsp.$error$, task)
					}
				}
			} catch (e) {
				isLast ? (accessRsp.$error$ = String(e.stack || e)) : console.error(e)
			}
		}
		return accessRsp
	}
	const applyToInstance = (worker, winId, instance, applyPath, isLast, groupedGetters) => {
		let i = 0
		let l = len(applyPath)
		let next
		let current
		let previous
		let args
		let groupedRtnValues
		for (; i < l; i++) {
			current = applyPath[i]
			next = applyPath[i + 1]
			previous = applyPath[i - 1]
			try {
				if (!Array.isArray(next)) {
					if ('string' == typeof current || 'number' == typeof current) {
						if (i + 1 === l && groupedGetters) {
							groupedRtnValues = {}
							groupedGetters.map((propName) => (groupedRtnValues[propName] = instance[propName]))
							return groupedRtnValues
						}
						instance = instance[current]
					} else {
						if (0 === next) {
							instance[previous] = deserializeFromWorker(worker, current)
							return
						}
						if ('function' == typeof instance[previous]) {
							args = deserializeFromWorker(worker, current)
							'define' === previous &&
								'CustomElementRegistry' === getConstructorName(instance) &&
								(args[1] = defineCustomElement(winId, worker, args[1]))
							'insertRule' === previous &&
								args[1] > len(instance.cssRules) &&
								(args[1] = len(instance.cssRules))
							instance = instance[previous].apply(instance, args)
							if ('play' === previous) {
								return Promise.resolve()
							}
						}
					}
				}
			} catch (err) {
				if (isLast) {
					throw err
				}
				console.debug('Non-blocking setter error:', err)
			}
		}
		return instance
	}
	const mainForwardTrigger = (worker, $winId$, win) => {
		let queuedForwardCalls = win._ptf
		let forwards = (win.partytown || {}).forward || []
		let i
		let mainForwardFn
		let forwardCall = ($forward$, args) =>
			worker.postMessage([
				10,
				{
					$winId$: $winId$,
					$forward$: $forward$,
					$args$: serializeForWorker($winId$, Array.from(args))
				}
			])
		win._ptf = void 0
		forwards.map((forwardProps) => {
			const [property, { preserveBehavior: preserveBehavior }] = ((
				propertyOrPropertyWithSettings
			) => {
				if ('string' == typeof propertyOrPropertyWithSettings) {
					return [propertyOrPropertyWithSettings, defaultPartytownForwardPropertySettings]
				}
				const [property, settings = defaultPartytownForwardPropertySettings] =
					propertyOrPropertyWithSettings
				return [
					property,
					{
						...defaultPartytownForwardPropertySettings,
						...settings
					}
				]
			})(forwardProps)
			mainForwardFn = win
			property.split('.').map((_, i, arr) => {
				mainForwardFn = mainForwardFn[arr[i]] =
					i + 1 < len(arr)
						? mainForwardFn[arr[i]] ||
							((propertyName) => (arrayMethods.includes(propertyName) ? [] : {}))(arr[i + 1])
						: (() => {
								let originalFunction = null
								if (preserveBehavior) {
									const { methodOrProperty: methodOrProperty, thisObject: thisObject } = ((
										window,
										properties
									) => {
										let thisObject = window
										for (let i = 0; i < properties.length - 1; i += 1) {
											thisObject = thisObject[properties[i]]
										}
										return {
											thisObject: thisObject,
											methodOrProperty:
												properties.length > 0
													? thisObject[properties[properties.length - 1]]
													: void 0
										}
									})(win, arr)
									'function' == typeof methodOrProperty &&
										(originalFunction = (...args) => methodOrProperty.apply(thisObject, ...args))
								}
								return (...args) => {
									let returnValue
									originalFunction && (returnValue = originalFunction(args))
									forwardCall(arr, args)
									return returnValue
								}
							})()
			})
		})
		if (queuedForwardCalls) {
			for (i = 0; i < len(queuedForwardCalls); i += 2) {
				forwardCall(queuedForwardCalls[i], queuedForwardCalls[i + 1])
			}
		}
	}
	const readNextScript = (worker, winCtx) => {
		let $winId$ = winCtx.$winId$
		let win = winCtx.$window$
		let doc = win.document
		let scriptSelector = 'script[type="text/partytown"]:not([data-ptid]):not([data-pterror])'
		let blockingScriptSelector = scriptSelector + ':not([async]):not([defer])'
		let scriptElm
		let $instanceId$
		let scriptData
		if (doc && doc.body) {
			scriptElm = doc.querySelector(blockingScriptSelector)
			scriptElm || (scriptElm = doc.querySelector(scriptSelector))
			if (scriptElm) {
				scriptElm.dataset.ptid = $instanceId$ = getAndSetInstanceId(scriptElm, $winId$)
				scriptData = {
					$winId$: $winId$,
					$instanceId$: $instanceId$
				}
				if (scriptElm.src) {
					scriptData.$url$ = scriptElm.src
					scriptData.$orgUrl$ = scriptElm.dataset.ptsrc || scriptElm.src
				} else {
					scriptData.$content$ = scriptElm.innerHTML
				}
				worker.postMessage([7, scriptData])
			} else {
				if (!winCtx.$isInitialized$) {
					winCtx.$isInitialized$ = 1
					mainForwardTrigger(worker, $winId$, win)
					doc.dispatchEvent(new CustomEvent('pt0'))
					{
						const winType = win === win.top ? 'top' : 'iframe'
						logMain(
							`Executed ${winType} window ${normalizedWinId($winId$)} environment scripts in ${(performance.now() - winCtx.$startTime$).toFixed(1)}ms`
						)
					}
				}
				worker.postMessage([8, $winId$])
			}
		} else {
			requestAnimationFrame(() => readNextScript(worker, winCtx))
		}
	}
	const registerWindow = (worker, $winId$, $window$) => {
		if (!windowIds.has($window$)) {
			windowIds.set($window$, $winId$)
			const doc = $window$.document
			const history = $window$.history
			const $parentWinId$ = windowIds.get($window$.parent)
			let initialised = false
			const onInitialisedQueue = []
			const onInitialised = (callback) => {
				initialised ? callback() : onInitialisedQueue.push(callback)
			}
			const sendInitEnvData = () => {
				worker.postMessage([
					5,
					{
						$winId$: $winId$,
						$parentWinId$: $parentWinId$,
						$url$: doc.baseURI,
						$visibilityState$: doc.visibilityState
					}
				])
				setTimeout(() => {
					initialised = true
					onInitialisedQueue.forEach((callback) => {
						callback()
					})
				})
			}
			const pushState = history.pushState.bind(history)
			const replaceState = history.replaceState.bind(history)
			const onLocationChange = (type, state, newUrl, oldUrl) => () => {
				worker.postMessage([
					13,
					{
						$winId$: $winId$,
						type: type,
						state: state,
						url: doc.baseURI,
						newUrl: newUrl,
						oldUrl: oldUrl
					}
				])
			}
			history.pushState = (state, _, newUrl) => {
				pushState(state, _, newUrl)
				onInitialised(onLocationChange(0, state, null == newUrl ? void 0 : newUrl.toString()))
			}
			history.replaceState = (state, _, newUrl) => {
				replaceState(state, _, newUrl)
				onInitialised(onLocationChange(1, state, null == newUrl ? void 0 : newUrl.toString()))
			}
			$window$.addEventListener('popstate', (event) => {
				onInitialised(onLocationChange(2, event.state))
			})
			$window$.addEventListener('hashchange', (event) => {
				onInitialised(onLocationChange(3, {}, event.newURL, event.oldURL))
			})
			$window$.addEventListener('ptupdate', () => {
				readNextScript(worker, winCtxs[$winId$])
			})
			doc.addEventListener('visibilitychange', () =>
				worker.postMessage([14, $winId$, doc.visibilityState])
			)
			winCtxs[$winId$] = {
				$winId$: $winId$,
				$window$: $window$
			}
			winCtxs[$winId$].$startTime$ = performance.now()
			{
				const winType = $winId$ === $parentWinId$ ? 'top' : 'iframe'
				logMain(`Registered ${winType} window ${normalizedWinId($winId$)}`)
			}
			'complete' === doc.readyState
				? sendInitEnvData()
				: $window$.addEventListener('load', sendInitEnvData)
		}
	}
	const onMessageFromWebWorker = (worker, msg, winCtx) => {
		if (4 === msg[0]) {
			registerWindow(worker, randomId(), mainWindow)
		} else {
			winCtx = winCtxs[msg[1]]
			winCtx &&
				(7 === msg[0]
					? requestAnimationFrame(() => readNextScript(worker, winCtx))
					: 6 === msg[0] &&
						((worker, winCtx, instanceId, errorMsg, scriptElm) => {
							scriptElm = winCtx.$window$.document.querySelector(`[data-ptid="${instanceId}"]`)
							if (scriptElm) {
								errorMsg ? (scriptElm.dataset.pterror = errorMsg) : (scriptElm.type += '-x')
								delete scriptElm.dataset.ptid
							}
							readNextScript(worker, winCtx)
						})(worker, winCtx, msg[2], msg[3]))
		}
	}
	const readMainPlatform = () => {
		const elm = docImpl.createElement('i')
		const textNode = docImpl.createTextNode('')
		const comment = docImpl.createComment('')
		const frag = docImpl.createDocumentFragment()
		const shadowRoot = docImpl.createElement('p').attachShadow({
			mode: 'open'
		})
		const intersectionObserver = getGlobalConstructor(mainWindow, 'IntersectionObserver')
		const mutationObserver = getGlobalConstructor(mainWindow, 'MutationObserver')
		const resizeObserver = getGlobalConstructor(mainWindow, 'ResizeObserver')
		const perf = mainWindow.performance
		const screen = mainWindow.screen
		const impls = [
			[mainWindow.history],
			[perf],
			[perf.navigation],
			[perf.timing],
			[screen],
			[screen.orientation],
			[mainWindow.visualViewport],
			[intersectionObserver, 12],
			[mutationObserver, 12],
			[resizeObserver, 12],
			[textNode],
			[comment],
			[frag],
			[shadowRoot],
			[elm],
			[elm.attributes],
			[elm.classList],
			[elm.dataset],
			[elm.style],
			[docImpl],
			[docImpl.doctype]
		]
		const initialInterfaces = [
			readImplementation('Window', mainWindow),
			readImplementation('Node', textNode)
		]
		const $config$ = (function (config) {
			return JSON.stringify(config, (key, value) => {
				if ('function' == typeof value) {
					value = String(value)
					value.startsWith(key + '(') && (value = 'function ' + value)
				}
				'loadScriptsOnMainThread' === key &&
					(value = value.map((scriptUrl) =>
						Array.isArray(scriptUrl)
							? scriptUrl
							: [
									'string' == typeof scriptUrl ? 'string' : 'regexp',
									'string' == typeof scriptUrl ? scriptUrl : scriptUrl.source
								]
					))
				return value
			})
		})(config)
		const initWebWorkerData = {
			$config$: $config$,
			$interfaces$: readImplementations(impls, initialInterfaces),
			$libPath$: new URL(libPath, mainWindow.location) + '',
			$origin$: origin,
			$tabId$: mainWindow._pttab
		}
		addGlobalConstructorUsingPrototype(
			initWebWorkerData.$interfaces$,
			mainWindow,
			'IntersectionObserverEntry'
		)
		return initWebWorkerData
	}
	const readMainInterfaces = () => {
		const elms = Object.getOwnPropertyNames(mainWindow)
			.map((interfaceName) =>
				((doc, interfaceName, r, tag) => {
					r = interfaceName.match(/^(HTML|SVG)(.+)Element$/)
					if (r) {
						tag = r[2]
						return 'S' == interfaceName[0]
							? doc.createElementNS(
									'http://www.w3.org/2000/svg',
									svgConstructorTags[tag] || tag.slice(0, 2).toLowerCase() + tag.slice(2)
								)
							: doc.createElement(htmlConstructorTags[tag] || tag)
					}
				})(docImpl, interfaceName)
			)
			.filter((elm) => elm)
			.map((elm) => [elm])
		return readImplementations(elms, [])
	}
	const readImplementations = (impls, interfaces) => {
		const cstrs = new Set(['Object'])
		const cstrImpls = impls
			.filter((implData) => implData[0])
			.map((implData) => {
				const impl = implData[0]
				const interfaceType = implData[1]
				const cstrName = getConstructorName(impl)
				const CstrPrototype = mainWindow[cstrName].prototype
				return [cstrName, CstrPrototype, impl, interfaceType]
			})
		cstrImpls.map(([cstrName, CstrPrototype, impl, intefaceType]) =>
			readOwnImplementation(cstrs, interfaces, cstrName, CstrPrototype, impl, intefaceType)
		)
		return interfaces
	}
	const readImplementation = (cstrName, impl, memberName) => {
		let interfaceMembers = []
		let interfaceInfo = [cstrName, 'Object', interfaceMembers]
		for (memberName in impl) {
			readImplementationMember(interfaceMembers, impl, memberName)
		}
		return interfaceInfo
	}
	const readOwnImplementation = (
		cstrs,
		interfaces,
		cstrName,
		CstrPrototype,
		impl,
		interfaceType
	) => {
		if (!cstrs.has(cstrName)) {
			cstrs.add(cstrName)
			const SuperCstr = Object.getPrototypeOf(CstrPrototype)
			const superCstrName = getConstructorName(SuperCstr)
			const interfaceMembers = []
			const propDescriptors = Object.getOwnPropertyDescriptors(CstrPrototype)
			readOwnImplementation(cstrs, interfaces, superCstrName, SuperCstr, impl, interfaceType)
			for (const memberName in propDescriptors) {
				readImplementationMember(interfaceMembers, impl, memberName)
			}
			interfaces.push([cstrName, superCstrName, interfaceMembers, interfaceType, getNodeName(impl)])
		}
	}
	const readImplementationMember = (
		interfaceMembers,
		implementation,
		memberName,
		value,
		memberType,
		cstrName
	) => {
		try {
			if (isValidMemberName(memberName) && isNaN(memberName[0]) && 'all' !== memberName) {
				value = implementation[memberName]
				memberType = typeof value
				if ('function' === memberType) {
					;(String(value).includes('[native') ||
						Object.getPrototypeOf(implementation)[memberName]) &&
						interfaceMembers.push([memberName, 5])
				} else if ('object' === memberType && null != value) {
					cstrName = getConstructorName(value)
					'Object' !== cstrName &&
						'Function' !== cstrName &&
						self[cstrName] &&
						interfaceMembers.push([memberName, value.nodeType || cstrName])
				} else {
					'symbol' !== memberType &&
						(memberName.toUpperCase() === memberName
							? interfaceMembers.push([memberName, 6, value])
							: interfaceMembers.push([memberName, 6]))
				}
			}
		} catch (e) {
			console.warn(e)
		}
	}
	const getGlobalConstructor = (mainWindow, cstrName) =>
		void 0 !== mainWindow[cstrName] ? new mainWindow[cstrName](noop) : 0
	const addGlobalConstructorUsingPrototype = ($interfaces$, mainWindow, cstrName) => {
		void 0 !== mainWindow[cstrName] &&
			$interfaces$.push([
				cstrName,
				'Object',
				Object.keys(mainWindow[cstrName].prototype).map((propName) => [propName, 6]),
				12
			])
	}
	let worker
	;(async (receiveMessage) => {
		const sharedDataBuffer = new SharedArrayBuffer(1073741824)
		const sharedData = new Int32Array(sharedDataBuffer)
		return (worker, msg) => {
			const msgType = msg[0]
			const accessReq = msg[1]
			if (0 === msgType) {
				const initData = readMainPlatform()
				initData.$sharedDataBuffer$ = sharedDataBuffer
				worker.postMessage([1, initData])
			} else {
				2 === msg[0]
					? worker.postMessage([3, readMainInterfaces()])
					: 11 === msgType
						? receiveMessage(accessReq, (accessRsp) => {
								const stringifiedData = JSON.stringify(accessRsp)
								const stringifiedDataLength = stringifiedData.length
								for (let i = 0; i < stringifiedDataLength; i++) {
									sharedData[i + 1] = stringifiedData.charCodeAt(i)
								}
								sharedData[0] = stringifiedDataLength
								Atomics.notify(sharedData, 0)
							})
						: onMessageFromWebWorker(worker, msg)
			}
		}
	})((accessReq, responseCallback) =>
		mainAccessHandler(worker, accessReq).then(responseCallback)
	).then((onMessageHandler) => {
		if (onMessageHandler) {
			worker = new Worker(libPath + 'partytown-ww-atomics.js?v=0.10.2', {
				name: 'Partytown 🎉'
			})
			worker.onmessage = (ev) => {
				const msg = ev.data
				12 === msg[0] ? mainAccessHandler(worker, msg[1]) : onMessageHandler(worker, msg)
			}
			logMain('Created Partytown web worker (0.10.2)')
			worker.onerror = (ev) => console.error('Web Worker Error', ev)
			mainWindow.addEventListener('pt1', (ev) =>
				registerWindow(worker, getAndSetInstanceId(ev.detail.frameElement), ev.detail)
			)
		}
	})
})(window)

================
File: static/~partytown/debug/partytown-media.js
================
/* Partytown 0.10.2 - MIT builder.io */
;((self) => {
	const [
		getter,
		setter,
		callMethod,
		constructGlobal,
		definePrototypePropertyDescriptor,
		randomId,
		WinIdKey,
		InstanceIdKey,
		ApplyPathKey
	] = self.$bridgeToMedia$
	delete self.$bridgeToMedia$
	const ContextKey = Symbol()
	const MediaSourceKey = Symbol()
	const ReadyStateKey = Symbol()
	const SourceBuffersKey = Symbol()
	const SourceBufferTasksKey = Symbol()
	const TimeRangesKey = Symbol()
	const EMPTY_ARRAY = []
	const defineCstr = (win, cstrName, Cstr) => (win[cstrName] = defineCstrName(cstrName, Cstr))
	const defineCstrName = (cstrName, Cstr) =>
		Object.defineProperty(Cstr, 'name', {
			value: cstrName
		})
	const initCanvas = (WorkerBase, win) => {
		const HTMLCanvasDescriptorMap = {
			getContext: {
				value(contextType, contextAttributes) {
					this[ContextKey] ||
						(this[ContextKey] = (
							contextType.includes('webgl') ? createContextWebGL : createContext2D
						)(this, contextType, contextAttributes))
					return this[ContextKey]
				}
			}
		}
		const WorkerCanvasGradient = defineCstr(
			win,
			'CanvasGradient',
			class extends WorkerBase {
				addColorStop(...args) {
					callMethod(this, ['addColorStop'], args, 2)
				}
			}
		)
		const WorkerCanvasPattern = defineCstr(
			win,
			'CanvasPattern',
			class extends WorkerBase {
				setTransform(...args) {
					callMethod(this, ['setTransform'], args, 2)
				}
			}
		)
		const createContext2D = (canvasInstance, contextType, contextAttributes) => {
			const winId = canvasInstance[WinIdKey]
			const ctxInstanceId = randomId()
			const ctxInstance = {
				[WinIdKey]: winId,
				[InstanceIdKey]: ctxInstanceId,
				[ApplyPathKey]: []
			}
			const ctx = callMethod(
				canvasInstance,
				['getContext'],
				[contextType, contextAttributes],
				1,
				ctxInstanceId
			)
			const ctx2dGetterMethods =
				'getContextAttributes,getImageData,getLineDash,getTransform,isPointInPath,isPointInStroke,measureText'.split(
					','
				)
			const CanvasRenderingContext2D = {
				get: (target, propName) =>
					'string' == typeof propName && propName in ctx
						? 'function' == typeof ctx[propName]
							? (...args) => {
									if (propName.startsWith('create')) {
										const instanceId = randomId()
										callMethod(ctxInstance, [propName], args, 2, instanceId)
										if ('createImageData' === propName || 'createPattern' === propName) {
											;((api) => {
												console.warn(`${api} not implemented`)
											})(`${propName}()`)
											return {
												setTransform: () => {}
											}
										}
										return new WorkerCanvasGradient(winId, instanceId)
									}
									const methodCallType = ctx2dGetterMethods.includes(propName) ? 1 : 2
									return callMethod(ctxInstance, [propName], args, methodCallType)
								}
							: ctx[propName]
						: target[propName],
				set(target, propName, value) {
					if ('string' == typeof propName && propName in ctx) {
						ctx[propName] !== value &&
							'function' != typeof value &&
							setter(ctxInstance, [propName], value)
						ctx[propName] = value
					} else {
						target[propName] = value
					}
					return true
				}
			}
			return new Proxy(ctx, CanvasRenderingContext2D)
		}
		const createContextWebGL = (canvasInstance, contextType, contextAttributes) => {
			const winId = canvasInstance[WinIdKey]
			const ctxInstanceId = randomId()
			const ctxInstance = {
				[WinIdKey]: winId,
				[InstanceIdKey]: ctxInstanceId,
				[ApplyPathKey]: []
			}
			const ctx = callMethod(
				canvasInstance,
				['getContext'],
				[contextType, contextAttributes],
				1,
				ctxInstanceId
			)
			const WebGLRenderingContextHandler = {
				get: (target, propName) =>
					'string' == typeof propName
						? 'function' != typeof ctx[propName]
							? ctx[propName]
							: (...args) =>
									callMethod(ctxInstance, [propName], args, getWebGlMethodCallType(propName))
						: target[propName],
				set(target, propName, value) {
					if ('string' == typeof propName && propName in ctx) {
						ctx[propName] !== value &&
							'function' != typeof value &&
							setter(ctxInstance, [propName], value)
						ctx[propName] = value
					} else {
						target[propName] = value
					}
					return true
				}
			}
			return new Proxy(ctx, WebGLRenderingContextHandler)
		}
		const ctxWebGLGetterMethods = 'checkFramebufferStatus,makeXRCompatible'.split(',')
		const getWebGlMethodCallType = (methodName) =>
			methodName.startsWith('create') ||
			methodName.startsWith('get') ||
			methodName.startsWith('is') ||
			ctxWebGLGetterMethods.includes(methodName)
				? 1
				: 2
		defineCstr(win, 'CanvasGradient', WorkerCanvasGradient)
		defineCstr(win, 'CanvasPattern', WorkerCanvasPattern)
		definePrototypePropertyDescriptor(win.HTMLCanvasElement, HTMLCanvasDescriptorMap)
	}
	const initMedia = (WorkerBase, WorkerEventTargetProxy, env, win) => {
		var _a, _b
		win.Audio = defineCstrName(
			'HTMLAudioElement',
			class {
				constructor(src) {
					const audio = env.$createNode$('audio', randomId())
					audio.src = src
					return audio
				}
			}
		)
		const WorkerAudioTrack = class extends WorkerBase {
			get enabled() {
				return getter(this, ['enabled'])
			}
			set enabled(value) {
				setter(this, ['enabled'], value)
			}
			get id() {
				return getter(this, ['id'])
			}
			get kind() {
				return getter(this, ['kind'])
			}
			get label() {
				return getter(this, ['label'])
			}
			get language() {
				return getter(this, ['language'])
			}
			get sourceBuffer() {
				return new WorkerSourceBuffer(this)
			}
		}
		const WorkerAudioTrackList = class {
			constructor(mediaElm) {
				const winId = mediaElm[WinIdKey]
				const instanceId = mediaElm[InstanceIdKey]
				const instance = {
					addEventListener(...args) {
						callMethod(mediaElm, ['audioTracks', 'addEventListener'], args, 3)
					},
					getTrackById: (...args) => callMethod(mediaElm, ['audioTracks', 'getTrackById'], args),
					get length() {
						return getter(mediaElm, ['audioTracks', 'length'])
					},
					removeEventListener(...args) {
						callMethod(mediaElm, ['audioTracks', 'removeEventListener'], args, 3)
					}
				}
				return new Proxy(instance, {
					get: (target, propName) =>
						'number' == typeof propName
							? new WorkerAudioTrack(winId, instanceId, ['audioTracks', propName])
							: target[propName]
				})
			}
		}
		const WorkerSourceBufferList = defineCstr(
			win,
			'SourceBufferList',
			class extends Array {
				constructor(mediaSource) {
					super()
					this[MediaSourceKey] = mediaSource
				}
				addEventListener(...args) {
					callMethod(this[MediaSourceKey], ['sourceBuffers', 'addEventListener'], args, 3)
				}
				removeEventListener(...args) {
					callMethod(this[MediaSourceKey], ['sourceBuffers', 'removeEventListener'], args, 3)
				}
			}
		)
		const WorkerSourceBuffer = defineCstr(
			win,
			'SourceBuffer',
			((_b = class extends WorkerEventTargetProxy {
				constructor(mediaSource) {
					super(mediaSource[WinIdKey], mediaSource[InstanceIdKey], ['sourceBuffers'])
					this[_a] = []
					this[MediaSourceKey] = mediaSource
				}
				abort() {
					const sbIndex = getSourceBufferIndex(this)
					callMethod(this, [sbIndex, 'appendWindowStart'], EMPTY_ARRAY, 1)
				}
				addEventListener(...args) {
					const sbIndex = getSourceBufferIndex(this)
					callMethod(this, [sbIndex, 'addEventListener'], args, 3)
				}
				appendBuffer(buf) {
					this[SourceBufferTasksKey].push(['appendBuffer', [buf], buf])
					drainSourceBufferQueue(this)
				}
				get appendWindowStart() {
					const sbIndex = getSourceBufferIndex(this)
					return getter(this, [sbIndex, 'appendWindowStart'])
				}
				set appendWindowStart(value) {
					const sbIndex = getSourceBufferIndex(this)
					setter(this, [sbIndex, 'appendWindowStart'], value)
				}
				get appendWindowEnd() {
					const sbIndex = getSourceBufferIndex(this)
					return getter(this, [sbIndex, 'appendWindowEnd'])
				}
				set appendWindowEnd(value) {
					const sbIndex = getSourceBufferIndex(this)
					setter(this, [sbIndex, 'appendWindowEnd'], value)
				}
				get buffered() {
					const mediaSource = this[MediaSourceKey]
					const sbIndex = getSourceBufferIndex(this)
					const timeRanges = new WorkerTimeRanges(
						mediaSource[WinIdKey],
						mediaSource[InstanceIdKey],
						['sourceBuffers', sbIndex, 'buffered']
					)
					return timeRanges
				}
				changeType(mimeType) {
					const sbIndex = getSourceBufferIndex(this)
					callMethod(this, [sbIndex, 'changeType'], [mimeType], 2)
				}
				get mode() {
					const sbIndex = getSourceBufferIndex(this)
					return getter(this, [sbIndex, 'mode'])
				}
				set mode(value) {
					const sbIndex = getSourceBufferIndex(this)
					setter(this, [sbIndex, 'mode'], value)
				}
				remove(start, end) {
					this[SourceBufferTasksKey].push(['remove', [start, end]])
					drainSourceBufferQueue(this)
				}
				removeEventListener(...args) {
					const sbIndex = getSourceBufferIndex(this)
					callMethod(this, [sbIndex, 'removeEventListener'], args, 3)
				}
				get timestampOffset() {
					const sbIndex = getSourceBufferIndex(this)
					return getter(this, [sbIndex, 'timestampOffset'])
				}
				set timestampOffset(value) {
					const sbIndex = getSourceBufferIndex(this)
					setter(this, [sbIndex, 'timestampOffset'], value)
				}
				get updating() {
					const sbIndex = getSourceBufferIndex(this)
					return getter(this, [sbIndex, 'updating'])
				}
			}),
			(_a = SourceBufferTasksKey),
			_b)
		)
		const WorkerTimeRanges = defineCstr(
			win,
			'TimeRanges',
			class extends WorkerBase {
				start(...args) {
					return callMethod(this, ['start'], args)
				}
				end(...args) {
					return callMethod(this, ['end'], args)
				}
				get length() {
					return getter(this, ['length'])
				}
			}
		)
		const getSourceBufferIndex = (sourceBuffer) => {
			if (sourceBuffer) {
				const mediaSource = sourceBuffer[MediaSourceKey]
				const sourceBufferList = mediaSource[SourceBuffersKey]
				return sourceBufferList.indexOf(sourceBuffer)
			}
			return -1
		}
		const drainSourceBufferQueue = (sourceBuffer) => {
			if (sourceBuffer[SourceBufferTasksKey].length) {
				if (!sourceBuffer.updating) {
					const task = sourceBuffer[SourceBufferTasksKey].shift()
					if (task) {
						const sbIndex = getSourceBufferIndex(sourceBuffer)
						callMethod(sourceBuffer, [sbIndex, task[0]], task[1], 3, void 0, task[2])
					}
				}
				setTimeout(() => drainSourceBufferQueue(sourceBuffer), 50)
			}
		}
		const HTMLMediaDescriptorMap = {
			buffered: {
				get() {
					if (!this[TimeRangesKey]) {
						this[TimeRangesKey] = new WorkerTimeRanges(this[WinIdKey], this[InstanceIdKey], [
							'buffered'
						])
						setTimeout(() => {
							this[TimeRangesKey] = void 0
						}, 5e3)
					}
					return this[TimeRangesKey]
				}
			},
			readyState: {
				get() {
					if (4 === this[ReadyStateKey]) {
						return 4
					}
					if ('number' != typeof this[ReadyStateKey]) {
						this[ReadyStateKey] = getter(this, ['readyState'])
						setTimeout(() => {
							this[ReadyStateKey] = void 0
						}, 1e3)
					}
					return this[ReadyStateKey]
				}
			}
		}
		defineCstr(
			win,
			'MediaSource',
			class extends WorkerEventTargetProxy {
				constructor() {
					super(env.$winId$)
					this[SourceBuffersKey] = new WorkerSourceBufferList(this)
					constructGlobal(this, 'MediaSource', EMPTY_ARRAY)
				}
				get activeSourceBuffers() {
					return []
				}
				addSourceBuffer(mimeType) {
					const sourceBuffer = new WorkerSourceBuffer(this)
					this[SourceBuffersKey].push(sourceBuffer)
					callMethod(this, ['addSourceBuffer'], [mimeType])
					return sourceBuffer
				}
				clearLiveSeekableRange() {
					callMethod(this, ['clearLiveSeekableRange'], EMPTY_ARRAY, 2)
				}
				get duration() {
					return getter(this, ['duration'])
				}
				set duration(value) {
					setter(this, ['duration'], value)
				}
				endOfStream(endOfStreamError) {
					callMethod(this, ['endOfStream'], [endOfStreamError], 3)
				}
				get readyState() {
					return getter(this, ['readyState'])
				}
				removeSourceBuffer(sourceBuffer) {
					const index = getSourceBufferIndex(sourceBuffer)
					if (index > -1) {
						this[SourceBuffersKey].splice(index, 1)
						callMethod(this, ['removeSourceBuffer'], [index], 1)
					}
				}
				setLiveSeekableRange(start, end) {
					callMethod(this, ['setLiveSeekableRange'], [start, end], 2)
				}
				get sourceBuffers() {
					return this[SourceBuffersKey]
				}
				static isTypeSupported(mimeType) {
					if (!isStaticTypeSupported.has(mimeType)) {
						const isSupported = callMethod(win, ['MediaSource', 'isTypeSupported'], [mimeType])
						isStaticTypeSupported.set(mimeType, isSupported)
					}
					return isStaticTypeSupported.get(mimeType)
				}
			}
		)
		const winURL = (win.URL = defineCstrName('URL', class extends URL {}))
		const hasAudioTracks = 'audioTracks' in win.HTMLMediaElement.prototype
		if (hasAudioTracks) {
			defineCstr(win, 'AudioTrackList', WorkerAudioTrackList)
			defineCstr(win, 'AudioTrack', WorkerAudioTrack)
			HTMLMediaDescriptorMap.audioTracks = {
				get() {
					return new WorkerAudioTrackList(this)
				}
			}
		}
		definePrototypePropertyDescriptor(win.HTMLMediaElement, HTMLMediaDescriptorMap)
		winURL.createObjectURL = (obj) => callMethod(win, ['URL', 'createObjectURL'], [obj])
		winURL.revokeObjectURL = (obj) => callMethod(win, ['URL', 'revokeObjectURL'], [obj])
	}
	const isStaticTypeSupported = new Map()
	self.$bridgeFromMedia$ = (
		WorkerBase,
		WorkerEventTargetProxy,
		env,
		win,
		windowMediaConstructors
	) => {
		windowMediaConstructors.map((mediaCstrName) => {
			delete win[mediaCstrName]
		})
		initCanvas(WorkerBase, win)
		initMedia(WorkerBase, WorkerEventTargetProxy, env, win)
	}
})(self)

================
File: static/~partytown/debug/partytown-sandbox-sw.js
================
/* Partytown 0.10.2 - MIT builder.io */
;((window) => {
	const isPromise = (v) => 'object' == typeof v && v && v.then
	const noop = () => {}
	const len = (obj) => obj.length
	const getConstructorName = (obj) => {
		var _a, _b, _c
		try {
			const constructorName =
				null === (_a = null == obj ? void 0 : obj.constructor) || void 0 === _a ? void 0 : _a.name
			if (constructorName) {
				return constructorName
			}
		} catch (e) {}
		try {
			const zoneJsConstructorName =
				null ===
					(_c =
						null === (_b = null == obj ? void 0 : obj.__zone_symbol__originalInstance) ||
						void 0 === _b
							? void 0
							: _b.constructor) || void 0 === _c
					? void 0
					: _c.name
			if (zoneJsConstructorName) {
				return zoneJsConstructorName
			}
		} catch (e) {}
		return ''
	}
	const startsWith = (str, val) => str.startsWith(val)
	const isValidMemberName = (memberName) =>
		!(
			startsWith(memberName, 'webkit') ||
			startsWith(memberName, 'toJSON') ||
			startsWith(memberName, 'constructor') ||
			startsWith(memberName, 'toString') ||
			startsWith(memberName, '_')
		)
	const getNodeName = (node) => (11 === node.nodeType && node.host ? '#s' : node.nodeName)
	const randomId = () => Math.round(Math.random() * Number.MAX_SAFE_INTEGER).toString(36)
	const defineConstructorName = (Cstr, value) =>
		((obj, memberName, descriptor) =>
			Object.defineProperty(obj, memberName, {
				...descriptor,
				configurable: true
			}))(Cstr, 'name', {
			value: value
		})
	const htmlConstructorTags = {
		Anchor: 'a',
		DList: 'dl',
		Image: 'img',
		OList: 'ol',
		Paragraph: 'p',
		Quote: 'q',
		TableCaption: 'caption',
		TableCell: 'td',
		TableCol: 'colgroup',
		TableRow: 'tr',
		TableSection: 'tbody',
		UList: 'ul'
	}
	const svgConstructorTags = {
		Graphics: 'g',
		SVG: 'svg'
	}
	const defaultPartytownForwardPropertySettings = {
		preserveBehavior: false
	}
	const arrayMethods = Object.freeze(
		((obj) => {
			const properties = new Set()
			let currentObj = obj
			do {
				Object.getOwnPropertyNames(currentObj).forEach((item) => {
					'function' == typeof currentObj[item] && properties.add(item)
				})
			} while ((currentObj = Object.getPrototypeOf(currentObj)) !== Object.prototype)
			return Array.from(properties)
		})([])
	)
	const InstanceIdKey = Symbol()
	const CreatedKey = Symbol()
	const instances = new Map()
	const mainRefs = new Map()
	const winCtxs = {}
	const windowIds = new WeakMap()
	const getAndSetInstanceId = (instance, instanceId) => {
		if (instance) {
			if ((instanceId = windowIds.get(instance))) {
				return instanceId
			}
			;(instanceId = instance[InstanceIdKey]) || setInstanceId(instance, (instanceId = randomId()))
			return instanceId
		}
	}
	const getInstance = (winId, instanceId, win, doc, docId) => {
		if ((win = winCtxs[winId]) && win.$window$) {
			if (winId === instanceId) {
				return win.$window$
			}
			doc = win.$window$.document
			docId = instanceId.split('.').pop()
			if ('d' === docId) {
				return doc
			}
			if ('e' === docId) {
				return doc.documentElement
			}
			if ('h' === docId) {
				return doc.head
			}
			if ('b' === docId) {
				return doc.body
			}
		}
		return instances.get(instanceId)
	}
	const setInstanceId = (instance, instanceId, now) => {
		if (instance) {
			instances.set(instanceId, instance)
			instance[InstanceIdKey] = instanceId
			instance[CreatedKey] = now = Date.now()
			if (now > lastCleanup + 5e3) {
				instances.forEach((storedInstance, instanceId) => {
					storedInstance[CreatedKey] < lastCleanup &&
						storedInstance.nodeType &&
						!storedInstance.isConnected &&
						instances.delete(instanceId)
				})
				lastCleanup = now
			}
		}
	}
	let lastCleanup = 0
	const mainWindow = window.parent
	const docImpl = document.implementation.createHTMLDocument()
	const config = mainWindow.partytown || {}
	const libPath = (config.lib || '/~partytown/') + 'debug/'
	const logMain = (msg) => {
		console.debug.apply(console, [
			'%cMain 🌎',
			'background: #717171; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;',
			msg
		])
	}
	const winIds = []
	const normalizedWinId = (winId) => {
		winIds.includes(winId) || winIds.push(winId)
		return winIds.indexOf(winId) + 1
	}
	const defineCustomElement = (winId, worker, ceData) => {
		const Cstr = defineConstructorName(
			class extends winCtxs[winId].$window$.HTMLElement {},
			ceData[0]
		)
		const ceCallbackMethods =
			'connectedCallback,disconnectedCallback,attributeChangedCallback,adoptedCallback'.split(',')
		ceCallbackMethods.map(
			(callbackMethodName) =>
				(Cstr.prototype[callbackMethodName] = function (...args) {
					worker.postMessage([15, winId, getAndSetInstanceId(this), callbackMethodName, args])
				})
		)
		Cstr.observedAttributes = ceData[1]
		return Cstr
	}
	const serializeForWorker = ($winId$, value, added, type, cstrName, prevInstanceId) =>
		void 0 !== value && (type = typeof value)
			? 'string' === type || 'number' === type || 'boolean' === type || null == value
				? [0, value]
				: 'function' === type
					? [6]
					: (added = added || new Set()) && Array.isArray(value)
						? added.has(value)
							? [1, []]
							: added.add(value) && [1, value.map((v) => serializeForWorker($winId$, v, added))]
						: 'object' === type
							? serializedValueIsError(value)
								? [
										14,
										{
											name: value.name,
											message: value.message,
											stack: value.stack
										}
									]
								: '' === (cstrName = getConstructorName(value))
									? [2, {}]
									: 'Window' === cstrName
										? [3, [$winId$, $winId$]]
										: 'HTMLCollection' === cstrName || 'NodeList' === cstrName
											? [7, Array.from(value).map((v) => serializeForWorker($winId$, v, added)[1])]
											: cstrName.endsWith('Event')
												? [5, serializeObjectForWorker($winId$, value, added)]
												: 'CSSRuleList' === cstrName
													? [12, Array.from(value).map(serializeCssRuleForWorker)]
													: startsWith(cstrName, 'CSS') && cstrName.endsWith('Rule')
														? [11, serializeCssRuleForWorker(value)]
														: 'CSSStyleDeclaration' === cstrName
															? [13, serializeObjectForWorker($winId$, value, added)]
															: 'Attr' === cstrName
																? [10, [value.name, value.value]]
																: value.nodeType
																	? [
																			3,
																			[
																				$winId$,
																				getAndSetInstanceId(value),
																				getNodeName(value),
																				prevInstanceId
																			]
																		]
																	: [2, serializeObjectForWorker($winId$, value, added, true, true)]
							: void 0
			: value
	const serializeObjectForWorker = (
		winId,
		obj,
		added,
		includeFunctions,
		includeEmptyStrings,
		serializedObj,
		propName,
		propValue
	) => {
		serializedObj = {}
		if (!added.has(obj)) {
			added.add(obj)
			for (propName in obj) {
				if (isValidMemberName(propName)) {
					propValue =
						'path' === propName && getConstructorName(obj).endsWith('Event')
							? obj.composedPath()
							: obj[propName]
					;(includeFunctions || 'function' != typeof propValue) &&
						(includeEmptyStrings || '' !== propValue) &&
						(serializedObj[propName] = serializeForWorker(winId, propValue, added))
				}
			}
		}
		return serializedObj
	}
	const serializeCssRuleForWorker = (cssRule) => {
		let obj = {}
		let key
		for (key in cssRule) {
			validCssRuleProps.includes(key) && (obj[key] = String(cssRule[key]))
		}
		return obj
	}
	let ErrorObject = null
	const serializedValueIsError = (value) => {
		var _a
		ErrorObject = (null === (_a = window.top) || void 0 === _a ? void 0 : _a.Error) || ErrorObject
		return value instanceof ErrorObject
	}
	const deserializeFromWorker = (worker, serializedTransfer, serializedType, serializedValue) => {
		if (serializedTransfer) {
			serializedType = serializedTransfer[0]
			serializedValue = serializedTransfer[1]
			return 0 === serializedType
				? serializedValue
				: 4 === serializedType
					? deserializeRefFromWorker(worker, serializedValue)
					: 1 === serializedType
						? serializedValue.map((v) => deserializeFromWorker(worker, v))
						: 3 === serializedType
							? getInstance(serializedValue[0], serializedValue[1])
							: 5 === serializedType
								? constructEvent(deserializeObjectFromWorker(worker, serializedValue))
								: 2 === serializedType
									? deserializeObjectFromWorker(worker, serializedValue)
									: 8 === serializedType
										? serializedValue
										: 9 === serializedType
											? new window[serializedTransfer[2]](serializedValue)
											: void 0
		}
	}
	const deserializeRefFromWorker = (
		worker,
		{ $winId$: $winId$, $instanceId$: $instanceId$, $refId$: $refId$ },
		ref
	) => {
		ref = mainRefs.get($refId$)
		if (!ref) {
			ref = function (...args) {
				worker.postMessage([
					9,
					{
						$winId$: $winId$,
						$instanceId$: $instanceId$,
						$refId$: $refId$,
						$thisArg$: serializeForWorker($winId$, this),
						$args$: serializeForWorker($winId$, args)
					}
				])
			}
			mainRefs.set($refId$, ref)
		}
		return ref
	}
	const constructEvent = (eventProps) =>
		new ('detail' in eventProps ? CustomEvent : Event)(eventProps.type, eventProps)
	const deserializeObjectFromWorker = (worker, serializedValue, obj, key) => {
		obj = {}
		for (key in serializedValue) {
			obj[key] = deserializeFromWorker(worker, serializedValue[key])
		}
		return obj
	}
	const validCssRuleProps =
		'cssText,selectorText,href,media,namespaceURI,prefix,name,conditionText'.split(',')
	const mainAccessHandler = async (worker, accessReq) => {
		let accessRsp = {
			$msgId$: accessReq.$msgId$
		}
		let totalTasks = len(accessReq.$tasks$)
		let i = 0
		let task
		let winId
		let applyPath
		let instance
		let rtnValue
		let isLast
		for (; i < totalTasks; i++) {
			try {
				isLast = i === totalTasks - 1
				task = accessReq.$tasks$[i]
				winId = task.$winId$
				applyPath = task.$applyPath$
				!winCtxs[winId] &&
					winId.startsWith('f_') &&
					(await new Promise((resolve) => {
						let check = 0
						let callback = () => {
							winCtxs[winId] || check++ > 1e3 ? resolve() : requestAnimationFrame(callback)
						}
						callback()
					}))
				if (1 === applyPath[0] && applyPath[1] in winCtxs[winId].$window$) {
					setInstanceId(
						new winCtxs[winId].$window$[applyPath[1]](
							...deserializeFromWorker(worker, applyPath[2])
						),
						task.$instanceId$
					)
				} else {
					instance = getInstance(winId, task.$instanceId$)
					if (instance) {
						rtnValue = applyToInstance(
							worker,
							winId,
							instance,
							applyPath,
							isLast,
							task.$groupedGetters$
						)
						task.$assignInstanceId$ &&
							('string' == typeof task.$assignInstanceId$
								? setInstanceId(rtnValue, task.$assignInstanceId$)
								: (winCtxs[task.$assignInstanceId$.$winId$] = {
										$winId$: task.$assignInstanceId$.$winId$,
										$window$: {
											document: rtnValue
										}
									}))
						if (isPromise(rtnValue)) {
							rtnValue = await rtnValue
							isLast && (accessRsp.$isPromise$ = true)
						}
						isLast &&
							(accessRsp.$rtnValue$ = serializeForWorker(
								winId,
								rtnValue,
								void 0,
								void 0,
								void 0,
								task.$instanceId$
							))
					} else {
						accessRsp.$error$ = `Error finding instance "${task.$instanceId$}" on window ${normalizedWinId(winId)}`
						console.error(accessRsp.$error$, task)
					}
				}
			} catch (e) {
				isLast ? (accessRsp.$error$ = String(e.stack || e)) : console.error(e)
			}
		}
		return accessRsp
	}
	const applyToInstance = (worker, winId, instance, applyPath, isLast, groupedGetters) => {
		let i = 0
		let l = len(applyPath)
		let next
		let current
		let previous
		let args
		let groupedRtnValues
		for (; i < l; i++) {
			current = applyPath[i]
			next = applyPath[i + 1]
			previous = applyPath[i - 1]
			try {
				if (!Array.isArray(next)) {
					if ('string' == typeof current || 'number' == typeof current) {
						if (i + 1 === l && groupedGetters) {
							groupedRtnValues = {}
							groupedGetters.map((propName) => (groupedRtnValues[propName] = instance[propName]))
							return groupedRtnValues
						}
						instance = instance[current]
					} else {
						if (0 === next) {
							instance[previous] = deserializeFromWorker(worker, current)
							return
						}
						if ('function' == typeof instance[previous]) {
							args = deserializeFromWorker(worker, current)
							'define' === previous &&
								'CustomElementRegistry' === getConstructorName(instance) &&
								(args[1] = defineCustomElement(winId, worker, args[1]))
							'insertRule' === previous &&
								args[1] > len(instance.cssRules) &&
								(args[1] = len(instance.cssRules))
							instance = instance[previous].apply(instance, args)
							if ('play' === previous) {
								return Promise.resolve()
							}
						}
					}
				}
			} catch (err) {
				if (isLast) {
					throw err
				}
				console.debug('Non-blocking setter error:', err)
			}
		}
		return instance
	}
	const mainForwardTrigger = (worker, $winId$, win) => {
		let queuedForwardCalls = win._ptf
		let forwards = (win.partytown || {}).forward || []
		let i
		let mainForwardFn
		let forwardCall = ($forward$, args) =>
			worker.postMessage([
				10,
				{
					$winId$: $winId$,
					$forward$: $forward$,
					$args$: serializeForWorker($winId$, Array.from(args))
				}
			])
		win._ptf = void 0
		forwards.map((forwardProps) => {
			const [property, { preserveBehavior: preserveBehavior }] = ((
				propertyOrPropertyWithSettings
			) => {
				if ('string' == typeof propertyOrPropertyWithSettings) {
					return [propertyOrPropertyWithSettings, defaultPartytownForwardPropertySettings]
				}
				const [property, settings = defaultPartytownForwardPropertySettings] =
					propertyOrPropertyWithSettings
				return [
					property,
					{
						...defaultPartytownForwardPropertySettings,
						...settings
					}
				]
			})(forwardProps)
			mainForwardFn = win
			property.split('.').map((_, i, arr) => {
				mainForwardFn = mainForwardFn[arr[i]] =
					i + 1 < len(arr)
						? mainForwardFn[arr[i]] ||
							((propertyName) => (arrayMethods.includes(propertyName) ? [] : {}))(arr[i + 1])
						: (() => {
								let originalFunction = null
								if (preserveBehavior) {
									const { methodOrProperty: methodOrProperty, thisObject: thisObject } = ((
										window,
										properties
									) => {
										let thisObject = window
										for (let i = 0; i < properties.length - 1; i += 1) {
											thisObject = thisObject[properties[i]]
										}
										return {
											thisObject: thisObject,
											methodOrProperty:
												properties.length > 0
													? thisObject[properties[properties.length - 1]]
													: void 0
										}
									})(win, arr)
									'function' == typeof methodOrProperty &&
										(originalFunction = (...args) => methodOrProperty.apply(thisObject, ...args))
								}
								return (...args) => {
									let returnValue
									originalFunction && (returnValue = originalFunction(args))
									forwardCall(arr, args)
									return returnValue
								}
							})()
			})
		})
		if (queuedForwardCalls) {
			for (i = 0; i < len(queuedForwardCalls); i += 2) {
				forwardCall(queuedForwardCalls[i], queuedForwardCalls[i + 1])
			}
		}
	}
	const readNextScript = (worker, winCtx) => {
		let $winId$ = winCtx.$winId$
		let win = winCtx.$window$
		let doc = win.document
		let scriptSelector = 'script[type="text/partytown"]:not([data-ptid]):not([data-pterror])'
		let blockingScriptSelector = scriptSelector + ':not([async]):not([defer])'
		let scriptElm
		let $instanceId$
		let scriptData
		if (doc && doc.body) {
			scriptElm = doc.querySelector(blockingScriptSelector)
			scriptElm || (scriptElm = doc.querySelector(scriptSelector))
			if (scriptElm) {
				scriptElm.dataset.ptid = $instanceId$ = getAndSetInstanceId(scriptElm, $winId$)
				scriptData = {
					$winId$: $winId$,
					$instanceId$: $instanceId$
				}
				if (scriptElm.src) {
					scriptData.$url$ = scriptElm.src
					scriptData.$orgUrl$ = scriptElm.dataset.ptsrc || scriptElm.src
				} else {
					scriptData.$content$ = scriptElm.innerHTML
				}
				worker.postMessage([7, scriptData])
			} else {
				if (!winCtx.$isInitialized$) {
					winCtx.$isInitialized$ = 1
					mainForwardTrigger(worker, $winId$, win)
					doc.dispatchEvent(new CustomEvent('pt0'))
					{
						const winType = win === win.top ? 'top' : 'iframe'
						logMain(
							`Executed ${winType} window ${normalizedWinId($winId$)} environment scripts in ${(performance.now() - winCtx.$startTime$).toFixed(1)}ms`
						)
					}
				}
				worker.postMessage([8, $winId$])
			}
		} else {
			requestAnimationFrame(() => readNextScript(worker, winCtx))
		}
	}
	const registerWindow = (worker, $winId$, $window$) => {
		if (!windowIds.has($window$)) {
			windowIds.set($window$, $winId$)
			const doc = $window$.document
			const history = $window$.history
			const $parentWinId$ = windowIds.get($window$.parent)
			let initialised = false
			const onInitialisedQueue = []
			const onInitialised = (callback) => {
				initialised ? callback() : onInitialisedQueue.push(callback)
			}
			const sendInitEnvData = () => {
				worker.postMessage([
					5,
					{
						$winId$: $winId$,
						$parentWinId$: $parentWinId$,
						$url$: doc.baseURI,
						$visibilityState$: doc.visibilityState
					}
				])
				setTimeout(() => {
					initialised = true
					onInitialisedQueue.forEach((callback) => {
						callback()
					})
				})
			}
			const pushState = history.pushState.bind(history)
			const replaceState = history.replaceState.bind(history)
			const onLocationChange = (type, state, newUrl, oldUrl) => () => {
				worker.postMessage([
					13,
					{
						$winId$: $winId$,
						type: type,
						state: state,
						url: doc.baseURI,
						newUrl: newUrl,
						oldUrl: oldUrl
					}
				])
			}
			history.pushState = (state, _, newUrl) => {
				pushState(state, _, newUrl)
				onInitialised(onLocationChange(0, state, null == newUrl ? void 0 : newUrl.toString()))
			}
			history.replaceState = (state, _, newUrl) => {
				replaceState(state, _, newUrl)
				onInitialised(onLocationChange(1, state, null == newUrl ? void 0 : newUrl.toString()))
			}
			$window$.addEventListener('popstate', (event) => {
				onInitialised(onLocationChange(2, event.state))
			})
			$window$.addEventListener('hashchange', (event) => {
				onInitialised(onLocationChange(3, {}, event.newURL, event.oldURL))
			})
			$window$.addEventListener('ptupdate', () => {
				readNextScript(worker, winCtxs[$winId$])
			})
			doc.addEventListener('visibilitychange', () =>
				worker.postMessage([14, $winId$, doc.visibilityState])
			)
			winCtxs[$winId$] = {
				$winId$: $winId$,
				$window$: $window$
			}
			winCtxs[$winId$].$startTime$ = performance.now()
			{
				const winType = $winId$ === $parentWinId$ ? 'top' : 'iframe'
				logMain(`Registered ${winType} window ${normalizedWinId($winId$)}`)
			}
			'complete' === doc.readyState
				? sendInitEnvData()
				: $window$.addEventListener('load', sendInitEnvData)
		}
	}
	const onMessageFromWebWorker = (worker, msg, winCtx) => {
		if (4 === msg[0]) {
			registerWindow(worker, randomId(), mainWindow)
		} else {
			winCtx = winCtxs[msg[1]]
			winCtx &&
				(7 === msg[0]
					? requestAnimationFrame(() => readNextScript(worker, winCtx))
					: 6 === msg[0] &&
						((worker, winCtx, instanceId, errorMsg, scriptElm) => {
							scriptElm = winCtx.$window$.document.querySelector(`[data-ptid="${instanceId}"]`)
							if (scriptElm) {
								errorMsg ? (scriptElm.dataset.pterror = errorMsg) : (scriptElm.type += '-x')
								delete scriptElm.dataset.ptid
							}
							readNextScript(worker, winCtx)
						})(worker, winCtx, msg[2], msg[3]))
		}
	}
	const readMainPlatform = () => {
		const elm = docImpl.createElement('i')
		const textNode = docImpl.createTextNode('')
		const comment = docImpl.createComment('')
		const frag = docImpl.createDocumentFragment()
		const shadowRoot = docImpl.createElement('p').attachShadow({
			mode: 'open'
		})
		const intersectionObserver = getGlobalConstructor(mainWindow, 'IntersectionObserver')
		const mutationObserver = getGlobalConstructor(mainWindow, 'MutationObserver')
		const resizeObserver = getGlobalConstructor(mainWindow, 'ResizeObserver')
		const perf = mainWindow.performance
		const screen = mainWindow.screen
		const impls = [
			[mainWindow.history],
			[perf],
			[perf.navigation],
			[perf.timing],
			[screen],
			[screen.orientation],
			[mainWindow.visualViewport],
			[intersectionObserver, 12],
			[mutationObserver, 12],
			[resizeObserver, 12],
			[textNode],
			[comment],
			[frag],
			[shadowRoot],
			[elm],
			[elm.attributes],
			[elm.classList],
			[elm.dataset],
			[elm.style],
			[docImpl],
			[docImpl.doctype]
		]
		const initialInterfaces = [
			readImplementation('Window', mainWindow),
			readImplementation('Node', textNode)
		]
		const $config$ = (function (config) {
			return JSON.stringify(config, (key, value) => {
				if ('function' == typeof value) {
					value = String(value)
					value.startsWith(key + '(') && (value = 'function ' + value)
				}
				'loadScriptsOnMainThread' === key &&
					(value = value.map((scriptUrl) =>
						Array.isArray(scriptUrl)
							? scriptUrl
							: [
									'string' == typeof scriptUrl ? 'string' : 'regexp',
									'string' == typeof scriptUrl ? scriptUrl : scriptUrl.source
								]
					))
				return value
			})
		})(config)
		const initWebWorkerData = {
			$config$: $config$,
			$interfaces$: readImplementations(impls, initialInterfaces),
			$libPath$: new URL(libPath, mainWindow.location) + '',
			$origin$: origin,
			$tabId$: mainWindow._pttab
		}
		addGlobalConstructorUsingPrototype(
			initWebWorkerData.$interfaces$,
			mainWindow,
			'IntersectionObserverEntry'
		)
		return initWebWorkerData
	}
	const readMainInterfaces = () => {
		const elms = Object.getOwnPropertyNames(mainWindow)
			.map((interfaceName) =>
				((doc, interfaceName, r, tag) => {
					r = interfaceName.match(/^(HTML|SVG)(.+)Element$/)
					if (r) {
						tag = r[2]
						return 'S' == interfaceName[0]
							? doc.createElementNS(
									'http://www.w3.org/2000/svg',
									svgConstructorTags[tag] || tag.slice(0, 2).toLowerCase() + tag.slice(2)
								)
							: doc.createElement(htmlConstructorTags[tag] || tag)
					}
				})(docImpl, interfaceName)
			)
			.filter((elm) => elm)
			.map((elm) => [elm])
		return readImplementations(elms, [])
	}
	const readImplementations = (impls, interfaces) => {
		const cstrs = new Set(['Object'])
		const cstrImpls = impls
			.filter((implData) => implData[0])
			.map((implData) => {
				const impl = implData[0]
				const interfaceType = implData[1]
				const cstrName = getConstructorName(impl)
				const CstrPrototype = mainWindow[cstrName].prototype
				return [cstrName, CstrPrototype, impl, interfaceType]
			})
		cstrImpls.map(([cstrName, CstrPrototype, impl, intefaceType]) =>
			readOwnImplementation(cstrs, interfaces, cstrName, CstrPrototype, impl, intefaceType)
		)
		return interfaces
	}
	const readImplementation = (cstrName, impl, memberName) => {
		let interfaceMembers = []
		let interfaceInfo = [cstrName, 'Object', interfaceMembers]
		for (memberName in impl) {
			readImplementationMember(interfaceMembers, impl, memberName)
		}
		return interfaceInfo
	}
	const readOwnImplementation = (
		cstrs,
		interfaces,
		cstrName,
		CstrPrototype,
		impl,
		interfaceType
	) => {
		if (!cstrs.has(cstrName)) {
			cstrs.add(cstrName)
			const SuperCstr = Object.getPrototypeOf(CstrPrototype)
			const superCstrName = getConstructorName(SuperCstr)
			const interfaceMembers = []
			const propDescriptors = Object.getOwnPropertyDescriptors(CstrPrototype)
			readOwnImplementation(cstrs, interfaces, superCstrName, SuperCstr, impl, interfaceType)
			for (const memberName in propDescriptors) {
				readImplementationMember(interfaceMembers, impl, memberName)
			}
			interfaces.push([cstrName, superCstrName, interfaceMembers, interfaceType, getNodeName(impl)])
		}
	}
	const readImplementationMember = (
		interfaceMembers,
		implementation,
		memberName,
		value,
		memberType,
		cstrName
	) => {
		try {
			if (isValidMemberName(memberName) && isNaN(memberName[0]) && 'all' !== memberName) {
				value = implementation[memberName]
				memberType = typeof value
				if ('function' === memberType) {
					;(String(value).includes('[native') ||
						Object.getPrototypeOf(implementation)[memberName]) &&
						interfaceMembers.push([memberName, 5])
				} else if ('object' === memberType && null != value) {
					cstrName = getConstructorName(value)
					'Object' !== cstrName &&
						'Function' !== cstrName &&
						self[cstrName] &&
						interfaceMembers.push([memberName, value.nodeType || cstrName])
				} else {
					'symbol' !== memberType &&
						(memberName.toUpperCase() === memberName
							? interfaceMembers.push([memberName, 6, value])
							: interfaceMembers.push([memberName, 6]))
				}
			}
		} catch (e) {
			console.warn(e)
		}
	}
	const getGlobalConstructor = (mainWindow, cstrName) =>
		void 0 !== mainWindow[cstrName] ? new mainWindow[cstrName](noop) : 0
	const addGlobalConstructorUsingPrototype = ($interfaces$, mainWindow, cstrName) => {
		void 0 !== mainWindow[cstrName] &&
			$interfaces$.push([
				cstrName,
				'Object',
				Object.keys(mainWindow[cstrName].prototype).map((propName) => [propName, 6]),
				12
			])
	}
	let worker
	;((receiveMessage) => {
		const swContainer = window.navigator.serviceWorker
		return swContainer.getRegistration().then((swRegistration) => {
			swContainer.addEventListener('message', (ev) =>
				receiveMessage(
					ev.data,
					(accessRsp) => swRegistration.active && swRegistration.active.postMessage(accessRsp)
				)
			)
			return (worker, msg) => {
				0 === msg[0]
					? worker.postMessage([1, readMainPlatform()])
					: 2 === msg[0]
						? worker.postMessage([3, readMainInterfaces()])
						: onMessageFromWebWorker(worker, msg)
			}
		})
	})((accessReq, responseCallback) =>
		mainAccessHandler(worker, accessReq).then(responseCallback)
	).then((onMessageHandler) => {
		if (onMessageHandler) {
			worker = new Worker(libPath + 'partytown-ww-sw.js?v=0.10.2', {
				name: 'Partytown 🎉'
			})
			worker.onmessage = (ev) => {
				const msg = ev.data
				12 === msg[0] ? mainAccessHandler(worker, msg[1]) : onMessageHandler(worker, msg)
			}
			logMain('Created Partytown web worker (0.10.2)')
			worker.onerror = (ev) => console.error('Web Worker Error', ev)
			mainWindow.addEventListener('pt1', (ev) =>
				registerWindow(worker, getAndSetInstanceId(ev.detail.frameElement), ev.detail)
			)
		}
	})
})(window)

================
File: static/~partytown/debug/partytown-sw.js
================
/* Partytown 0.10.2 - MIT builder.io */
Object.freeze(
	((obj) => {
		const properties = new Set()
		let currentObj = obj
		do {
			Object.getOwnPropertyNames(currentObj).forEach((item) => {
				'function' == typeof currentObj[item] && properties.add(item)
			})
		} while ((currentObj = Object.getPrototypeOf(currentObj)) !== Object.prototype)
		return Array.from(properties)
	})([])
)

const resolves = new Map()

const swMessageError = (accessReq, $error$) => ({
	$msgId$: accessReq.$msgId$,
	$error$: $error$
})

const httpRequestFromWebWorker = (req) =>
	new Promise(async (resolve) => {
		const accessReq = await req.clone().json()
		const responseData = await ((accessReq) =>
			new Promise(async (resolve) => {
				const clients = await self.clients.matchAll()
				const client = ((clients, msgId) => {
					const tabId = msgId.split('.').pop()
					let client = clients.find((a) => a.url.endsWith(`?${tabId}`))
					client ||
						(client = [...clients].sort((a, b) => (a.url > b.url ? -1 : a.url < b.url ? 1 : 0))[0])
					return client
				})([...clients], accessReq.$msgId$)
				if (client) {
					const timeout = 12e4
					const msgResolve = [
						resolve,
						setTimeout(() => {
							resolves.delete(accessReq.$msgId$)
							resolve(swMessageError(accessReq, 'Timeout'))
						}, timeout)
					]
					resolves.set(accessReq.$msgId$, msgResolve)
					client.postMessage(accessReq)
				} else {
					resolve(swMessageError(accessReq, 'NoParty'))
				}
			}))(accessReq)
		resolve(response(JSON.stringify(responseData), 'application/json'))
	})

const response = (body, contentType) =>
	new Response(body, {
		headers: {
			'content-type': contentType || 'text/html',
			'Cache-Control': 'no-store'
		}
	})

self.oninstall = () => self.skipWaiting()

self.onactivate = () => self.clients.claim()

self.onmessage = (ev) => {
	const accessRsp = ev.data
	const r = resolves.get(accessRsp.$msgId$)
	if (r) {
		resolves.delete(accessRsp.$msgId$)
		clearTimeout(r[1])
		r[0](accessRsp)
	}
}

self.onfetch = (ev) => {
	const req = ev.request
	const url = new URL(req.url)
	const pathname = url.pathname
	if (pathname.endsWith('sw.html')) {
		ev.respondWith(
			response(
				'<!DOCTYPE html><html><head><meta charset="utf-8"><script src="./partytown-sandbox-sw.js?v=0.10.2"></script></head></html>'
			)
		)
	} else {
		pathname.endsWith('proxytown') && ev.respondWith(httpRequestFromWebWorker(req))
	}
}

================
File: static/~partytown/debug/partytown-ww-atomics.js
================
/* Partytown 0.10.2 - MIT builder.io */
;((self) => {
	const WinIdKey = Symbol()
	const InstanceIdKey = Symbol()
	const InstanceDataKey = Symbol()
	const NamespaceKey = Symbol()
	const ApplyPathKey = Symbol()
	const InstanceStateKey = Symbol()
	const HookContinue = Symbol()
	const HookPrevent = Symbol()
	const webWorkerInstances = new Map()
	const webWorkerRefsByRefId = {}
	const webWorkerRefIdsByRef = new WeakMap()
	const postMessages = []
	const webWorkerCtx = {}
	const environments = {}
	const cachedDimensions = new Map()
	const cachedStructure = new Map()
	const commaSplit = (str) => str.split(',')
	const partytownLibUrl = (url) => {
		url = webWorkerCtx.$libPath$ + url
		if (new URL(url).origin != location.origin) {
			throw 'Invalid ' + url
		}
		return url
	}
	const getterDimensionPropNames = commaSplit(
		'clientWidth,clientHeight,clientTop,clientLeft,innerWidth,innerHeight,offsetWidth,offsetHeight,offsetTop,offsetLeft,outerWidth,outerHeight,pageXOffset,pageYOffset,scrollWidth,scrollHeight,scrollTop,scrollLeft'
	)
	const elementStructurePropNames = commaSplit(
		'childElementCount,children,firstElementChild,lastElementChild,nextElementSibling,previousElementSibling'
	)
	const structureChangingMethodNames = commaSplit('insertBefore,remove,removeChild,replaceChild')
	const dimensionChangingSetterNames = commaSplit(
		'className,width,height,hidden,innerHTML,innerText,textContent,text'
	)
	const dimensionChangingMethodNames = commaSplit('setAttribute,setAttributeNS,setProperty')
	const eventTargetMethods = commaSplit('addEventListener,dispatchEvent,removeEventListener')
	const nonBlockingMethods = eventTargetMethods.concat(
		dimensionChangingMethodNames,
		commaSplit('add,observe,remove,unobserve')
	)
	const IS_TAG_REG = /^[A-Z_]([A-Z0-9-]*[A-Z0-9])?$/
	const noop = () => {}
	const len = (obj) => obj.length
	const getConstructorName = (obj) => {
		var _a, _b, _c
		try {
			const constructorName =
				null === (_a = null == obj ? void 0 : obj.constructor) || void 0 === _a ? void 0 : _a.name
			if (constructorName) {
				return constructorName
			}
		} catch (e) {}
		try {
			const zoneJsConstructorName =
				null ===
					(_c =
						null === (_b = null == obj ? void 0 : obj.__zone_symbol__originalInstance) ||
						void 0 === _b
							? void 0
							: _b.constructor) || void 0 === _c
					? void 0
					: _c.name
			if (zoneJsConstructorName) {
				return zoneJsConstructorName
			}
		} catch (e) {}
		return ''
	}
	const EMPTY_ARRAY = []
	const randomId = () => Math.round(Math.random() * Number.MAX_SAFE_INTEGER).toString(36)
	const SCRIPT_TYPE = 'text/partytown'
	const defineProperty = (obj, memberName, descriptor) =>
		Object.defineProperty(obj, memberName, {
			...descriptor,
			configurable: true
		})
	const defineConstructorName = (Cstr, value) =>
		defineProperty(Cstr, 'name', {
			value: value
		})
	const definePrototypeProperty = (Cstr, memberName, descriptor) =>
		defineProperty(Cstr.prototype, memberName, descriptor)
	const definePrototypePropertyDescriptor = (Cstr, propertyDescriptorMap) =>
		Object.defineProperties(Cstr.prototype, propertyDescriptorMap)
	const definePrototypeValue = (Cstr, memberName, value) =>
		definePrototypeProperty(Cstr, memberName, {
			value: value,
			writable: true
		})
	Object.freeze(
		((obj) => {
			const properties = new Set()
			let currentObj = obj
			do {
				Object.getOwnPropertyNames(currentObj).forEach((item) => {
					'function' == typeof currentObj[item] && properties.add(item)
				})
			} while ((currentObj = Object.getPrototypeOf(currentObj)) !== Object.prototype)
			return Array.from(properties)
		})([])
	)
	function testIfMustLoadScriptOnMainThread(config, value) {
		var _a, _b
		return (
			null !==
				(_b =
					null === (_a = config.loadScriptsOnMainThread) || void 0 === _a
						? void 0
						: _a
								.map(
									([type, value]) =>
										new RegExp(
											'string' === type
												? (function (input) {
														return input.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
													})(value)
												: value
										)
								)
								.some((regexp) => regexp.test(value))) &&
			void 0 !== _b &&
			_b
		)
	}
	const hasInstanceStateValue = (instance, stateKey) => stateKey in instance[InstanceStateKey]
	const getInstanceStateValue = (instance, stateKey) => instance[InstanceStateKey][stateKey]
	const setInstanceStateValue = (instance, stateKey, stateValue) =>
		(instance[InstanceStateKey][stateKey] = stateValue)
	const setWorkerRef = (ref, refId) => {
		if (!(refId = webWorkerRefIdsByRef.get(ref))) {
			webWorkerRefIdsByRef.set(ref, (refId = randomId()))
			webWorkerRefsByRefId[refId] = ref
		}
		return refId
	}
	const getOrCreateNodeInstance = (
		winId,
		instanceId,
		nodeName,
		namespace,
		instance,
		prevInstanceId
	) => {
		instance = webWorkerInstances.get(instanceId)
		if (!instance && nodeName && environments[winId]) {
			const prevInstance = webWorkerInstances.get(prevInstanceId || '')
			instance = environments[winId].$createNode$(nodeName, instanceId, namespace, prevInstance)
			webWorkerInstances.set(instanceId, instance)
		}
		return instance
	}
	const definePrototypeNodeType = (Cstr, nodeType) =>
		definePrototypeValue(Cstr, 'nodeType', nodeType)
	const cachedTreeProps = (Cstr, treeProps) =>
		treeProps.map((propName) =>
			definePrototypeProperty(Cstr, propName, {
				get() {
					let cacheKey = getInstanceCacheKey(this, propName)
					let result = cachedStructure.get(cacheKey)
					if (!result) {
						result = getter(this, [propName])
						cachedStructure.set(cacheKey, result)
					}
					return result
				}
			})
		)
	const getInstanceCacheKey = (instance, memberName, args) =>
		[
			instance[WinIdKey],
			instance[InstanceIdKey],
			memberName,
			...(args || EMPTY_ARRAY).map((arg) => String(arg && arg[WinIdKey] ? arg[InstanceIdKey] : arg))
		].join('.')
	const cachedProps = (Cstr, propNames) =>
		commaSplit(propNames).map((propName) =>
			definePrototypeProperty(Cstr, propName, {
				get() {
					hasInstanceStateValue(this, propName) ||
						setInstanceStateValue(this, propName, getter(this, [propName]))
					return getInstanceStateValue(this, propName)
				},
				set(val) {
					getInstanceStateValue(this, propName) !== val && setter(this, [propName], val)
					setInstanceStateValue(this, propName, val)
				}
			})
		)
	const cachedDimensionProps = (Cstr) =>
		getterDimensionPropNames.map((propName) =>
			definePrototypeProperty(Cstr, propName, {
				get() {
					const dimension = cachedDimensions.get(getInstanceCacheKey(this, propName))
					if ('number' == typeof dimension) {
						return dimension
					}
					const groupedDimensions = getter(this, [propName], getterDimensionPropNames)
					if (groupedDimensions && 'object' == typeof groupedDimensions) {
						Object.entries(groupedDimensions).map(([dimensionPropName, value]) =>
							cachedDimensions.set(getInstanceCacheKey(this, dimensionPropName), value)
						)
						return groupedDimensions[propName]
					}
					return groupedDimensions
				}
			})
		)
	const cachedDimensionMethods = (Cstr, dimensionMethodNames) =>
		dimensionMethodNames.map((methodName) => {
			Cstr.prototype[methodName] = function (...args) {
				let cacheKey = getInstanceCacheKey(this, methodName, args)
				let dimensions = cachedDimensions.get(cacheKey)
				if (!dimensions) {
					dimensions = callMethod(this, [methodName], args)
					cachedDimensions.set(cacheKey, dimensions)
				}
				return dimensions
			}
		})
	const serializeForMain = ($winId$, $instanceId$, value, added, type) =>
		void 0 !== value && (type = typeof value)
			? 'string' === type || 'boolean' === type || 'number' === type || null == value
				? [0, value]
				: 'function' === type
					? [
							4,
							{
								$winId$: $winId$,
								$instanceId$: $instanceId$,
								$refId$: setWorkerRef(value)
							}
						]
					: (added = added || new Set()) && Array.isArray(value)
						? added.has(value)
							? [1, []]
							: added.add(value) && [
									1,
									value.map((v) => serializeForMain($winId$, $instanceId$, v, added))
								]
						: 'object' === type
							? value[InstanceIdKey]
								? [3, [value[WinIdKey], value[InstanceIdKey]]]
								: value instanceof Event
									? [5, serializeObjectForMain($winId$, $instanceId$, value, false, added)]
									: supportsTrustedHTML && value instanceof TrustedHTML
										? [0, value.toString()]
										: value instanceof ArrayBuffer
											? [8, value]
											: ArrayBuffer.isView(value)
												? [9, value.buffer, getConstructorName(value)]
												: [2, serializeObjectForMain($winId$, $instanceId$, value, true, added)]
							: void 0
			: value
	const supportsTrustedHTML = 'undefined' != typeof TrustedHTML
	const serializeObjectForMain = (
		winId,
		instanceId,
		obj,
		includeFunctions,
		added,
		serializedObj,
		propName,
		propValue
	) => {
		serializedObj = {}
		if (!added.has(obj)) {
			added.add(obj)
			for (propName in obj) {
				propValue = obj[propName]
				;(includeFunctions || 'function' != typeof propValue) &&
					(serializedObj[propName] = serializeForMain(winId, instanceId, propValue, added))
			}
		}
		return serializedObj
	}
	const serializeInstanceForMain = (instance, value) =>
		instance ? serializeForMain(instance[WinIdKey], instance[InstanceIdKey], value) : [0, value]
	const deserializeFromMain = (
		winId,
		instanceId,
		applyPath,
		serializedValueTransfer,
		serializedType,
		serializedValue,
		obj,
		key
	) => {
		if (serializedValueTransfer) {
			serializedType = serializedValueTransfer[0]
			serializedValue = serializedValueTransfer[1]
			if (0 === serializedType || 11 === serializedType || 12 === serializedType) {
				return serializedValue
			}
			if (4 === serializedType) {
				return deserializeRefFromMain(applyPath, serializedValue)
			}
			if (6 === serializedType) {
				return winId && applyPath.length > 0
					? (...args) => callMethod(environments[winId].$window$, applyPath, args, 1)
					: noop
			}
			if (3 === serializedType) {
				return getOrCreateSerializedInstance(serializedValue)
			}
			if (7 === serializedType) {
				return new NodeList(serializedValue.map(getOrCreateSerializedInstance))
			}
			if (10 === serializedType) {
				return new Attr(serializedValue)
			}
			if (1 === serializedType) {
				return serializedValue.map((v) => deserializeFromMain(winId, instanceId, applyPath, v))
			}
			if (14 === serializedType) {
				return new CustomError(serializedValue)
			}
			obj = {}
			for (key in serializedValue) {
				obj[key] = deserializeFromMain(winId, instanceId, [...applyPath, key], serializedValue[key])
			}
			if (13 === serializedType) {
				return new environments[winId].$window$.CSSStyleDeclaration(
					winId,
					instanceId,
					applyPath,
					obj
				)
			}
			if (5 === serializedType) {
				if ('message' === obj.type && obj.origin) {
					let postMessageKey = JSON.stringify(obj.data)
					let postMessageData = postMessages.find((pm) => pm.$data$ === postMessageKey)
					let env
					if (postMessageData) {
						env = environments[postMessageData.$winId$]
						if (env) {
							obj.source = env.$window$
							obj.origin = env.$location$.origin
						}
					}
				}
				return new Proxy(new Event(obj.type, obj), {
					get: (target, propName) =>
						propName in obj
							? obj[propName]
							: 'function' == typeof target[String(propName)]
								? noop
								: target[String(propName)]
				})
			}
			if (2 === serializedType) {
				return obj
			}
		}
	}
	const getOrCreateSerializedInstance = ([winId, instanceId, nodeName, prevInstanceId]) =>
		instanceId === winId && environments[winId]
			? environments[winId].$window$
			: getOrCreateNodeInstance(winId, instanceId, nodeName, void 0, void 0, prevInstanceId)
	const deserializeRefFromMain = (
		applyPath,
		{ $winId$: $winId$, $instanceId$: $instanceId$, $nodeName$: $nodeName$, $refId$: $refId$ }
	) => {
		webWorkerRefsByRefId[$refId$] ||
			webWorkerRefIdsByRef.set(
				(webWorkerRefsByRefId[$refId$] = function (...args) {
					const instance = getOrCreateNodeInstance($winId$, $instanceId$, $nodeName$)
					return callMethod(instance, applyPath, args)
				}),
				$refId$
			)
		return webWorkerRefsByRefId[$refId$]
	}
	class CustomError extends Error {
		constructor(errorObject) {
			super(errorObject.message)
			this.name = errorObject.name
			this.message = errorObject.message
			this.stack = errorObject.stack
		}
	}
	class NodeList {
		constructor(nodes) {
			;(this._ = nodes).map((node, index) => (this[index] = node))
		}
		entries() {
			return this._.entries()
		}
		forEach(cb, thisArg) {
			this._.map(cb, thisArg)
		}
		item(index) {
			return this[index]
		}
		keys() {
			return this._.keys()
		}
		get length() {
			return len(this._)
		}
		values() {
			return this._.values()
		}
		[Symbol.iterator]() {
			return this._[Symbol.iterator]()
		}
	}
	const Attr = class {
		constructor(serializedAttr) {
			this.name = serializedAttr[0]
			this.value = serializedAttr[1]
		}
		get nodeName() {
			return this.name
		}
		get nodeType() {
			return 2
		}
	}
	const warnCrossOrigin = (apiType, apiName, env) =>
		console.warn(`Partytown unable to ${apiType} cross-origin ${apiName}: ` + env.$location$)
	const logWorker = (msg, winId) => {
		try {
			const config = webWorkerCtx.$config$
			if (config.logStackTraces) {
				const frames = new Error().stack.split('\n')
				const i = frames.findIndex((f) => f.includes('logWorker'))
				msg += '\n' + frames.slice(i + 1).join('\n')
			}
			let prefix
			let color
			if (winId) {
				prefix = `Worker (${normalizedWinId(winId)}) 🎉`
				color = winColor(winId)
			} else {
				prefix = self.name
				color = '#9844bf'
			}
			if (webWorkerCtx.lastLog !== msg) {
				webWorkerCtx.lastLog = msg
				console.debug.apply(console, [
					`%c${prefix}`,
					`background: ${color}; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;`,
					msg
				])
			}
		} catch (e) {}
	}
	const winIds = []
	const normalizedWinId = (winId) => {
		winIds.includes(winId) || winIds.push(winId)
		return winIds.indexOf(winId) + 1
	}
	const winColor = (winId) => {
		const colors = ['#00309e', '#ea3655', '#eea727']
		const index = normalizedWinId(winId) - 1
		return colors[index] || colors[colors.length - 1]
	}
	const getTargetProp = (target, applyPath) => {
		let n = ''
		if (target) {
			const cstrName = getConstructorName(target)
			if ('Window' === cstrName) {
				n = ''
			} else if ('string' == typeof target[InstanceDataKey]) {
				let nodeName = target[InstanceDataKey]
				n =
					'#text' === nodeName
						? 'textNode.'
						: '#comment' === nodeName
							? 'commentNode.'
							: '#document' === nodeName
								? 'document.'
								: 'html' === nodeName
									? 'doctype.'
									: nodeName.toLowerCase() + '.'
			} else {
				n =
					'nodeType' in target && 2 === target.nodeType
						? 'attributes.'
						: 'CanvasRenderingContext2D' === cstrName
							? 'context2D.'
							: 'CanvasRenderingContextWebGL' === cstrName
								? 'contextWebGL.'
								: 'CSSStyleDeclaration' === cstrName
									? 'style.'
									: 'MutationObserver' === cstrName
										? 'mutationObserver.'
										: 'NamedNodeMap' === cstrName
											? 'namedNodeMap.'
											: 'ResizeObserver' === cstrName
												? 'resizeObserver.'
												: cstrName.substring(0, 1).toLowerCase() + cstrName.substring(1) + '.'
			}
			target[ApplyPathKey] &&
				target[ApplyPathKey].length &&
				(n += [...target[ApplyPathKey]].join('.') + '.')
		}
		if (applyPath.length > 1) {
			const first = applyPath.slice(0, applyPath.length - 1)
			const last = applyPath[applyPath.length - 1]
			if (!isNaN(last)) {
				return n + `${first.join('.')}[${last}]`
			}
		}
		return n + applyPath.join('.')
	}
	const getLogValue = (applyPath, v) => {
		const type = typeof v
		if (void 0 === v) {
			return 'undefined'
		}
		if ('boolean' === type || 'number' === type || null == v) {
			return JSON.stringify(v)
		}
		if ('string' === type) {
			return applyPath.includes('cookie')
				? JSON.stringify(v.slice(0, 10) + '...')
				: JSON.stringify(v.length > 50 ? v.slice(0, 40) + '...' : v)
		}
		if (Array.isArray(v)) {
			return `[${v.map(getLogValue).join(', ')}]`
		}
		if ('object' === type) {
			const instanceId = v[InstanceIdKey]
			const cstrName = getConstructorName(v)
			if ('string' == typeof instanceId) {
				if ('Window' === cstrName) {
					return 'window'
				}
				if ('string' == typeof v[InstanceDataKey]) {
					if (1 === v.nodeType) {
						return `<${v[InstanceDataKey].toLowerCase()}>`
					}
					if (10 === v.nodeType) {
						return `<!DOCTYPE ${v[InstanceDataKey]}>`
					}
					if (v.nodeType <= 11) {
						return v[InstanceDataKey]
					}
				}
				return '¯\\_(ツ)_/¯ instance obj'
			}
			return v[Symbol.iterator]
				? `[${Array.from(v)
						.map((i) => getLogValue(applyPath, i))
						.join(', ')}]`
				: 'value' in v
					? 'string' == typeof v.value
						? `"${v.value}"`
						: objToString(v.value)
					: objToString(v)
		}
		return ((v) => 'object' == typeof v && v && v.then)(v)
			? 'Promise'
			: 'function' === type
				? `ƒ() ${v.name || ''}`.trim()
				: `¯\\_(ツ)_/¯ ${String(v)}`.trim()
	}
	const objToString = (obj) => {
		const s = []
		for (let key in obj) {
			const value = obj[key]
			const type = typeof value
			'string' === type
				? s.push(`${key}: "${value}"`)
				: 'function' === type
					? s.push(`${key}: ƒ`)
					: Array.isArray(type)
						? s.push(`${key}: [..]`)
						: 'object' === type && value
							? s.push(`${key}: {..}`)
							: s.push(`${key}: ${String(value)}`)
		}
		let str = s.join(', ')
		str.length > 200 && (str = str.substring(0, 200) + '..')
		return `{ ${str} }`
	}
	const logDimensionCacheClearStyle = (target, propName) => {
		;(webWorkerCtx.$config$.logGetters || webWorkerCtx.$config$.logSetters) &&
			logWorker(`Dimension cache cleared from style.${propName} setter`, target[WinIdKey])
	}
	const logDimensionCacheClearMethod = (target, methodName) => {
		;(webWorkerCtx.$config$.logGetters || webWorkerCtx.$config$.logCalls) &&
			logWorker(`Dimension cache cleared from method call ${methodName}()`, target[WinIdKey])
	}
	const taskQueue = []
	const queue = (instance, $applyPath$, callType, $assignInstanceId$, $groupedGetters$, buffer) => {
		if (instance[ApplyPathKey]) {
			taskQueue.push({
				$winId$: instance[WinIdKey],
				$instanceId$: instance[InstanceIdKey],
				$applyPath$: [...instance[ApplyPathKey], ...$applyPath$],
				$assignInstanceId$: $assignInstanceId$,
				$groupedGetters$: $groupedGetters$
			})
			taskQueue[len(taskQueue) - 1].$debug$ = ((target, applyPath, callType) => {
				let m = getTargetProp(target, applyPath)
				1 === callType
					? (m += ' (blocking)')
					: 2 === callType
						? (m += ' (non-blocking)')
						: 3 === callType && (m += ' (non-blocking, no-side-effect)')
				return m.trim()
			})(instance, $applyPath$, callType)
			buffer && 3 !== callType && console.error('buffer must be sent NonBlockingNoSideEffect')
			if (3 === callType) {
				webWorkerCtx.$postMessage$(
					[
						12,
						{
							$msgId$: randomId(),
							$tasks$: [...taskQueue]
						}
					],
					buffer ? [buffer instanceof ArrayBuffer ? buffer : buffer.buffer] : void 0
				)
				taskQueue.length = 0
			} else if (1 === callType) {
				return sendToMain(true)
			}
			webWorkerCtx.$asyncMsgTimer$ = setTimeout(sendToMain, 20)
		}
	}
	const sendToMain = (isBlocking) => {
		clearTimeout(webWorkerCtx.$asyncMsgTimer$)
		if (len(taskQueue)) {
			webWorkerCtx.$config$.logMainAccess &&
				logWorker(`Main access, tasks sent: ${taskQueue.length}`)
			const endTask = taskQueue[len(taskQueue) - 1]
			const accessReq = {
				$msgId$: `${randomId()}.${webWorkerCtx.$tabId$}`,
				$tasks$: [...taskQueue]
			}
			taskQueue.length = 0
			if (isBlocking) {
				const accessRsp = ((webWorkerCtx, accessReq) => {
					const sharedDataBuffer = webWorkerCtx.$sharedDataBuffer$
					const sharedData = new Int32Array(sharedDataBuffer)
					Atomics.store(sharedData, 0, 0)
					webWorkerCtx.$postMessage$([11, accessReq])
					Atomics.wait(sharedData, 0, 0)
					let dataLength = Atomics.load(sharedData, 0)
					let accessRespStr = ''
					let i = 0
					for (; i < dataLength; i++) {
						accessRespStr += String.fromCharCode(sharedData[i + 1])
					}
					return JSON.parse(accessRespStr)
				})(webWorkerCtx, accessReq)
				const isPromise = accessRsp.$isPromise$
				const rtnValue = deserializeFromMain(
					endTask.$winId$,
					endTask.$instanceId$,
					endTask.$applyPath$,
					accessRsp.$rtnValue$
				)
				if (accessRsp.$error$) {
					if (isPromise) {
						return Promise.reject(accessRsp.$error$)
					}
					throw new Error(accessRsp.$error$)
				}
				return isPromise ? Promise.resolve(rtnValue) : rtnValue
			}
			webWorkerCtx.$postMessage$([12, accessReq])
		}
	}
	const getter = (instance, applyPath, groupedGetters, rtnValue) => {
		if (webWorkerCtx.$config$.get) {
			rtnValue = webWorkerCtx.$config$.get(createHookOptions(instance, applyPath))
			if (rtnValue !== HookContinue) {
				return rtnValue
			}
		}
		rtnValue = queue(instance, applyPath, 1, void 0, groupedGetters)
		;((target, applyPath, rtnValue, restrictedToWorker = false, groupedGetters = false) => {
			if (webWorkerCtx.$config$.logGetters) {
				try {
					const msg = `Get ${getTargetProp(target, applyPath)}, returned: ${getLogValue(applyPath, rtnValue)}${restrictedToWorker ? ' (restricted to worker)' : ''}${groupedGetters ? ' (grouped getter)' : ''}`
					msg.includes('Symbol(') || logWorker(msg, target[WinIdKey])
				} catch (e) {}
			}
		})(instance, applyPath, rtnValue, false, !!groupedGetters)
		return rtnValue
	}
	const setter = (instance, applyPath, value, hookSetterValue) => {
		if (webWorkerCtx.$config$.set) {
			hookSetterValue = webWorkerCtx.$config$.set({
				value: value,
				prevent: HookPrevent,
				...createHookOptions(instance, applyPath)
			})
			if (hookSetterValue === HookPrevent) {
				return
			}
			hookSetterValue !== HookContinue && (value = hookSetterValue)
		}
		if (dimensionChangingSetterNames.some((s) => applyPath.includes(s))) {
			cachedDimensions.clear()
			;((target, propName) => {
				;(webWorkerCtx.$config$.logGetters || webWorkerCtx.$config$.logSetters) &&
					logWorker(`Dimension cache cleared from setter "${propName}"`, target[WinIdKey])
			})(instance, applyPath[applyPath.length - 1])
		}
		applyPath = [...applyPath, serializeInstanceForMain(instance, value), 0]
		;((target, applyPath, value, restrictedToWorker = false) => {
			if (webWorkerCtx.$config$.logSetters) {
				try {
					applyPath = applyPath.slice(0, applyPath.length - 2)
					logWorker(
						`Set ${getTargetProp(target, applyPath)}, value: ${getLogValue(applyPath, value)}${restrictedToWorker ? ' (restricted to worker)' : ''}`,
						target[WinIdKey]
					)
				} catch (e) {}
			}
		})(instance, applyPath, value)
		queue(instance, applyPath, 2)
	}
	const callMethod = (
		instance,
		applyPath,
		args,
		callType,
		assignInstanceId,
		buffer,
		rtnValue,
		methodName
	) => {
		if (webWorkerCtx.$config$.apply) {
			rtnValue = webWorkerCtx.$config$.apply({
				args: args,
				...createHookOptions(instance, applyPath)
			})
			if (rtnValue !== HookContinue) {
				return rtnValue
			}
		}
		methodName = applyPath[len(applyPath) - 1]
		applyPath = [...applyPath, serializeInstanceForMain(instance, args)]
		callType = callType || (nonBlockingMethods.includes(methodName) ? 2 : 1)
		if ('setAttribute' === methodName && hasInstanceStateValue(instance, args[0])) {
			setInstanceStateValue(instance, args[0], args[1])
		} else if (structureChangingMethodNames.includes(methodName)) {
			cachedDimensions.clear()
			cachedStructure.clear()
			;((target, methodName) => {
				;(webWorkerCtx.$config$.logGetters || webWorkerCtx.$config$.logCalls) &&
					logWorker(
						`Dimension and DOM structure cache cleared from method call ${methodName}()`,
						target[WinIdKey]
					)
			})(instance, methodName)
		} else if (dimensionChangingMethodNames.includes(methodName)) {
			callType = 2
			cachedDimensions.clear()
			logDimensionCacheClearMethod(instance, methodName)
		}
		rtnValue = queue(instance, applyPath, callType, assignInstanceId, void 0, buffer)
		;((target, applyPath, args, rtnValue) => {
			if (webWorkerCtx.$config$.logCalls) {
				try {
					applyPath = applyPath.slice(0, applyPath.length - 1)
					logWorker(
						`Call ${getTargetProp(target, applyPath)}(${args.map((v) => getLogValue(applyPath, v)).join(', ')}), returned: ${getLogValue(applyPath, rtnValue)}`,
						target[WinIdKey]
					)
				} catch (e) {}
			}
		})(instance, applyPath, args, rtnValue)
		return rtnValue
	}
	const constructGlobal = (instance, cstrName, args) => {
		;((target, cstrName, args) => {
			if (webWorkerCtx.$config$.logCalls) {
				try {
					logWorker(
						`Construct new ${cstrName}(${args.map((v) => getLogValue([], v)).join(', ')})`,
						target[WinIdKey]
					)
				} catch (e) {}
			}
		})(instance, cstrName, args)
		queue(instance, [1, cstrName, serializeInstanceForMain(instance, args)], 1)
	}
	const createHookOptions = (instance, applyPath) => ({
		name: applyPath.join('.'),
		continue: HookContinue,
		nodeName: instance[InstanceDataKey],
		constructor: getConstructorName(instance),
		instance: instance,
		window: environments[instance[WinIdKey]].$window$
	})
	const addStorageApi = (win, storageName, isSameOrigin, env) => {
		let storage = {
			getItem(key) {
				if (isSameOrigin) {
					return callMethod(win, [storageName, 'getItem'], [key], 1)
				}
				warnCrossOrigin('get', storageName, env)
			},
			setItem(key, value) {
				isSameOrigin
					? callMethod(win, [storageName, 'setItem'], [key, value], 1)
					: warnCrossOrigin('set', storageName, env)
			},
			removeItem(key) {
				isSameOrigin
					? callMethod(win, [storageName, 'removeItem'], [key], 1)
					: warnCrossOrigin('remove', storageName, env)
			},
			key(index) {
				if (isSameOrigin) {
					return callMethod(win, [storageName, 'key'], [index], 1)
				}
				warnCrossOrigin('key', storageName, env)
			},
			clear() {
				isSameOrigin
					? callMethod(win, [storageName, 'clear'], EMPTY_ARRAY, 1)
					: warnCrossOrigin('clear', storageName, env)
			},
			get length() {
				if (isSameOrigin) {
					return getter(win, [storageName, 'length'])
				}
				warnCrossOrigin('length', storageName, env)
			}
		}
		win[storageName] = new Proxy(storage, {
			get: (target, key) =>
				Reflect.has(target, key) ? Reflect.get(target, key) : target.getItem(key),
			set(target, key, value) {
				target.setItem(key, value)
				return true
			},
			has: (target, key) =>
				!!Reflect.has(target, key) || ('string' == typeof key && null !== target.getItem(key)),
			deleteProperty(target, key) {
				target.removeItem(key)
				return true
			}
		})
	}
	const createCSSStyleDeclarationCstr = (win, WorkerBase, cstrName) => {
		win[cstrName] = defineConstructorName(
			class extends WorkerBase {
				constructor(winId, instanceId, applyPath, styles) {
					super(winId, instanceId, applyPath, styles || {})
					return new Proxy(this, {
						get(target, propName) {
							if (target[propName]) {
								return target[propName]
							}
							target[propName] ||
								'string' != typeof propName ||
								target[InstanceDataKey][propName] ||
								(target[InstanceDataKey][propName] = getter(target, [propName]))
							return target[InstanceDataKey][propName]
						},
						set(target, propName, propValue) {
							target[InstanceDataKey][propName] = propValue
							setter(target, [propName], propValue)
							logDimensionCacheClearStyle(target, propName)
							cachedDimensions.clear()
							return true
						}
					})
				}
				setProperty(...args) {
					this[InstanceDataKey][args[0]] = args[1]
					callMethod(this, ['setProperty'], args, 2)
					logDimensionCacheClearStyle(this, args[0])
					cachedDimensions.clear()
				}
				getPropertyValue(propName) {
					return this[propName]
				}
				removeProperty(propName) {
					let value = this[InstanceDataKey][propName]
					callMethod(this, ['removeProperty'], [propName], 2)
					logDimensionCacheClearStyle(this, propName)
					cachedDimensions.clear()
					this[InstanceDataKey][propName] = void 0
					return value
				}
			},
			cstrName
		)
	}
	const createCSSStyleSheetConstructor = (win, cssStyleSheetCstrName) => {
		win[cssStyleSheetCstrName] = defineConstructorName(
			class {
				constructor(ownerNode) {
					this.ownerNode = ownerNode
				}
				get cssRules() {
					const ownerNode = this.ownerNode
					return new Proxy(
						{},
						{
							get(target, propKey) {
								const propName = String(propKey)
								return 'item' === propName
									? (index) => getCssRule(ownerNode, index)
									: 'length' === propName
										? getCssRules(ownerNode).length
										: isNaN(propName)
											? target[propKey]
											: getCssRule(ownerNode, propName)
							}
						}
					)
				}
				insertRule(ruleText, index) {
					const cssRules = getCssRules(this.ownerNode)
					index = void 0 === index ? 0 : index
					if (index >= 0 && index <= cssRules.length) {
						callMethod(this.ownerNode, ['sheet', 'insertRule'], [ruleText, index], 2)
						cssRules.splice(index, 0, 0)
					}
					logDimensionCacheClearMethod(this.ownerNode, 'insertRule')
					cachedDimensions.clear()
					return index
				}
				deleteRule(index) {
					callMethod(this.ownerNode, ['sheet', 'deleteRule'], [index], 2)
					getCssRules(this.ownerNode).splice(index, 1)
					logDimensionCacheClearMethod(this.ownerNode, 'deleteRule')
					cachedDimensions.clear()
				}
				get type() {
					return 'text/css'
				}
			},
			cssStyleSheetCstrName
		)
		const HTMLStyleDescriptorMap = {
			sheet: {
				get() {
					return new win[cssStyleSheetCstrName](this)
				}
			}
		}
		definePrototypePropertyDescriptor(win.HTMLStyleElement, HTMLStyleDescriptorMap)
	}
	const getCssRules = (ownerNode, cssRules) => {
		cssRules = getInstanceStateValue(ownerNode, 2)
		if (!cssRules) {
			cssRules = getter(ownerNode, ['sheet', 'cssRules'])
			setInstanceStateValue(ownerNode, 2, cssRules)
		}
		return cssRules
	}
	const getCssRule = (ownerNode, index, cssRules) => {
		cssRules = getCssRules(ownerNode)
		0 === cssRules[index] &&
			(cssRules[index] = getter(ownerNode, ['sheet', 'cssRules', parseInt(index, 10)]))
		return cssRules[index]
	}
	const runScriptContent = (env, instanceId, scriptContent, winId, errorMsg) => {
		try {
			webWorkerCtx.$config$.logScriptExecution &&
				logWorker(
					`Execute script: ${scriptContent
						.substring(0, 100)
						.split('\n')
						.map((l) => l.trim())
						.join(' ')
						.trim()
						.substring(0, 60)}...`,
					winId
				)
			env.$currentScriptId$ = instanceId
			run(env, scriptContent)
		} catch (contentError) {
			console.error(scriptContent, contentError)
			errorMsg = String(contentError.stack || contentError)
		}
		env.$currentScriptId$ = ''
		return errorMsg
	}
	const run = (env, scriptContent, scriptUrl) => {
		env.$runWindowLoadEvent$ = 1
		let sourceWithReplacedThis = ((scriptContent, newThis) =>
			scriptContent.replace(
				/([a-zA-Z0-9_$\.\'\"\`])?(\.\.\.)?this(?![a-zA-Z0-9_$:])/g,
				(match, p1, p2) => {
					const prefix = (p1 || '') + (p2 || '')
					return null != p1 ? prefix + 'this' : prefix + newThis
				}
			))(scriptContent, '(thi$(this)?window:this)')
		scriptContent =
			`with(this){${sourceWithReplacedThis.replace(/\/\/# so/g, '//Xso')}\n;function thi$(t){return t===this}};${(
				webWorkerCtx.$config$.globalFns || []
			)
				.filter((globalFnName) => /[a-zA-Z_$][0-9a-zA-Z_$]*/.test(globalFnName))
				.map((g) => `(typeof ${g}=='function'&&(this.${g}=${g}))`)
				.join(';')};` + (scriptUrl ? '\n//# sourceURL=' + scriptUrl : '')
		env.$isSameOrigin$ ||
			(scriptContent = scriptContent.replace(/.postMessage\(/g, `.postMessage('${env.$winId$}',`))
		new Function(scriptContent).call(env.$window$)
		env.$runWindowLoadEvent$ = 0
	}
	const runStateLoadHandlers = (instance, type, handlers) => {
		handlers = getInstanceStateValue(instance, type)
		handlers &&
			setTimeout(() =>
				handlers.map((cb) =>
					cb({
						type: type
					})
				)
			)
	}
	const resolveBaseLocation = (env, baseLocation) => {
		baseLocation = env.$location$
		while (!baseLocation.host) {
			env = environments[env.$parentWinId$]
			baseLocation = env.$location$
			if (env.$winId$ === env.$parentWinId$) {
				break
			}
		}
		return baseLocation
	}
	const resolveToUrl = (env, url, type, baseLocation, resolvedUrl, configResolvedUrl) => {
		baseLocation = resolveBaseLocation(env, baseLocation)
		resolvedUrl = new URL(url || '', baseLocation)
		if (type && webWorkerCtx.$config$.resolveUrl) {
			configResolvedUrl = webWorkerCtx.$config$.resolveUrl(resolvedUrl, baseLocation, type)
			if (configResolvedUrl) {
				return configResolvedUrl
			}
		}
		return resolvedUrl
	}
	const resolveUrl = (env, url, type) => resolveToUrl(env, url, type) + ''
	const resolveSendBeaconRequestParameters = (env, url) => {
		const baseLocation = resolveBaseLocation(env)
		const resolvedUrl = new URL(url || '', baseLocation)
		if (webWorkerCtx.$config$.resolveSendBeaconRequestParameters) {
			const configResolvedParams = webWorkerCtx.$config$.resolveSendBeaconRequestParameters(
				resolvedUrl,
				baseLocation
			)
			if (configResolvedParams) {
				return configResolvedParams
			}
		}
		return {}
	}
	const getPartytownScript = () =>
		`<script src="${partytownLibUrl('partytown.js?v=0.10.2')}"><\/script>`
	const createImageConstructor = (env) =>
		class HTMLImageElement {
			constructor() {
				this.s = ''
				this.l = []
				this.e = []
				this.style = {}
			}
			get src() {
				return this.s
			}
			set src(src) {
				webWorkerCtx.$config$.logImageRequests &&
					logWorker(`Image() request: ${resolveUrl(env, src, 'image')}`, env.$winId$)
				this.s = src
				fetch(resolveUrl(env, src, 'image'), {
					mode: 'no-cors',
					credentials: 'include',
					keepalive: true
				}).then(
					(rsp) => {
						rsp.ok || 0 === rsp.status
							? this.l.map((cb) =>
									cb({
										type: 'load'
									})
								)
							: this.e.map((cb) =>
									cb({
										type: 'error'
									})
								)
					},
					() =>
						this.e.forEach((cb) =>
							cb({
								type: 'error'
							})
						)
				)
			}
			addEventListener(eventName, cb) {
				'load' === eventName && this.l.push(cb)
				'error' === eventName && this.e.push(cb)
			}
			removeEventListener(eventName, cb) {
				'load' === eventName && (this.l = this.l.filter((fn) => fn !== cb))
				'error' === eventName && (this.e = this.e.filter((fn) => fn !== cb))
			}
			get onload() {
				return this.l[0]
			}
			set onload(cb) {
				this.l = [cb]
			}
			get onerror() {
				return this.e[0]
			}
			set onerror(cb) {
				this.e = [cb]
			}
		}
	const HTMLSrcElementDescriptorMap = {
		addEventListener: {
			value(...args) {
				const eventName = args[0]
				const callbacks = getInstanceStateValue(this, eventName) || []
				callbacks.push(args[1])
				setInstanceStateValue(this, eventName, callbacks)
			}
		},
		async: {
			get: noop,
			set: noop
		},
		defer: {
			get: noop,
			set: noop
		},
		onload: {
			get() {
				let callbacks = getInstanceStateValue(this, 'load')
				return (callbacks && callbacks[0]) || null
			},
			set(cb) {
				setInstanceStateValue(this, 'load', cb ? [cb] : null)
			}
		},
		onerror: {
			get() {
				let callbacks = getInstanceStateValue(this, 'error')
				return (callbacks && callbacks[0]) || null
			},
			set(cb) {
				setInstanceStateValue(this, 'error', cb ? [cb] : null)
			}
		},
		getAttribute: {
			value(attrName) {
				return 'src' === attrName ? this.src : callMethod(this, ['getAttribute'], [attrName])
			}
		},
		setAttribute: {
			value(attrName, attrValue) {
				scriptAttrPropNames.includes(attrName)
					? (this[attrName] = attrValue)
					: callMethod(this, ['setAttribute'], [attrName, attrValue])
			}
		}
	}
	const scriptAttrPropNames = commaSplit('src,type')
	const patchHTMLScriptElement = (WorkerHTMLScriptElement, env) => {
		const HTMLScriptDescriptorMap = {
			innerHTML: innerHTMLDescriptor,
			innerText: innerHTMLDescriptor,
			src: {
				get() {
					return getInstanceStateValue(this, 4) || ''
				},
				set(url) {
					const orgUrl = resolveUrl(env, url, null)
					const config = webWorkerCtx.$config$
					url = resolveUrl(env, url, 'script')
					setInstanceStateValue(this, 4, url)
					setter(this, ['src'], url)
					orgUrl !== url && setter(this, ['dataset', 'ptsrc'], orgUrl)
					if (this.type) {
						const shouldExecuteScriptViaMainThread = testIfMustLoadScriptOnMainThread(config, url)
						shouldExecuteScriptViaMainThread && setter(this, ['type'], 'text/javascript')
					}
				}
			},
			text: innerHTMLDescriptor,
			textContent: innerHTMLDescriptor,
			type: {
				get() {
					return getter(this, ['type'])
				},
				set(type) {
					if (!isScriptJsType(type)) {
						setInstanceStateValue(this, 5, type)
						setter(this, ['type'], type)
					}
				}
			},
			...HTMLSrcElementDescriptorMap
		}
		definePrototypePropertyDescriptor(WorkerHTMLScriptElement, HTMLScriptDescriptorMap)
	}
	const innerHTMLDescriptor = {
		get() {
			const type = getter(this, ['type'])
			if (isScriptJsType(type)) {
				const scriptContent = getInstanceStateValue(this, 3)
				if (scriptContent) {
					return scriptContent
				}
			}
			return getter(this, ['innerHTML']) || ''
		},
		set(scriptContent) {
			setInstanceStateValue(this, 3, scriptContent)
		}
	}
	const isScriptJsType = (scriptType) => !scriptType || 'text/javascript' === scriptType
	const createNodeCstr = (win, env, WorkerBase) => {
		const config = webWorkerCtx.$config$
		const WorkerNode = defineConstructorName(
			class extends WorkerBase {
				appendChild(node) {
					return this.insertBefore(node, null)
				}
				get href() {}
				set href(_) {}
				insertBefore(newNode, referenceNode) {
					const winId = (newNode[WinIdKey] = this[WinIdKey])
					const instanceId = newNode[InstanceIdKey]
					const nodeName = newNode[InstanceDataKey]
					const isScript = 'SCRIPT' === nodeName
					const isIFrame = 'IFRAME' === nodeName
					if (isScript) {
						const scriptContent = getInstanceStateValue(newNode, 3)
						const scriptType = getInstanceStateValue(newNode, 5)
						if (scriptContent) {
							if (isScriptJsType(scriptType)) {
								const scriptId = newNode.id
								const loadOnMainThread =
									scriptId && testIfMustLoadScriptOnMainThread(config, scriptId)
								if (loadOnMainThread) {
									setter(newNode, ['type'], 'text/javascript')
								} else {
									const errorMsg = runScriptContent(env, instanceId, scriptContent, winId, '')
									const datasetType = errorMsg ? 'pterror' : 'ptid'
									const datasetValue = errorMsg || instanceId
									setter(newNode, ['type'], 'text/partytown-x')
									setter(newNode, ['dataset', datasetType], datasetValue)
								}
							}
							setter(newNode, ['innerHTML'], scriptContent)
						}
					}
					callMethod(this, ['insertBefore'], [newNode, referenceNode], 2)
					if (isIFrame) {
						const src = getInstanceStateValue(newNode, 0)
						if (src && src.startsWith('javascript:')) {
							const scriptContent = src.split('javascript:')[1]
							runScriptContent(env, instanceId, scriptContent, winId, '')
						}
						;((winId, iframe) => {
							let i = 0
							let type
							let handlers
							let callback = () => {
								if (
									environments[winId] &&
									environments[winId].$isInitialized$ &&
									!environments[winId].$isLoading$
								) {
									type = getInstanceStateValue(iframe, 1) ? 'error' : 'load'
									handlers = getInstanceStateValue(iframe, type)
									handlers &&
										handlers.map((handler) =>
											handler({
												type: type
											})
										)
								} else if (i++ > 2e3) {
									handlers = getInstanceStateValue(iframe, 'error')
									handlers &&
										handlers.map((handler) =>
											handler({
												type: 'error'
											})
										)
								} else {
									setTimeout(callback, 9)
								}
							}
							callback()
						})(instanceId, newNode)
					}
					if (isScript) {
						sendToMain(true)
						webWorkerCtx.$postMessage$([7, winId])
					}
					return newNode
				}
				get nodeName() {
					return '#s' === this[InstanceDataKey] ? '#document-fragment' : this[InstanceDataKey]
				}
				get nodeType() {
					return 3
				}
				get ownerDocument() {
					return env.$document$
				}
			},
			'Node'
		)
		cachedTreeProps(
			WorkerNode,
			commaSplit(
				'childNodes,firstChild,isConnected,lastChild,nextSibling,parentElement,parentNode,previousSibling'
			)
		)
		win.Node = WorkerNode
	}
	const htmlMedia = commaSplit('AUDIO,CANVAS,VIDEO')
	const windowMediaConstructors = commaSplit('Audio,MediaSource')
	const patchDocument = (WorkerDocument, env, isDocumentImplementation) => {
		const DocumentDescriptorMap = {
			body: {
				get: () => env.$body$
			},
			cookie: {
				get() {
					if (env.$isSameOrigin$) {
						return getter(this, ['cookie'])
					}
					warnCrossOrigin('get', 'cookie', env)
					return ''
				},
				set(value) {
					if (env.$isSameOrigin$) {
						setter(this, ['cookie'], value)
					} else {
						warnCrossOrigin('set', 'cookie', env)
					}
				}
			},
			createElement: {
				value(tagName) {
					tagName = tagName.toUpperCase()
					if (!IS_TAG_REG.test(tagName)) {
						throw tagName + ' not valid'
					}
					const isIframe = 'IFRAME' === tagName
					const winId = this[WinIdKey]
					const instanceId = (isIframe ? 'f_' : '') + randomId()
					callMethod(this, ['createElement'], [tagName], 2, instanceId)
					const elm = getOrCreateNodeInstance(winId, instanceId, tagName)
					if (isIframe) {
						const env = createEnvironment(
							{
								$winId$: instanceId,
								$parentWinId$: winId,
								$url$: 'about:blank'
							},
							true
						)
						env.$window$.fetch = fetch
						setter(elm, ['srcdoc'], getPartytownScript())
					} else if ('SCRIPT' === tagName) {
						const scriptType = getInstanceStateValue(elm, 5)
						isScriptJsType(scriptType) && setter(elm, ['type'], 'text/partytown')
					}
					return elm
				}
			},
			createElementNS: {
				value(namespace, tagName) {
					const instanceId = randomId()
					const nsElm = getOrCreateNodeInstance(this[WinIdKey], instanceId, tagName, namespace)
					callMethod(this, ['createElementNS'], [namespace, tagName], 2, instanceId)
					return nsElm
				}
			},
			createTextNode: {
				value(text) {
					const winId = this[WinIdKey]
					const instanceId = randomId()
					const textNode = getOrCreateNodeInstance(winId, instanceId, '#text')
					callMethod(this, ['createTextNode'], [text], 2, instanceId)
					return textNode
				}
			},
			createEvent: {
				value: (type) => new Event(type)
			},
			currentScript: {
				get() {
					return env.$currentScriptId$
						? getOrCreateNodeInstance(this[WinIdKey], env.$currentScriptId$, 'SCRIPT')
						: null
				}
			},
			defaultView: {
				get: () => (isDocumentImplementation ? null : env.$window$)
			},
			documentElement: {
				get: () => env.$documentElement$
			},
			getElementsByTagName: {
				value(tagName) {
					tagName = tagName.toUpperCase()
					return 'BODY' === tagName
						? [env.$body$]
						: 'HEAD' === tagName
							? [env.$head$]
							: callMethod(this, ['getElementsByTagName'], [tagName])
				}
			},
			head: {
				get: () => env.$head$
			},
			images: {
				get() {
					return getter(this, ['images'])
				}
			},
			scripts: {
				get() {
					return getter(this, ['scripts'])
				}
			},
			implementation: {
				get() {
					return {
						hasFeature: () => true,
						createHTMLDocument: (title) => {
							const $winId$ = randomId()
							callMethod(this, ['implementation', 'createHTMLDocument'], [title], 1, {
								$winId$: $winId$
							})
							const docEnv = createEnvironment(
								{
									$winId$: $winId$,
									$parentWinId$: $winId$,
									$url$: env.$location$ + '',
									$visibilityState$: 'hidden'
								},
								true,
								true
							)
							return docEnv.$document$
						}
					}
				}
			},
			location: {
				get: () => env.$location$,
				set(url) {
					env.$location$.href = url + ''
				}
			},
			nodeType: {
				value: 9
			},
			parentNode: {
				value: null
			},
			parentElement: {
				value: null
			},
			readyState: {
				value: 'complete'
			},
			visibilityState: {
				get: () => env.$visibilityState$ || 'visible'
			}
		}
		definePrototypePropertyDescriptor(WorkerDocument, DocumentDescriptorMap)
		cachedProps(WorkerDocument, 'compatMode,referrer,forms')
	}
	const patchDocumentElementChild = (WokerDocumentElementChild, env) => {
		const DocumentElementChildDescriptorMap = {
			parentElement: {
				get() {
					return this.parentNode
				}
			},
			parentNode: {
				get: () => env.$documentElement$
			}
		}
		definePrototypePropertyDescriptor(WokerDocumentElementChild, DocumentElementChildDescriptorMap)
	}
	const patchElement = (WorkerElement, WorkerHTMLElement) => {
		const ElementDescriptorMap = {
			localName: {
				get() {
					return this[InstanceDataKey].toLowerCase()
				}
			},
			namespaceURI: {
				get() {
					return this[NamespaceKey] || 'http://www.w3.org/1999/xhtml'
				}
			},
			nodeType: {
				value: 1
			},
			tagName: {
				get() {
					return this[InstanceDataKey]
				}
			}
		}
		definePrototypePropertyDescriptor(WorkerElement, ElementDescriptorMap)
		cachedTreeProps(WorkerElement, elementStructurePropNames)
		cachedProps(WorkerElement, 'id')
		cachedDimensionProps(WorkerHTMLElement)
		cachedDimensionMethods(WorkerHTMLElement, commaSplit('getClientRects,getBoundingClientRect'))
	}
	const patchHTMLAnchorElement = (WorkerHTMLAnchorElement, env) => {
		const HTMLAnchorDescriptorMap = {}
		commaSplit('hash,host,hostname,href,origin,pathname,port,protocol,search').map((anchorProp) => {
			HTMLAnchorDescriptorMap[anchorProp] = {
				get() {
					let value = getInstanceStateValue(this, 4)
					let href
					if ('string' != typeof value) {
						href = getter(this, ['href'])
						if ('' === href) {
							return 'protocol' === anchorProp ? ':' : ''
						}
						setInstanceStateValue(this, 4, href)
						value = new URL(href)[anchorProp]
					}
					return resolveToUrl(env, value, null)[anchorProp]
				},
				set(value) {
					let url
					if ('href' === anchorProp) {
						if (
							((url) => {
								try {
									new URL(url)
									return true
								} catch (_) {
									return false
								}
							})(value)
						) {
							url = new URL(value)
						} else {
							const baseHref = env.$location$.href
							url = resolveToUrl(env, baseHref, null)
							url.href = new URL(value + '', url.href)
						}
					} else {
						url = resolveToUrl(env, this.href, null)
						url[anchorProp] = value
					}
					setInstanceStateValue(this, 4, url.href)
					setter(this, ['href'], url.href)
				}
			}
		})
		definePrototypePropertyDescriptor(WorkerHTMLAnchorElement, HTMLAnchorDescriptorMap)
	}
	const patchHTMLIFrameElement = (WorkerHTMLIFrameElement, env) => {
		const HTMLIFrameDescriptorMap = {
			contentDocument: {
				get() {
					return getIframeEnv(this).$document$
				}
			},
			contentWindow: {
				get() {
					return getIframeEnv(this).$window$
				}
			},
			src: {
				get() {
					let src = getInstanceStateValue(this, 0)
					if (src && src.startsWith('javascript:')) {
						return src
					}
					src = getIframeEnv(this).$location$.href
					return src.startsWith('about:') ? '' : src
				},
				set(src) {
					if (src) {
						if (src.startsWith('javascript:')) {
							setInstanceStateValue(this, 0, src)
						} else if (!src.startsWith('about:')) {
							let xhr = new XMLHttpRequest()
							let xhrStatus
							let env = getIframeEnv(this)
							env.$location$.href = src = resolveUrl(env, src, 'iframe')
							env.$isLoading$ = 1
							setInstanceStateValue(this, 1, void 0)
							xhr.open('GET', src, false)
							xhr.send()
							xhrStatus = xhr.status
							if (xhrStatus > 199 && xhrStatus < 300) {
								setter(
									this,
									['srcdoc'],
									`<base href="${src}">` +
										(function (text) {
											return text.replace(SCRIPT_TAG_REGEXP, (_, attrs) => {
												const parts = []
												let hasType = false
												let match
												while ((match = ATTR_REGEXP.exec(attrs))) {
													let [keyValue] = match
													if (keyValue.startsWith('type=')) {
														hasType = true
														keyValue = keyValue.replace(
															/(application|text)\/javascript/,
															SCRIPT_TYPE
														)
													}
													parts.push(keyValue)
												}
												hasType || parts.push('type="text/partytown"')
												return `<script ${parts.join(' ')}>`
											})
										})(xhr.responseText) +
										getPartytownScript()
								)
								sendToMain(true)
								webWorkerCtx.$postMessage$([7, env.$winId$])
							} else {
								setInstanceStateValue(this, 1, xhrStatus)
								env.$isLoading$ = 0
							}
						}
					}
				}
			},
			...HTMLSrcElementDescriptorMap
		}
		definePrototypePropertyDescriptor(WorkerHTMLIFrameElement, HTMLIFrameDescriptorMap)
	}
	const ATTR_REGEXP_STR = '((?:\\w|-)+(?:=(?:(?:\\w|-)+|\'[^\']*\'|"[^"]*")?)?)'
	const SCRIPT_TAG_REGEXP = new RegExp(`<script\\s*((${ATTR_REGEXP_STR}\\s*)*)>`, 'mg')
	const ATTR_REGEXP = new RegExp(ATTR_REGEXP_STR, 'mg')
	const getIframeEnv = (iframe) => {
		const $winId$ = iframe[InstanceIdKey]
		environments[$winId$] ||
			createEnvironment(
				{
					$winId$: $winId$,
					$parentWinId$: iframe[WinIdKey],
					$url$: getter(iframe, ['src']) || 'about:blank'
				},
				true
			)
		return environments[$winId$]
	}
	const patchSvgElement = (WorkerSVGGraphicsElement) => {
		const getMatrix = (elm, methodName) => {
			const { a: a, b: b, c: c, d: d, e: e, f: f } = callMethod(elm, [methodName], EMPTY_ARRAY)
			return new DOMMatrixReadOnly([a, b, c, d, e, f])
		}
		const SVGGraphicsElementDescriptorMap = {
			...WorkerSVGGraphicsElement,
			getCTM: {
				value: function () {
					return getMatrix(this, 'getCTM')
				}
			},
			getScreenCTM: {
				value: function () {
					return getMatrix(this, 'getScreenCTM')
				}
			}
		}
		definePrototypePropertyDescriptor(WorkerSVGGraphicsElement, SVGGraphicsElementDescriptorMap)
	}
	const createNamedNodeMapCstr = (win, WorkerBase) => {
		win.NamedNodeMap = defineConstructorName(
			class NamedNodeMap extends WorkerBase {
				constructor(winId, instanceId, applyPath) {
					super(winId, instanceId, applyPath)
					return new Proxy(this, {
						get(target, propName) {
							const handler = NAMED_NODE_MAP_HANDLERS[propName]
							return handler ? handler.bind(target, [propName]) : getter(target, [propName])
						},
						set(target, propName, propValue) {
							const handler = NAMED_NODE_MAP_HANDLERS[propName]
							if (handler) {
								throw new Error("Can't set read-only property: " + String(propName))
							}
							setter(target, [propName], propValue)
							return true
						}
					})
				}
			},
			'NamedNodeMap'
		)
	}
	function method(applyPath, ...args) {
		return callMethod(this, applyPath, args, 1)
	}
	const NAMED_NODE_MAP_HANDLERS = {
		getNamedItem: method,
		getNamedItemNS: method,
		item: method,
		removeNamedItem: method,
		removeNamedItemNS: method,
		setNamedItem: method,
		setNamedItemNS: method
	}
	const createWindow = (
		$winId$,
		$parentWinId$,
		url,
		$visibilityState$,
		isIframeWindow,
		isDocumentImplementation
	) => {
		let cstrInstanceId
		let cstrNodeName
		let cstrNamespace
		let cstrPrevInstance
		const WorkerBase = class {
			constructor(winId, instanceId, applyPath, instanceData, namespace) {
				this[WinIdKey] = winId || $winId$
				this[InstanceIdKey] = instanceId || cstrInstanceId || randomId()
				this[ApplyPathKey] = applyPath || []
				this[InstanceDataKey] = instanceData || cstrNodeName
				this[NamespaceKey] = namespace || cstrNamespace
				this[InstanceStateKey] = (cstrPrevInstance && cstrPrevInstance[InstanceStateKey]) || {}
				cstrInstanceId = cstrNodeName = cstrNamespace = void 0
			}
		}
		const WorkerLocation = defineConstructorName(
			class extends URL {
				assign() {
					logWorker('location.assign(), noop')
				}
				reload() {
					logWorker('location.reload(), noop')
				}
				replace() {
					logWorker('location.replace(), noop')
				}
			},
			'Location'
		)
		const $location$ = new WorkerLocation(url)
		const $isSameOrigin$ =
			$location$.origin === webWorkerCtx.$origin$ || 'about:blank' === $location$.origin
		const $isTopWindow$ = $parentWinId$ === $winId$
		const env = {}
		const getChildEnvs = () => {
			let childEnv = []
			let envWinId
			let otherEnv
			for (envWinId in environments) {
				otherEnv = environments[envWinId]
				otherEnv.$parentWinId$ !== $winId$ || otherEnv.$isTopWindow$ || childEnv.push(otherEnv)
			}
			return childEnv
		}
		const WorkerWindow = defineConstructorName(
			class extends WorkerBase {
				constructor() {
					super($winId$, $winId$)
					this.addEventListener = (...args) => {
						'load' === args[0]
							? env.$runWindowLoadEvent$ &&
								setTimeout(() =>
									args[1]({
										type: 'load'
									})
								)
							: callMethod(this, ['addEventListener'], args, 2)
					}
					let win = this
					let value
					let historyState
					let hasInitializedMedia = 0
					let initWindowMedia = () => {
						if (!hasInitializedMedia) {
							;(() => {
								if (!webWorkerCtx.$initWindowMedia$) {
									self.$bridgeToMedia$ = [
										getter,
										setter,
										callMethod,
										constructGlobal,
										definePrototypePropertyDescriptor,
										randomId,
										WinIdKey,
										InstanceIdKey,
										ApplyPathKey
									]
									webWorkerCtx.$importScripts$(partytownLibUrl('partytown-media.js?v=0.10.2'))
									webWorkerCtx.$initWindowMedia$ = self.$bridgeFromMedia$
									delete self.$bridgeFromMedia$
								}
								return webWorkerCtx.$initWindowMedia$
							})()(WorkerBase, WorkerEventTargetProxy, env, win, windowMediaConstructors)
							hasInitializedMedia = 1
						}
					}
					let nodeCstrs = {}
					let $createNode$ = (nodeName, instanceId, namespace, prevInstance) => {
						htmlMedia.includes(nodeName) && initWindowMedia()
						const NodeCstr = nodeCstrs[nodeName]
							? nodeCstrs[nodeName]
							: nodeName.includes('-')
								? nodeCstrs.UNKNOWN
								: nodeCstrs.I
						cstrInstanceId = instanceId
						cstrNodeName = nodeName
						cstrNamespace = namespace
						cstrPrevInstance = prevInstance
						return new NodeCstr()
					}
					win.Window = WorkerWindow
					win.name = name + `${normalizedWinId($winId$)} (${$winId$})`
					createNodeCstr(win, env, WorkerBase)
					;((win) => {
						win.NodeList = defineConstructorName(NodeList, 'NodeList')
					})(win)
					createNamedNodeMapCstr(win, WorkerBase)
					createCSSStyleDeclarationCstr(win, WorkerBase, 'CSSStyleDeclaration')
					;((win, WorkerBase, cstrName) => {
						win[cstrName] = defineConstructorName(
							class extends WorkerBase {
								now() {
									return performance.now()
								}
							},
							cstrName
						)
					})(win, WorkerBase, 'Performance')
					;((win, nodeCstrs) => {
						const registry = new Map()
						win.customElements = {
							define(tagName, Cstr, opts) {
								registry.set(tagName, Cstr)
								nodeCstrs[tagName.toUpperCase()] = Cstr
								const ceData = [Cstr.name, Cstr.observedAttributes]
								callMethod(win, ['customElements', 'define'], [tagName, ceData, opts])
							},
							get: (tagName) =>
								registry.get(tagName) || callMethod(win, ['customElements', 'get'], [tagName]),
							whenDefined: (tagName) =>
								registry.has(tagName)
									? Promise.resolve()
									: callMethod(win, ['customElements', 'whenDefined'], [tagName]),
							upgrade: (elm) => callMethod(win, ['customElements', 'upgrade'], [elm])
						}
					})(win, nodeCstrs)
					webWorkerCtx.$interfaces$.map(
						([cstrName, superCstrName, members, interfaceType, nodeName]) => {
							const SuperCstr = TrapConstructors[cstrName]
								? WorkerTrapProxy
								: 'EventTarget' === superCstrName
									? WorkerEventTargetProxy
									: 'Object' === superCstrName
										? WorkerBase
										: win[superCstrName]
							const Cstr = (win[cstrName] = defineConstructorName(
								12 === interfaceType
									? class extends WorkerBase {
											constructor(...args) {
												super()
												constructGlobal(this, cstrName, args)
											}
										}
									: win[cstrName] || class extends SuperCstr {},
								cstrName
							))
							nodeName && (nodeCstrs[nodeName] = Cstr)
							members.map(([memberName, memberType, staticValue]) => {
								memberName in Cstr.prototype ||
									memberName in SuperCstr.prototype ||
									('string' == typeof memberType
										? definePrototypeProperty(Cstr, memberName, {
												get() {
													if (!hasInstanceStateValue(this, memberName)) {
														const instanceId = this[InstanceIdKey]
														const applyPath = [...this[ApplyPathKey], memberName]
														const PropCstr = win[memberType]
														PropCstr &&
															setInstanceStateValue(
																this,
																memberName,
																new PropCstr($winId$, instanceId, applyPath)
															)
													}
													return getInstanceStateValue(this, memberName)
												},
												set(value) {
													setInstanceStateValue(this, memberName, value)
												}
											})
										: 5 === memberType
											? definePrototypeValue(Cstr, memberName, function (...args) {
													return callMethod(this, [memberName], args)
												})
											: memberType > 0 &&
												(void 0 !== staticValue
													? definePrototypeValue(Cstr, memberName, staticValue)
													: definePrototypeProperty(Cstr, memberName, {
															get() {
																return getter(this, [memberName])
															},
															set(value) {
																return setter(this, [memberName], value)
															}
														})))
							})
						}
					)
					commaSplit(
						'atob,btoa,crypto,indexedDB,setTimeout,setInterval,clearTimeout,clearInterval'
					).map((globalName) => {
						delete WorkerWindow.prototype[globalName]
						if (!(globalName in win)) {
							value = self[globalName]
							null != value &&
								(win[globalName] =
									'function' != typeof value || value.toString().startsWith('class')
										? value
										: value.bind(self))
						}
					})
					Object.getOwnPropertyNames(self).map((globalName) => {
						globalName in win || (win[globalName] = self[globalName])
					})
					windowMediaConstructors.map((cstrName) =>
						defineProperty(win, cstrName, {
							get() {
								initWindowMedia()
								return win[cstrName]
							}
						})
					)
					'trustedTypes' in self && (win.trustedTypes = self.trustedTypes)
					patchElement(win.Element, win.HTMLElement)
					patchDocument(win.Document, env, isDocumentImplementation)
					;((WorkerDocumentFragment) => {
						definePrototypeNodeType(WorkerDocumentFragment, 11)
						cachedTreeProps(WorkerDocumentFragment, elementStructurePropNames)
					})(win.DocumentFragment)
					patchHTMLAnchorElement(win.HTMLAnchorElement, env)
					;((WorkerHTMLFormElement) => {
						definePrototypePropertyDescriptor(WorkerHTMLFormElement, {})
						cachedProps(WorkerHTMLFormElement, 'elements')
					})(win.HTMLFormElement)
					patchHTMLIFrameElement(win.HTMLIFrameElement)
					patchHTMLScriptElement(win.HTMLScriptElement, env)
					patchSvgElement(win.SVGGraphicsElement)
					patchDocumentElementChild(win.HTMLHeadElement, env)
					patchDocumentElementChild(win.HTMLBodyElement, env)
					;((WorkerHTMLHtmlElement, env) => {
						const DocumentElementDescriptorMap = {
							parentElement: {
								value: null
							},
							parentNode: {
								get: () => env.$document$
							}
						}
						definePrototypePropertyDescriptor(WorkerHTMLHtmlElement, DocumentElementDescriptorMap)
					})(win.HTMLHtmlElement, env)
					createCSSStyleSheetConstructor(win, 'CSSStyleSheet')
					definePrototypeNodeType(win.Comment, 8)
					definePrototypeNodeType(win.DocumentType, 10)
					Object.assign(env, {
						$winId$: $winId$,
						$parentWinId$: $parentWinId$,
						$window$: new Proxy(win, {
							get: (win, propName) => {
								var _a
								if ('string' != typeof propName || isNaN(propName)) {
									return (
										null === (_a = webWorkerCtx.$config$.mainWindowAccessors) || void 0 === _a
											? void 0
											: _a.includes(propName)
									)
										? getter(this, [propName])
										: win[propName]
								}
								{
									let frame = getChildEnvs()[propName]
									return frame ? frame.$window$ : void 0
								}
							},
							has: () => true
						}),
						$document$: $createNode$('#document', $winId$ + '.d'),
						$documentElement$: $createNode$('HTML', $winId$ + '.e'),
						$head$: $createNode$('HEAD', $winId$ + '.h'),
						$body$: $createNode$('BODY', $winId$ + '.b'),
						$location$: $location$,
						$visibilityState$: $visibilityState$,
						$isSameOrigin$: $isSameOrigin$,
						$isTopWindow$: $isTopWindow$,
						$createNode$: $createNode$
					})
					win.requestAnimationFrame = (cb) => setTimeout(() => cb(performance.now()), 9)
					win.cancelAnimationFrame = (id) => clearTimeout(id)
					win.requestIdleCallback = (cb, start) => {
						start = Date.now()
						return setTimeout(
							() =>
								cb({
									didTimeout: false,
									timeRemaining: () => Math.max(0, 50 - (Date.now() - start))
								}),
							1
						)
					}
					win.cancelIdleCallback = (id) => clearTimeout(id)
					addStorageApi(win, 'localStorage', $isSameOrigin$, env)
					addStorageApi(win, 'sessionStorage', $isSameOrigin$, env)
					$isSameOrigin$ || (win.indexeddb = void 0)
					if (isIframeWindow) {
						historyState = {}
						win.history = {
							pushState(stateObj) {
								historyState = stateObj
							},
							replaceState(stateObj) {
								historyState = stateObj
							},
							get state() {
								return historyState
							},
							length: 0
						}
						win.indexeddb = void 0
					} else {
						const originalPushState = win.history.pushState.bind(win.history)
						const originalReplaceState = win.history.replaceState.bind(win.history)
						win.history.pushState = (stateObj, _, newUrl) => {
							false !== env.$propagateHistoryChange$ && originalPushState(stateObj, _, newUrl)
						}
						win.history.replaceState = (stateObj, _, newUrl) => {
							false !== env.$propagateHistoryChange$ && originalReplaceState(stateObj, _, newUrl)
						}
					}
					win.Worker = void 0
				}
				get body() {
					return env.$body$
				}
				get document() {
					return env.$document$
				}
				get documentElement() {
					return env.$documentElement$
				}
				fetch(input, init) {
					input = 'string' == typeof input || input instanceof URL ? String(input) : input.url
					return fetch(resolveUrl(env, input, 'fetch'), init)
				}
				get frames() {
					return env.$window$
				}
				get frameElement() {
					return $isTopWindow$ ? null : getOrCreateNodeInstance($parentWinId$, $winId$, 'IFRAME')
				}
				get globalThis() {
					return env.$window$
				}
				get head() {
					return env.$head$
				}
				get length() {
					return getChildEnvs().length
				}
				get location() {
					return $location$
				}
				set location(loc) {
					$location$.href = loc + ''
				}
				get Image() {
					return createImageConstructor(env)
				}
				get navigator() {
					return ((env) => {
						const nav = {
							sendBeacon: (url, body) => {
								if (webWorkerCtx.$config$.logSendBeaconRequests) {
									try {
										logWorker(
											`sendBeacon: ${resolveUrl(env, url, null)}${body ? ', data: ' + JSON.stringify(body) : ''}, resolvedParams: ${JSON.stringify(resolveSendBeaconRequestParameters(env, url))}`
										)
									} catch (e) {
										console.error(e)
									}
								}
								try {
									fetch(resolveUrl(env, url, null), {
										method: 'POST',
										body: body,
										mode: 'no-cors',
										keepalive: true,
										...resolveSendBeaconRequestParameters(env, url)
									})
									return true
								} catch (e) {
									console.error(e)
									return false
								}
							}
						}
						for (let key in navigator) {
							nav[key] = navigator[key]
						}
						return new Proxy(nav, {
							set(_, propName, propValue) {
								navigator[propName] = propValue
								return true
							},
							get(target, prop) {
								if (Object.prototype.hasOwnProperty.call(target, prop)) {
									return target[prop]
								}
								const value = getter(env.$window$, ['navigator', prop])
								return value
							}
						})
					})(env)
				}
				get origin() {
					return $location$.origin
				}
				set origin(_) {}
				get parent() {
					for (let envWinId in environments) {
						if (environments[envWinId].$winId$ === $parentWinId$) {
							return environments[envWinId].$window$
						}
					}
					return env.$window$
				}
				postMessage(...args) {
					if (environments[args[0]]) {
						len(postMessages) > 50 && postMessages.splice(0, 5)
						postMessages.push({
							$winId$: args[0],
							$data$: JSON.stringify(args[1])
						})
						args = args.slice(1)
					}
					callMethod(this, ['postMessage'], args, 3)
				}
				get self() {
					return env.$window$
				}
				get top() {
					for (let envWinId in environments) {
						if (environments[envWinId].$isTopWindow$) {
							return environments[envWinId].$window$
						}
					}
					return env.$window$
				}
				get window() {
					return env.$window$
				}
				get XMLHttpRequest() {
					const Xhr = XMLHttpRequest
					const str = String(Xhr)
					const ExtendedXhr = defineConstructorName(
						class extends Xhr {
							open(...args) {
								args[1] = resolveUrl(env, args[1], 'xhr')
								super.open(...args)
							}
							set withCredentials(_) {
								webWorkerCtx.$config$.allowXhrCredentials && (super.withCredentials = _)
							}
							toString() {
								return str
							}
						},
						getConstructorName(Xhr)
					)
					ExtendedXhr.prototype.constructor.toString = () => str
					return ExtendedXhr
				}
			},
			'Window'
		)
		const WorkerTrapProxy = class extends WorkerBase {
			constructor(winId, instanceId, applyPath, nodeName) {
				super(winId, instanceId, applyPath, nodeName)
				return new Proxy(this, {
					get: (instance, propName) => getter(instance, [propName]),
					set(instance, propName, propValue) {
						setter(instance, [propName], propValue)
						return true
					}
				})
			}
		}
		const WorkerEventTargetProxy = class extends WorkerBase {}
		eventTargetMethods.map(
			(methodName) =>
				(WorkerEventTargetProxy.prototype[methodName] = function (...args) {
					return callMethod(this, [methodName], args, 2)
				})
		)
		cachedProps(WorkerWindow, 'devicePixelRatio')
		cachedDimensionProps(WorkerWindow)
		cachedDimensionMethods(WorkerWindow, ['getComputedStyle'])
		new WorkerWindow()
		return env
	}
	const TrapConstructors = {
		DOMStringMap: 1,
		NamedNodeMap: 1
	}
	const createEnvironment = (
		{
			$winId$: $winId$,
			$parentWinId$: $parentWinId$,
			$url$: $url$,
			$visibilityState$: $visibilityState$
		},
		isIframeWindow,
		isDocumentImplementation
	) => {
		if (!environments[$winId$]) {
			environments[$winId$] = createWindow(
				$winId$,
				$parentWinId$,
				$url$,
				$visibilityState$,
				isIframeWindow,
				isDocumentImplementation
			)
			{
				const winType = $winId$ === $parentWinId$ ? 'top' : 'iframe'
				logWorker(`Created ${winType} window ${normalizedWinId($winId$)} environment`, $winId$)
			}
		}
		webWorkerCtx.$postMessage$([7, $winId$])
		return environments[$winId$]
	}
	const queuedEvents = []
	const receiveMessageFromSandboxToWorker = (ev) => {
		const msg = ev.data
		const msgType = msg[0]
		const msgValue = msg[1]
		if (webWorkerCtx.$isInitialized$) {
			if (7 === msgType) {
				;(async (initScript) => {
					let winId = initScript.$winId$
					let instanceId = initScript.$instanceId$
					let instance = getOrCreateNodeInstance(winId, instanceId, 'SCRIPT')
					let scriptContent = initScript.$content$
					let scriptSrc = initScript.$url$
					let scriptOrgSrc = initScript.$orgUrl$
					let errorMsg = ''
					let env = environments[winId]
					let rsp
					let javascriptContentTypes = [
						'text/jscript',
						'text/javascript',
						'text/x-javascript',
						'application/javascript',
						'application/x-javascript',
						'text/ecmascript',
						'text/x-ecmascript',
						'application/ecmascript'
					]
					if (scriptSrc) {
						try {
							scriptSrc = resolveToUrl(env, scriptSrc, 'script') + ''
							setInstanceStateValue(instance, 4, scriptSrc)
							webWorkerCtx.$config$.logScriptExecution &&
								logWorker(`Execute script src: ${scriptOrgSrc}`, winId)
							rsp = await fetch(scriptSrc)
							if (rsp.ok) {
								let responseContentType = rsp.headers.get('content-type')
								let shouldExecute = javascriptContentTypes.some((ct) => {
									var _a, _b, _c
									return null ===
										(_c =
											null ===
												(_a =
													null == responseContentType ? void 0 : responseContentType.toLowerCase) ||
											void 0 === _a
												? void 0
												: (_b = _a.call(responseContentType)).includes) || void 0 === _c
										? void 0
										: _c.call(_b, ct)
								})
								if (shouldExecute) {
									scriptContent = await rsp.text()
									env.$currentScriptId$ = instanceId
									run(env, scriptContent, scriptOrgSrc || scriptSrc)
								}
								runStateLoadHandlers(instance, 'load')
							} else {
								errorMsg = rsp.statusText
								runStateLoadHandlers(instance, 'error')
							}
						} catch (urlError) {
							console.error(urlError)
							errorMsg = String(urlError.stack || urlError)
							runStateLoadHandlers(instance, 'error')
						}
					} else {
						scriptContent &&
							(errorMsg = runScriptContent(env, instanceId, scriptContent, winId, errorMsg))
					}
					env.$currentScriptId$ = ''
					webWorkerCtx.$postMessage$([6, winId, instanceId, errorMsg])
				})(msgValue)
			} else if (9 === msgType) {
				;(({
					$winId$: $winId$,
					$instanceId$: $instanceId$,
					$refId$: $refId$,
					$thisArg$: $thisArg$,
					$args$: $args$
				}) => {
					if (webWorkerRefsByRefId[$refId$]) {
						try {
							webWorkerRefsByRefId[$refId$].apply(
								deserializeFromMain($winId$, $instanceId$, [], $thisArg$),
								deserializeFromMain($winId$, $instanceId$, [], $args$)
							)
						} catch (e) {
							console.error(e)
						}
					}
				})(msgValue)
			} else if (10 === msgType) {
				;(({ $winId$: $winId$, $forward$: $forward$, $args$: $args$ }) => {
					try {
						let target = environments[$winId$].$window$
						let i = 0
						let l = len($forward$)
						for (; i < l; i++) {
							i + 1 < l
								? (target = target[$forward$[i]])
								: target[$forward$[i]].apply(target, deserializeFromMain(null, $winId$, [], $args$))
						}
					} catch (e) {
						console.error(e)
					}
				})(msgValue)
			} else if (5 === msgType) {
				createEnvironment(msgValue)
			} else if (8 === msgType) {
				if (1 !== environments[msgValue].$isInitialized$) {
					const winId = msgValue
					const env = environments[winId]
					const winType = env.$winId$ === env.$parentWinId$ ? 'top' : 'iframe'
					logWorker(`Initialized ${winType} window ${normalizedWinId(winId)} environment 🎉`, winId)
				}
				environments[msgValue].$isInitialized$ = 1
				environments[msgValue].$isLoading$ = 0
			} else if (14 === msgType) {
				environments[msgValue].$visibilityState$ = msg[2]
			} else if (13 === msgType) {
				const $winId$ = msgValue.$winId$
				const env = environments[$winId$]
				env.$location$.href = msgValue.url
				!(function ($winId$, env, data) {
					const history = env.$window$.history
					switch (data.type) {
						case 0:
							env.$propagateHistoryChange$ = false
							try {
								history.pushState(data.state, '', data.newUrl)
							} catch (e) {}
							env.$propagateHistoryChange$ = true
							break

						case 1:
							env.$propagateHistoryChange$ = false
							try {
								history.replaceState(data.state, '', data.newUrl)
							} catch (e) {}
							env.$propagateHistoryChange$ = true
					}
				})(msgValue.$winId$, env, msgValue)
			} else {
				15 === msgType &&
					((_type, winId, instanceId, callbackName, args) => {
						const elm = getOrCreateNodeInstance(winId, instanceId)
						elm && 'function' == typeof elm[callbackName] && elm[callbackName].apply(elm, args)
					})(...msg)
			}
		} else if (1 === msgType) {
			;((initWebWorkerData) => {
				const config = (webWorkerCtx.$config$ = JSON.parse(initWebWorkerData.$config$))
				const locOrigin = initWebWorkerData.$origin$
				webWorkerCtx.$importScripts$ = importScripts.bind(self)
				webWorkerCtx.$interfaces$ = initWebWorkerData.$interfaces$
				webWorkerCtx.$libPath$ = initWebWorkerData.$libPath$
				webWorkerCtx.$origin$ = locOrigin
				webWorkerCtx.$postMessage$ = postMessage.bind(self)
				webWorkerCtx.$sharedDataBuffer$ = initWebWorkerData.$sharedDataBuffer$
				webWorkerCtx.$tabId$ = initWebWorkerData.$tabId$
				self.importScripts = void 0
				delete self.postMessage
				delete self.WorkerGlobalScope
				commaSplit('resolveUrl,resolveSendBeaconRequestParameters,get,set,apply').map(
					(configName) => {
						config[configName] &&
							(config[configName] = new Function('return ' + config[configName])())
					}
				)
			})(msgValue)
			webWorkerCtx.$postMessage$([2])
		} else if (3 === msgType) {
			webWorkerCtx.$interfaces$ = [...webWorkerCtx.$interfaces$, ...msgValue]
			webWorkerCtx.$isInitialized$ = 1
			logWorker('Initialized web worker')
			webWorkerCtx.$postMessage$([4])
			queuedEvents.length && logWorker(`Queued ready messages: ${queuedEvents.length}`)
			;[...queuedEvents].map(receiveMessageFromSandboxToWorker)
			queuedEvents.length = 0
		} else {
			queuedEvents.push(ev)
		}
	}
	self.onmessage = receiveMessageFromSandboxToWorker
	postMessage([0])
})(self)

================
File: static/~partytown/debug/partytown-ww-sw.js
================
/* Partytown 0.10.2 - MIT builder.io */
;((self) => {
	const WinIdKey = Symbol()
	const InstanceIdKey = Symbol()
	const InstanceDataKey = Symbol()
	const NamespaceKey = Symbol()
	const ApplyPathKey = Symbol()
	const InstanceStateKey = Symbol()
	const HookContinue = Symbol()
	const HookPrevent = Symbol()
	const webWorkerInstances = new Map()
	const webWorkerRefsByRefId = {}
	const webWorkerRefIdsByRef = new WeakMap()
	const postMessages = []
	const webWorkerCtx = {}
	const environments = {}
	const cachedDimensions = new Map()
	const cachedStructure = new Map()
	const commaSplit = (str) => str.split(',')
	const partytownLibUrl = (url) => {
		url = webWorkerCtx.$libPath$ + url
		if (new URL(url).origin != location.origin) {
			throw 'Invalid ' + url
		}
		return url
	}
	const getterDimensionPropNames = commaSplit(
		'clientWidth,clientHeight,clientTop,clientLeft,innerWidth,innerHeight,offsetWidth,offsetHeight,offsetTop,offsetLeft,outerWidth,outerHeight,pageXOffset,pageYOffset,scrollWidth,scrollHeight,scrollTop,scrollLeft'
	)
	const elementStructurePropNames = commaSplit(
		'childElementCount,children,firstElementChild,lastElementChild,nextElementSibling,previousElementSibling'
	)
	const structureChangingMethodNames = commaSplit('insertBefore,remove,removeChild,replaceChild')
	const dimensionChangingSetterNames = commaSplit(
		'className,width,height,hidden,innerHTML,innerText,textContent,text'
	)
	const dimensionChangingMethodNames = commaSplit('setAttribute,setAttributeNS,setProperty')
	const eventTargetMethods = commaSplit('addEventListener,dispatchEvent,removeEventListener')
	const nonBlockingMethods = eventTargetMethods.concat(
		dimensionChangingMethodNames,
		commaSplit('add,observe,remove,unobserve')
	)
	const IS_TAG_REG = /^[A-Z_]([A-Z0-9-]*[A-Z0-9])?$/
	const noop = () => {}
	const len = (obj) => obj.length
	const getConstructorName = (obj) => {
		var _a, _b, _c
		try {
			const constructorName =
				null === (_a = null == obj ? void 0 : obj.constructor) || void 0 === _a ? void 0 : _a.name
			if (constructorName) {
				return constructorName
			}
		} catch (e) {}
		try {
			const zoneJsConstructorName =
				null ===
					(_c =
						null === (_b = null == obj ? void 0 : obj.__zone_symbol__originalInstance) ||
						void 0 === _b
							? void 0
							: _b.constructor) || void 0 === _c
					? void 0
					: _c.name
			if (zoneJsConstructorName) {
				return zoneJsConstructorName
			}
		} catch (e) {}
		return ''
	}
	const EMPTY_ARRAY = []
	const randomId = () => Math.round(Math.random() * Number.MAX_SAFE_INTEGER).toString(36)
	const SCRIPT_TYPE = 'text/partytown'
	const defineProperty = (obj, memberName, descriptor) =>
		Object.defineProperty(obj, memberName, {
			...descriptor,
			configurable: true
		})
	const defineConstructorName = (Cstr, value) =>
		defineProperty(Cstr, 'name', {
			value: value
		})
	const definePrototypeProperty = (Cstr, memberName, descriptor) =>
		defineProperty(Cstr.prototype, memberName, descriptor)
	const definePrototypePropertyDescriptor = (Cstr, propertyDescriptorMap) =>
		Object.defineProperties(Cstr.prototype, propertyDescriptorMap)
	const definePrototypeValue = (Cstr, memberName, value) =>
		definePrototypeProperty(Cstr, memberName, {
			value: value,
			writable: true
		})
	Object.freeze(
		((obj) => {
			const properties = new Set()
			let currentObj = obj
			do {
				Object.getOwnPropertyNames(currentObj).forEach((item) => {
					'function' == typeof currentObj[item] && properties.add(item)
				})
			} while ((currentObj = Object.getPrototypeOf(currentObj)) !== Object.prototype)
			return Array.from(properties)
		})([])
	)
	function testIfMustLoadScriptOnMainThread(config, value) {
		var _a, _b
		return (
			null !==
				(_b =
					null === (_a = config.loadScriptsOnMainThread) || void 0 === _a
						? void 0
						: _a
								.map(
									([type, value]) =>
										new RegExp(
											'string' === type
												? (function (input) {
														return input.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
													})(value)
												: value
										)
								)
								.some((regexp) => regexp.test(value))) &&
			void 0 !== _b &&
			_b
		)
	}
	const hasInstanceStateValue = (instance, stateKey) => stateKey in instance[InstanceStateKey]
	const getInstanceStateValue = (instance, stateKey) => instance[InstanceStateKey][stateKey]
	const setInstanceStateValue = (instance, stateKey, stateValue) =>
		(instance[InstanceStateKey][stateKey] = stateValue)
	const setWorkerRef = (ref, refId) => {
		if (!(refId = webWorkerRefIdsByRef.get(ref))) {
			webWorkerRefIdsByRef.set(ref, (refId = randomId()))
			webWorkerRefsByRefId[refId] = ref
		}
		return refId
	}
	const getOrCreateNodeInstance = (
		winId,
		instanceId,
		nodeName,
		namespace,
		instance,
		prevInstanceId
	) => {
		instance = webWorkerInstances.get(instanceId)
		if (!instance && nodeName && environments[winId]) {
			const prevInstance = webWorkerInstances.get(prevInstanceId || '')
			instance = environments[winId].$createNode$(nodeName, instanceId, namespace, prevInstance)
			webWorkerInstances.set(instanceId, instance)
		}
		return instance
	}
	const definePrototypeNodeType = (Cstr, nodeType) =>
		definePrototypeValue(Cstr, 'nodeType', nodeType)
	const cachedTreeProps = (Cstr, treeProps) =>
		treeProps.map((propName) =>
			definePrototypeProperty(Cstr, propName, {
				get() {
					let cacheKey = getInstanceCacheKey(this, propName)
					let result = cachedStructure.get(cacheKey)
					if (!result) {
						result = getter(this, [propName])
						cachedStructure.set(cacheKey, result)
					}
					return result
				}
			})
		)
	const getInstanceCacheKey = (instance, memberName, args) =>
		[
			instance[WinIdKey],
			instance[InstanceIdKey],
			memberName,
			...(args || EMPTY_ARRAY).map((arg) => String(arg && arg[WinIdKey] ? arg[InstanceIdKey] : arg))
		].join('.')
	const cachedProps = (Cstr, propNames) =>
		commaSplit(propNames).map((propName) =>
			definePrototypeProperty(Cstr, propName, {
				get() {
					hasInstanceStateValue(this, propName) ||
						setInstanceStateValue(this, propName, getter(this, [propName]))
					return getInstanceStateValue(this, propName)
				},
				set(val) {
					getInstanceStateValue(this, propName) !== val && setter(this, [propName], val)
					setInstanceStateValue(this, propName, val)
				}
			})
		)
	const cachedDimensionProps = (Cstr) =>
		getterDimensionPropNames.map((propName) =>
			definePrototypeProperty(Cstr, propName, {
				get() {
					const dimension = cachedDimensions.get(getInstanceCacheKey(this, propName))
					if ('number' == typeof dimension) {
						return dimension
					}
					const groupedDimensions = getter(this, [propName], getterDimensionPropNames)
					if (groupedDimensions && 'object' == typeof groupedDimensions) {
						Object.entries(groupedDimensions).map(([dimensionPropName, value]) =>
							cachedDimensions.set(getInstanceCacheKey(this, dimensionPropName), value)
						)
						return groupedDimensions[propName]
					}
					return groupedDimensions
				}
			})
		)
	const cachedDimensionMethods = (Cstr, dimensionMethodNames) =>
		dimensionMethodNames.map((methodName) => {
			Cstr.prototype[methodName] = function (...args) {
				let cacheKey = getInstanceCacheKey(this, methodName, args)
				let dimensions = cachedDimensions.get(cacheKey)
				if (!dimensions) {
					dimensions = callMethod(this, [methodName], args)
					cachedDimensions.set(cacheKey, dimensions)
				}
				return dimensions
			}
		})
	const serializeForMain = ($winId$, $instanceId$, value, added, type) =>
		void 0 !== value && (type = typeof value)
			? 'string' === type || 'boolean' === type || 'number' === type || null == value
				? [0, value]
				: 'function' === type
					? [
							4,
							{
								$winId$: $winId$,
								$instanceId$: $instanceId$,
								$refId$: setWorkerRef(value)
							}
						]
					: (added = added || new Set()) && Array.isArray(value)
						? added.has(value)
							? [1, []]
							: added.add(value) && [
									1,
									value.map((v) => serializeForMain($winId$, $instanceId$, v, added))
								]
						: 'object' === type
							? value[InstanceIdKey]
								? [3, [value[WinIdKey], value[InstanceIdKey]]]
								: value instanceof Event
									? [5, serializeObjectForMain($winId$, $instanceId$, value, false, added)]
									: supportsTrustedHTML && value instanceof TrustedHTML
										? [0, value.toString()]
										: value instanceof ArrayBuffer
											? [8, value]
											: ArrayBuffer.isView(value)
												? [9, value.buffer, getConstructorName(value)]
												: [2, serializeObjectForMain($winId$, $instanceId$, value, true, added)]
							: void 0
			: value
	const supportsTrustedHTML = 'undefined' != typeof TrustedHTML
	const serializeObjectForMain = (
		winId,
		instanceId,
		obj,
		includeFunctions,
		added,
		serializedObj,
		propName,
		propValue
	) => {
		serializedObj = {}
		if (!added.has(obj)) {
			added.add(obj)
			for (propName in obj) {
				propValue = obj[propName]
				;(includeFunctions || 'function' != typeof propValue) &&
					(serializedObj[propName] = serializeForMain(winId, instanceId, propValue, added))
			}
		}
		return serializedObj
	}
	const serializeInstanceForMain = (instance, value) =>
		instance ? serializeForMain(instance[WinIdKey], instance[InstanceIdKey], value) : [0, value]
	const deserializeFromMain = (
		winId,
		instanceId,
		applyPath,
		serializedValueTransfer,
		serializedType,
		serializedValue,
		obj,
		key
	) => {
		if (serializedValueTransfer) {
			serializedType = serializedValueTransfer[0]
			serializedValue = serializedValueTransfer[1]
			if (0 === serializedType || 11 === serializedType || 12 === serializedType) {
				return serializedValue
			}
			if (4 === serializedType) {
				return deserializeRefFromMain(applyPath, serializedValue)
			}
			if (6 === serializedType) {
				return winId && applyPath.length > 0
					? (...args) => callMethod(environments[winId].$window$, applyPath, args, 1)
					: noop
			}
			if (3 === serializedType) {
				return getOrCreateSerializedInstance(serializedValue)
			}
			if (7 === serializedType) {
				return new NodeList(serializedValue.map(getOrCreateSerializedInstance))
			}
			if (10 === serializedType) {
				return new Attr(serializedValue)
			}
			if (1 === serializedType) {
				return serializedValue.map((v) => deserializeFromMain(winId, instanceId, applyPath, v))
			}
			if (14 === serializedType) {
				return new CustomError(serializedValue)
			}
			obj = {}
			for (key in serializedValue) {
				obj[key] = deserializeFromMain(winId, instanceId, [...applyPath, key], serializedValue[key])
			}
			if (13 === serializedType) {
				return new environments[winId].$window$.CSSStyleDeclaration(
					winId,
					instanceId,
					applyPath,
					obj
				)
			}
			if (5 === serializedType) {
				if ('message' === obj.type && obj.origin) {
					let postMessageKey = JSON.stringify(obj.data)
					let postMessageData = postMessages.find((pm) => pm.$data$ === postMessageKey)
					let env
					if (postMessageData) {
						env = environments[postMessageData.$winId$]
						if (env) {
							obj.source = env.$window$
							obj.origin = env.$location$.origin
						}
					}
				}
				return new Proxy(new Event(obj.type, obj), {
					get: (target, propName) =>
						propName in obj
							? obj[propName]
							: 'function' == typeof target[String(propName)]
								? noop
								: target[String(propName)]
				})
			}
			if (2 === serializedType) {
				return obj
			}
		}
	}
	const getOrCreateSerializedInstance = ([winId, instanceId, nodeName, prevInstanceId]) =>
		instanceId === winId && environments[winId]
			? environments[winId].$window$
			: getOrCreateNodeInstance(winId, instanceId, nodeName, void 0, void 0, prevInstanceId)
	const deserializeRefFromMain = (
		applyPath,
		{ $winId$: $winId$, $instanceId$: $instanceId$, $nodeName$: $nodeName$, $refId$: $refId$ }
	) => {
		webWorkerRefsByRefId[$refId$] ||
			webWorkerRefIdsByRef.set(
				(webWorkerRefsByRefId[$refId$] = function (...args) {
					const instance = getOrCreateNodeInstance($winId$, $instanceId$, $nodeName$)
					return callMethod(instance, applyPath, args)
				}),
				$refId$
			)
		return webWorkerRefsByRefId[$refId$]
	}
	class CustomError extends Error {
		constructor(errorObject) {
			super(errorObject.message)
			this.name = errorObject.name
			this.message = errorObject.message
			this.stack = errorObject.stack
		}
	}
	class NodeList {
		constructor(nodes) {
			;(this._ = nodes).map((node, index) => (this[index] = node))
		}
		entries() {
			return this._.entries()
		}
		forEach(cb, thisArg) {
			this._.map(cb, thisArg)
		}
		item(index) {
			return this[index]
		}
		keys() {
			return this._.keys()
		}
		get length() {
			return len(this._)
		}
		values() {
			return this._.values()
		}
		[Symbol.iterator]() {
			return this._[Symbol.iterator]()
		}
	}
	const Attr = class {
		constructor(serializedAttr) {
			this.name = serializedAttr[0]
			this.value = serializedAttr[1]
		}
		get nodeName() {
			return this.name
		}
		get nodeType() {
			return 2
		}
	}
	const warnCrossOrigin = (apiType, apiName, env) =>
		console.warn(`Partytown unable to ${apiType} cross-origin ${apiName}: ` + env.$location$)
	const logWorker = (msg, winId) => {
		try {
			const config = webWorkerCtx.$config$
			if (config.logStackTraces) {
				const frames = new Error().stack.split('\n')
				const i = frames.findIndex((f) => f.includes('logWorker'))
				msg += '\n' + frames.slice(i + 1).join('\n')
			}
			let prefix
			let color
			if (winId) {
				prefix = `Worker (${normalizedWinId(winId)}) 🎉`
				color = winColor(winId)
			} else {
				prefix = self.name
				color = '#9844bf'
			}
			if (webWorkerCtx.lastLog !== msg) {
				webWorkerCtx.lastLog = msg
				console.debug.apply(console, [
					`%c${prefix}`,
					`background: ${color}; color: white; padding: 2px 3px; border-radius: 2px; font-size: 0.8em;`,
					msg
				])
			}
		} catch (e) {}
	}
	const winIds = []
	const normalizedWinId = (winId) => {
		winIds.includes(winId) || winIds.push(winId)
		return winIds.indexOf(winId) + 1
	}
	const winColor = (winId) => {
		const colors = ['#00309e', '#ea3655', '#eea727']
		const index = normalizedWinId(winId) - 1
		return colors[index] || colors[colors.length - 1]
	}
	const getTargetProp = (target, applyPath) => {
		let n = ''
		if (target) {
			const cstrName = getConstructorName(target)
			if ('Window' === cstrName) {
				n = ''
			} else if ('string' == typeof target[InstanceDataKey]) {
				let nodeName = target[InstanceDataKey]
				n =
					'#text' === nodeName
						? 'textNode.'
						: '#comment' === nodeName
							? 'commentNode.'
							: '#document' === nodeName
								? 'document.'
								: 'html' === nodeName
									? 'doctype.'
									: nodeName.toLowerCase() + '.'
			} else {
				n =
					'nodeType' in target && 2 === target.nodeType
						? 'attributes.'
						: 'CanvasRenderingContext2D' === cstrName
							? 'context2D.'
							: 'CanvasRenderingContextWebGL' === cstrName
								? 'contextWebGL.'
								: 'CSSStyleDeclaration' === cstrName
									? 'style.'
									: 'MutationObserver' === cstrName
										? 'mutationObserver.'
										: 'NamedNodeMap' === cstrName
											? 'namedNodeMap.'
											: 'ResizeObserver' === cstrName
												? 'resizeObserver.'
												: cstrName.substring(0, 1).toLowerCase() + cstrName.substring(1) + '.'
			}
			target[ApplyPathKey] &&
				target[ApplyPathKey].length &&
				(n += [...target[ApplyPathKey]].join('.') + '.')
		}
		if (applyPath.length > 1) {
			const first = applyPath.slice(0, applyPath.length - 1)
			const last = applyPath[applyPath.length - 1]
			if (!isNaN(last)) {
				return n + `${first.join('.')}[${last}]`
			}
		}
		return n + applyPath.join('.')
	}
	const getLogValue = (applyPath, v) => {
		const type = typeof v
		if (void 0 === v) {
			return 'undefined'
		}
		if ('boolean' === type || 'number' === type || null == v) {
			return JSON.stringify(v)
		}
		if ('string' === type) {
			return applyPath.includes('cookie')
				? JSON.stringify(v.slice(0, 10) + '...')
				: JSON.stringify(v.length > 50 ? v.slice(0, 40) + '...' : v)
		}
		if (Array.isArray(v)) {
			return `[${v.map(getLogValue).join(', ')}]`
		}
		if ('object' === type) {
			const instanceId = v[InstanceIdKey]
			const cstrName = getConstructorName(v)
			if ('string' == typeof instanceId) {
				if ('Window' === cstrName) {
					return 'window'
				}
				if ('string' == typeof v[InstanceDataKey]) {
					if (1 === v.nodeType) {
						return `<${v[InstanceDataKey].toLowerCase()}>`
					}
					if (10 === v.nodeType) {
						return `<!DOCTYPE ${v[InstanceDataKey]}>`
					}
					if (v.nodeType <= 11) {
						return v[InstanceDataKey]
					}
				}
				return '¯\\_(ツ)_/¯ instance obj'
			}
			return v[Symbol.iterator]
				? `[${Array.from(v)
						.map((i) => getLogValue(applyPath, i))
						.join(', ')}]`
				: 'value' in v
					? 'string' == typeof v.value
						? `"${v.value}"`
						: objToString(v.value)
					: objToString(v)
		}
		return ((v) => 'object' == typeof v && v && v.then)(v)
			? 'Promise'
			: 'function' === type
				? `ƒ() ${v.name || ''}`.trim()
				: `¯\\_(ツ)_/¯ ${String(v)}`.trim()
	}
	const objToString = (obj) => {
		const s = []
		for (let key in obj) {
			const value = obj[key]
			const type = typeof value
			'string' === type
				? s.push(`${key}: "${value}"`)
				: 'function' === type
					? s.push(`${key}: ƒ`)
					: Array.isArray(type)
						? s.push(`${key}: [..]`)
						: 'object' === type && value
							? s.push(`${key}: {..}`)
							: s.push(`${key}: ${String(value)}`)
		}
		let str = s.join(', ')
		str.length > 200 && (str = str.substring(0, 200) + '..')
		return `{ ${str} }`
	}
	const logDimensionCacheClearStyle = (target, propName) => {
		;(webWorkerCtx.$config$.logGetters || webWorkerCtx.$config$.logSetters) &&
			logWorker(`Dimension cache cleared from style.${propName} setter`, target[WinIdKey])
	}
	const logDimensionCacheClearMethod = (target, methodName) => {
		;(webWorkerCtx.$config$.logGetters || webWorkerCtx.$config$.logCalls) &&
			logWorker(`Dimension cache cleared from method call ${methodName}()`, target[WinIdKey])
	}
	const taskQueue = []
	const queue = (instance, $applyPath$, callType, $assignInstanceId$, $groupedGetters$, buffer) => {
		if (instance[ApplyPathKey]) {
			taskQueue.push({
				$winId$: instance[WinIdKey],
				$instanceId$: instance[InstanceIdKey],
				$applyPath$: [...instance[ApplyPathKey], ...$applyPath$],
				$assignInstanceId$: $assignInstanceId$,
				$groupedGetters$: $groupedGetters$
			})
			taskQueue[len(taskQueue) - 1].$debug$ = ((target, applyPath, callType) => {
				let m = getTargetProp(target, applyPath)
				1 === callType
					? (m += ' (blocking)')
					: 2 === callType
						? (m += ' (non-blocking)')
						: 3 === callType && (m += ' (non-blocking, no-side-effect)')
				return m.trim()
			})(instance, $applyPath$, callType)
			buffer && 3 !== callType && console.error('buffer must be sent NonBlockingNoSideEffect')
			if (3 === callType) {
				webWorkerCtx.$postMessage$(
					[
						12,
						{
							$msgId$: randomId(),
							$tasks$: [...taskQueue]
						}
					],
					buffer ? [buffer instanceof ArrayBuffer ? buffer : buffer.buffer] : void 0
				)
				taskQueue.length = 0
			} else if (1 === callType) {
				return sendToMain(true)
			}
			webWorkerCtx.$asyncMsgTimer$ = setTimeout(sendToMain, 20)
		}
	}
	const sendToMain = (isBlocking) => {
		clearTimeout(webWorkerCtx.$asyncMsgTimer$)
		if (len(taskQueue)) {
			webWorkerCtx.$config$.logMainAccess &&
				logWorker(`Main access, tasks sent: ${taskQueue.length}`)
			const endTask = taskQueue[len(taskQueue) - 1]
			const accessReq = {
				$msgId$: `${randomId()}.${webWorkerCtx.$tabId$}`,
				$tasks$: [...taskQueue]
			}
			taskQueue.length = 0
			if (isBlocking) {
				const accessRsp = ((webWorkerCtx, accessReq) => {
					const xhr = new XMLHttpRequest()
					xhr.open('POST', partytownLibUrl('proxytown'), false)
					xhr.send(JSON.stringify(accessReq))
					return JSON.parse(xhr.responseText)
				})(0, accessReq)
				const isPromise = accessRsp.$isPromise$
				const rtnValue = deserializeFromMain(
					endTask.$winId$,
					endTask.$instanceId$,
					endTask.$applyPath$,
					accessRsp.$rtnValue$
				)
				if (accessRsp.$error$) {
					if (isPromise) {
						return Promise.reject(accessRsp.$error$)
					}
					throw new Error(accessRsp.$error$)
				}
				return isPromise ? Promise.resolve(rtnValue) : rtnValue
			}
			webWorkerCtx.$postMessage$([12, accessReq])
		}
	}
	const getter = (instance, applyPath, groupedGetters, rtnValue) => {
		if (webWorkerCtx.$config$.get) {
			rtnValue = webWorkerCtx.$config$.get(createHookOptions(instance, applyPath))
			if (rtnValue !== HookContinue) {
				return rtnValue
			}
		}
		rtnValue = queue(instance, applyPath, 1, void 0, groupedGetters)
		;((target, applyPath, rtnValue, restrictedToWorker = false, groupedGetters = false) => {
			if (webWorkerCtx.$config$.logGetters) {
				try {
					const msg = `Get ${getTargetProp(target, applyPath)}, returned: ${getLogValue(applyPath, rtnValue)}${restrictedToWorker ? ' (restricted to worker)' : ''}${groupedGetters ? ' (grouped getter)' : ''}`
					msg.includes('Symbol(') || logWorker(msg, target[WinIdKey])
				} catch (e) {}
			}
		})(instance, applyPath, rtnValue, false, !!groupedGetters)
		return rtnValue
	}
	const setter = (instance, applyPath, value, hookSetterValue) => {
		if (webWorkerCtx.$config$.set) {
			hookSetterValue = webWorkerCtx.$config$.set({
				value: value,
				prevent: HookPrevent,
				...createHookOptions(instance, applyPath)
			})
			if (hookSetterValue === HookPrevent) {
				return
			}
			hookSetterValue !== HookContinue && (value = hookSetterValue)
		}
		if (dimensionChangingSetterNames.some((s) => applyPath.includes(s))) {
			cachedDimensions.clear()
			;((target, propName) => {
				;(webWorkerCtx.$config$.logGetters || webWorkerCtx.$config$.logSetters) &&
					logWorker(`Dimension cache cleared from setter "${propName}"`, target[WinIdKey])
			})(instance, applyPath[applyPath.length - 1])
		}
		applyPath = [...applyPath, serializeInstanceForMain(instance, value), 0]
		;((target, applyPath, value, restrictedToWorker = false) => {
			if (webWorkerCtx.$config$.logSetters) {
				try {
					applyPath = applyPath.slice(0, applyPath.length - 2)
					logWorker(
						`Set ${getTargetProp(target, applyPath)}, value: ${getLogValue(applyPath, value)}${restrictedToWorker ? ' (restricted to worker)' : ''}`,
						target[WinIdKey]
					)
				} catch (e) {}
			}
		})(instance, applyPath, value)
		queue(instance, applyPath, 2)
	}
	const callMethod = (
		instance,
		applyPath,
		args,
		callType,
		assignInstanceId,
		buffer,
		rtnValue,
		methodName
	) => {
		if (webWorkerCtx.$config$.apply) {
			rtnValue = webWorkerCtx.$config$.apply({
				args: args,
				...createHookOptions(instance, applyPath)
			})
			if (rtnValue !== HookContinue) {
				return rtnValue
			}
		}
		methodName = applyPath[len(applyPath) - 1]
		applyPath = [...applyPath, serializeInstanceForMain(instance, args)]
		callType = callType || (nonBlockingMethods.includes(methodName) ? 2 : 1)
		if ('setAttribute' === methodName && hasInstanceStateValue(instance, args[0])) {
			setInstanceStateValue(instance, args[0], args[1])
		} else if (structureChangingMethodNames.includes(methodName)) {
			cachedDimensions.clear()
			cachedStructure.clear()
			;((target, methodName) => {
				;(webWorkerCtx.$config$.logGetters || webWorkerCtx.$config$.logCalls) &&
					logWorker(
						`Dimension and DOM structure cache cleared from method call ${methodName}()`,
						target[WinIdKey]
					)
			})(instance, methodName)
		} else if (dimensionChangingMethodNames.includes(methodName)) {
			callType = 2
			cachedDimensions.clear()
			logDimensionCacheClearMethod(instance, methodName)
		}
		rtnValue = queue(instance, applyPath, callType, assignInstanceId, void 0, buffer)
		;((target, applyPath, args, rtnValue) => {
			if (webWorkerCtx.$config$.logCalls) {
				try {
					applyPath = applyPath.slice(0, applyPath.length - 1)
					logWorker(
						`Call ${getTargetProp(target, applyPath)}(${args.map((v) => getLogValue(applyPath, v)).join(', ')}), returned: ${getLogValue(applyPath, rtnValue)}`,
						target[WinIdKey]
					)
				} catch (e) {}
			}
		})(instance, applyPath, args, rtnValue)
		return rtnValue
	}
	const constructGlobal = (instance, cstrName, args) => {
		;((target, cstrName, args) => {
			if (webWorkerCtx.$config$.logCalls) {
				try {
					logWorker(
						`Construct new ${cstrName}(${args.map((v) => getLogValue([], v)).join(', ')})`,
						target[WinIdKey]
					)
				} catch (e) {}
			}
		})(instance, cstrName, args)
		queue(instance, [1, cstrName, serializeInstanceForMain(instance, args)], 1)
	}
	const createHookOptions = (instance, applyPath) => ({
		name: applyPath.join('.'),
		continue: HookContinue,
		nodeName: instance[InstanceDataKey],
		constructor: getConstructorName(instance),
		instance: instance,
		window: environments[instance[WinIdKey]].$window$
	})
	const addStorageApi = (win, storageName, isSameOrigin, env) => {
		let storage = {
			getItem(key) {
				if (isSameOrigin) {
					return callMethod(win, [storageName, 'getItem'], [key], 1)
				}
				warnCrossOrigin('get', storageName, env)
			},
			setItem(key, value) {
				isSameOrigin
					? callMethod(win, [storageName, 'setItem'], [key, value], 1)
					: warnCrossOrigin('set', storageName, env)
			},
			removeItem(key) {
				isSameOrigin
					? callMethod(win, [storageName, 'removeItem'], [key], 1)
					: warnCrossOrigin('remove', storageName, env)
			},
			key(index) {
				if (isSameOrigin) {
					return callMethod(win, [storageName, 'key'], [index], 1)
				}
				warnCrossOrigin('key', storageName, env)
			},
			clear() {
				isSameOrigin
					? callMethod(win, [storageName, 'clear'], EMPTY_ARRAY, 1)
					: warnCrossOrigin('clear', storageName, env)
			},
			get length() {
				if (isSameOrigin) {
					return getter(win, [storageName, 'length'])
				}
				warnCrossOrigin('length', storageName, env)
			}
		}
		win[storageName] = new Proxy(storage, {
			get: (target, key) =>
				Reflect.has(target, key) ? Reflect.get(target, key) : target.getItem(key),
			set(target, key, value) {
				target.setItem(key, value)
				return true
			},
			has: (target, key) =>
				!!Reflect.has(target, key) || ('string' == typeof key && null !== target.getItem(key)),
			deleteProperty(target, key) {
				target.removeItem(key)
				return true
			}
		})
	}
	const createCSSStyleDeclarationCstr = (win, WorkerBase, cstrName) => {
		win[cstrName] = defineConstructorName(
			class extends WorkerBase {
				constructor(winId, instanceId, applyPath, styles) {
					super(winId, instanceId, applyPath, styles || {})
					return new Proxy(this, {
						get(target, propName) {
							if (target[propName]) {
								return target[propName]
							}
							target[propName] ||
								'string' != typeof propName ||
								target[InstanceDataKey][propName] ||
								(target[InstanceDataKey][propName] = getter(target, [propName]))
							return target[InstanceDataKey][propName]
						},
						set(target, propName, propValue) {
							target[InstanceDataKey][propName] = propValue
							setter(target, [propName], propValue)
							logDimensionCacheClearStyle(target, propName)
							cachedDimensions.clear()
							return true
						}
					})
				}
				setProperty(...args) {
					this[InstanceDataKey][args[0]] = args[1]
					callMethod(this, ['setProperty'], args, 2)
					logDimensionCacheClearStyle(this, args[0])
					cachedDimensions.clear()
				}
				getPropertyValue(propName) {
					return this[propName]
				}
				removeProperty(propName) {
					let value = this[InstanceDataKey][propName]
					callMethod(this, ['removeProperty'], [propName], 2)
					logDimensionCacheClearStyle(this, propName)
					cachedDimensions.clear()
					this[InstanceDataKey][propName] = void 0
					return value
				}
			},
			cstrName
		)
	}
	const createCSSStyleSheetConstructor = (win, cssStyleSheetCstrName) => {
		win[cssStyleSheetCstrName] = defineConstructorName(
			class {
				constructor(ownerNode) {
					this.ownerNode = ownerNode
				}
				get cssRules() {
					const ownerNode = this.ownerNode
					return new Proxy(
						{},
						{
							get(target, propKey) {
								const propName = String(propKey)
								return 'item' === propName
									? (index) => getCssRule(ownerNode, index)
									: 'length' === propName
										? getCssRules(ownerNode).length
										: isNaN(propName)
											? target[propKey]
											: getCssRule(ownerNode, propName)
							}
						}
					)
				}
				insertRule(ruleText, index) {
					const cssRules = getCssRules(this.ownerNode)
					index = void 0 === index ? 0 : index
					if (index >= 0 && index <= cssRules.length) {
						callMethod(this.ownerNode, ['sheet', 'insertRule'], [ruleText, index], 2)
						cssRules.splice(index, 0, 0)
					}
					logDimensionCacheClearMethod(this.ownerNode, 'insertRule')
					cachedDimensions.clear()
					return index
				}
				deleteRule(index) {
					callMethod(this.ownerNode, ['sheet', 'deleteRule'], [index], 2)
					getCssRules(this.ownerNode).splice(index, 1)
					logDimensionCacheClearMethod(this.ownerNode, 'deleteRule')
					cachedDimensions.clear()
				}
				get type() {
					return 'text/css'
				}
			},
			cssStyleSheetCstrName
		)
		const HTMLStyleDescriptorMap = {
			sheet: {
				get() {
					return new win[cssStyleSheetCstrName](this)
				}
			}
		}
		definePrototypePropertyDescriptor(win.HTMLStyleElement, HTMLStyleDescriptorMap)
	}
	const getCssRules = (ownerNode, cssRules) => {
		cssRules = getInstanceStateValue(ownerNode, 2)
		if (!cssRules) {
			cssRules = getter(ownerNode, ['sheet', 'cssRules'])
			setInstanceStateValue(ownerNode, 2, cssRules)
		}
		return cssRules
	}
	const getCssRule = (ownerNode, index, cssRules) => {
		cssRules = getCssRules(ownerNode)
		0 === cssRules[index] &&
			(cssRules[index] = getter(ownerNode, ['sheet', 'cssRules', parseInt(index, 10)]))
		return cssRules[index]
	}
	const runScriptContent = (env, instanceId, scriptContent, winId, errorMsg) => {
		try {
			webWorkerCtx.$config$.logScriptExecution &&
				logWorker(
					`Execute script: ${scriptContent
						.substring(0, 100)
						.split('\n')
						.map((l) => l.trim())
						.join(' ')
						.trim()
						.substring(0, 60)}...`,
					winId
				)
			env.$currentScriptId$ = instanceId
			run(env, scriptContent)
		} catch (contentError) {
			console.error(scriptContent, contentError)
			errorMsg = String(contentError.stack || contentError)
		}
		env.$currentScriptId$ = ''
		return errorMsg
	}
	const run = (env, scriptContent, scriptUrl) => {
		env.$runWindowLoadEvent$ = 1
		let sourceWithReplacedThis = ((scriptContent, newThis) =>
			scriptContent.replace(
				/([a-zA-Z0-9_$\.\'\"\`])?(\.\.\.)?this(?![a-zA-Z0-9_$:])/g,
				(match, p1, p2) => {
					const prefix = (p1 || '') + (p2 || '')
					return null != p1 ? prefix + 'this' : prefix + newThis
				}
			))(scriptContent, '(thi$(this)?window:this)')
		scriptContent =
			`with(this){${sourceWithReplacedThis.replace(/\/\/# so/g, '//Xso')}\n;function thi$(t){return t===this}};${(
				webWorkerCtx.$config$.globalFns || []
			)
				.filter((globalFnName) => /[a-zA-Z_$][0-9a-zA-Z_$]*/.test(globalFnName))
				.map((g) => `(typeof ${g}=='function'&&(this.${g}=${g}))`)
				.join(';')};` + (scriptUrl ? '\n//# sourceURL=' + scriptUrl : '')
		env.$isSameOrigin$ ||
			(scriptContent = scriptContent.replace(/.postMessage\(/g, `.postMessage('${env.$winId$}',`))
		new Function(scriptContent).call(env.$window$)
		env.$runWindowLoadEvent$ = 0
	}
	const runStateLoadHandlers = (instance, type, handlers) => {
		handlers = getInstanceStateValue(instance, type)
		handlers &&
			setTimeout(() =>
				handlers.map((cb) =>
					cb({
						type: type
					})
				)
			)
	}
	const resolveBaseLocation = (env, baseLocation) => {
		baseLocation = env.$location$
		while (!baseLocation.host) {
			env = environments[env.$parentWinId$]
			baseLocation = env.$location$
			if (env.$winId$ === env.$parentWinId$) {
				break
			}
		}
		return baseLocation
	}
	const resolveToUrl = (env, url, type, baseLocation, resolvedUrl, configResolvedUrl) => {
		baseLocation = resolveBaseLocation(env, baseLocation)
		resolvedUrl = new URL(url || '', baseLocation)
		if (type && webWorkerCtx.$config$.resolveUrl) {
			configResolvedUrl = webWorkerCtx.$config$.resolveUrl(resolvedUrl, baseLocation, type)
			if (configResolvedUrl) {
				return configResolvedUrl
			}
		}
		return resolvedUrl
	}
	const resolveUrl = (env, url, type) => resolveToUrl(env, url, type) + ''
	const resolveSendBeaconRequestParameters = (env, url) => {
		const baseLocation = resolveBaseLocation(env)
		const resolvedUrl = new URL(url || '', baseLocation)
		if (webWorkerCtx.$config$.resolveSendBeaconRequestParameters) {
			const configResolvedParams = webWorkerCtx.$config$.resolveSendBeaconRequestParameters(
				resolvedUrl,
				baseLocation
			)
			if (configResolvedParams) {
				return configResolvedParams
			}
		}
		return {}
	}
	const getPartytownScript = () =>
		`<script src="${partytownLibUrl('partytown.js?v=0.10.2')}"><\/script>`
	const createImageConstructor = (env) =>
		class HTMLImageElement {
			constructor() {
				this.s = ''
				this.l = []
				this.e = []
				this.style = {}
			}
			get src() {
				return this.s
			}
			set src(src) {
				webWorkerCtx.$config$.logImageRequests &&
					logWorker(`Image() request: ${resolveUrl(env, src, 'image')}`, env.$winId$)
				this.s = src
				fetch(resolveUrl(env, src, 'image'), {
					mode: 'no-cors',
					credentials: 'include',
					keepalive: true
				}).then(
					(rsp) => {
						rsp.ok || 0 === rsp.status
							? this.l.map((cb) =>
									cb({
										type: 'load'
									})
								)
							: this.e.map((cb) =>
									cb({
										type: 'error'
									})
								)
					},
					() =>
						this.e.forEach((cb) =>
							cb({
								type: 'error'
							})
						)
				)
			}
			addEventListener(eventName, cb) {
				'load' === eventName && this.l.push(cb)
				'error' === eventName && this.e.push(cb)
			}
			removeEventListener(eventName, cb) {
				'load' === eventName && (this.l = this.l.filter((fn) => fn !== cb))
				'error' === eventName && (this.e = this.e.filter((fn) => fn !== cb))
			}
			get onload() {
				return this.l[0]
			}
			set onload(cb) {
				this.l = [cb]
			}
			get onerror() {
				return this.e[0]
			}
			set onerror(cb) {
				this.e = [cb]
			}
		}
	const HTMLSrcElementDescriptorMap = {
		addEventListener: {
			value(...args) {
				const eventName = args[0]
				const callbacks = getInstanceStateValue(this, eventName) || []
				callbacks.push(args[1])
				setInstanceStateValue(this, eventName, callbacks)
			}
		},
		async: {
			get: noop,
			set: noop
		},
		defer: {
			get: noop,
			set: noop
		},
		onload: {
			get() {
				let callbacks = getInstanceStateValue(this, 'load')
				return (callbacks && callbacks[0]) || null
			},
			set(cb) {
				setInstanceStateValue(this, 'load', cb ? [cb] : null)
			}
		},
		onerror: {
			get() {
				let callbacks = getInstanceStateValue(this, 'error')
				return (callbacks && callbacks[0]) || null
			},
			set(cb) {
				setInstanceStateValue(this, 'error', cb ? [cb] : null)
			}
		},
		getAttribute: {
			value(attrName) {
				return 'src' === attrName ? this.src : callMethod(this, ['getAttribute'], [attrName])
			}
		},
		setAttribute: {
			value(attrName, attrValue) {
				scriptAttrPropNames.includes(attrName)
					? (this[attrName] = attrValue)
					: callMethod(this, ['setAttribute'], [attrName, attrValue])
			}
		}
	}
	const scriptAttrPropNames = commaSplit('src,type')
	const patchHTMLScriptElement = (WorkerHTMLScriptElement, env) => {
		const HTMLScriptDescriptorMap = {
			innerHTML: innerHTMLDescriptor,
			innerText: innerHTMLDescriptor,
			src: {
				get() {
					return getInstanceStateValue(this, 4) || ''
				},
				set(url) {
					const orgUrl = resolveUrl(env, url, null)
					const config = webWorkerCtx.$config$
					url = resolveUrl(env, url, 'script')
					setInstanceStateValue(this, 4, url)
					setter(this, ['src'], url)
					orgUrl !== url && setter(this, ['dataset', 'ptsrc'], orgUrl)
					if (this.type) {
						const shouldExecuteScriptViaMainThread = testIfMustLoadScriptOnMainThread(config, url)
						shouldExecuteScriptViaMainThread && setter(this, ['type'], 'text/javascript')
					}
				}
			},
			text: innerHTMLDescriptor,
			textContent: innerHTMLDescriptor,
			type: {
				get() {
					return getter(this, ['type'])
				},
				set(type) {
					if (!isScriptJsType(type)) {
						setInstanceStateValue(this, 5, type)
						setter(this, ['type'], type)
					}
				}
			},
			...HTMLSrcElementDescriptorMap
		}
		definePrototypePropertyDescriptor(WorkerHTMLScriptElement, HTMLScriptDescriptorMap)
	}
	const innerHTMLDescriptor = {
		get() {
			const type = getter(this, ['type'])
			if (isScriptJsType(type)) {
				const scriptContent = getInstanceStateValue(this, 3)
				if (scriptContent) {
					return scriptContent
				}
			}
			return getter(this, ['innerHTML']) || ''
		},
		set(scriptContent) {
			setInstanceStateValue(this, 3, scriptContent)
		}
	}
	const isScriptJsType = (scriptType) => !scriptType || 'text/javascript' === scriptType
	const createNodeCstr = (win, env, WorkerBase) => {
		const config = webWorkerCtx.$config$
		const WorkerNode = defineConstructorName(
			class extends WorkerBase {
				appendChild(node) {
					return this.insertBefore(node, null)
				}
				get href() {}
				set href(_) {}
				insertBefore(newNode, referenceNode) {
					const winId = (newNode[WinIdKey] = this[WinIdKey])
					const instanceId = newNode[InstanceIdKey]
					const nodeName = newNode[InstanceDataKey]
					const isScript = 'SCRIPT' === nodeName
					const isIFrame = 'IFRAME' === nodeName
					if (isScript) {
						const scriptContent = getInstanceStateValue(newNode, 3)
						const scriptType = getInstanceStateValue(newNode, 5)
						if (scriptContent) {
							if (isScriptJsType(scriptType)) {
								const scriptId = newNode.id
								const loadOnMainThread =
									scriptId && testIfMustLoadScriptOnMainThread(config, scriptId)
								if (loadOnMainThread) {
									setter(newNode, ['type'], 'text/javascript')
								} else {
									const errorMsg = runScriptContent(env, instanceId, scriptContent, winId, '')
									const datasetType = errorMsg ? 'pterror' : 'ptid'
									const datasetValue = errorMsg || instanceId
									setter(newNode, ['type'], 'text/partytown-x')
									setter(newNode, ['dataset', datasetType], datasetValue)
								}
							}
							setter(newNode, ['innerHTML'], scriptContent)
						}
					}
					callMethod(this, ['insertBefore'], [newNode, referenceNode], 2)
					if (isIFrame) {
						const src = getInstanceStateValue(newNode, 0)
						if (src && src.startsWith('javascript:')) {
							const scriptContent = src.split('javascript:')[1]
							runScriptContent(env, instanceId, scriptContent, winId, '')
						}
						;((winId, iframe) => {
							let i = 0
							let type
							let handlers
							let callback = () => {
								if (
									environments[winId] &&
									environments[winId].$isInitialized$ &&
									!environments[winId].$isLoading$
								) {
									type = getInstanceStateValue(iframe, 1) ? 'error' : 'load'
									handlers = getInstanceStateValue(iframe, type)
									handlers &&
										handlers.map((handler) =>
											handler({
												type: type
											})
										)
								} else if (i++ > 2e3) {
									handlers = getInstanceStateValue(iframe, 'error')
									handlers &&
										handlers.map((handler) =>
											handler({
												type: 'error'
											})
										)
								} else {
									setTimeout(callback, 9)
								}
							}
							callback()
						})(instanceId, newNode)
					}
					if (isScript) {
						sendToMain(true)
						webWorkerCtx.$postMessage$([7, winId])
					}
					return newNode
				}
				get nodeName() {
					return '#s' === this[InstanceDataKey] ? '#document-fragment' : this[InstanceDataKey]
				}
				get nodeType() {
					return 3
				}
				get ownerDocument() {
					return env.$document$
				}
			},
			'Node'
		)
		cachedTreeProps(
			WorkerNode,
			commaSplit(
				'childNodes,firstChild,isConnected,lastChild,nextSibling,parentElement,parentNode,previousSibling'
			)
		)
		win.Node = WorkerNode
	}
	const htmlMedia = commaSplit('AUDIO,CANVAS,VIDEO')
	const windowMediaConstructors = commaSplit('Audio,MediaSource')
	const patchDocument = (WorkerDocument, env, isDocumentImplementation) => {
		const DocumentDescriptorMap = {
			body: {
				get: () => env.$body$
			},
			cookie: {
				get() {
					if (env.$isSameOrigin$) {
						return getter(this, ['cookie'])
					}
					warnCrossOrigin('get', 'cookie', env)
					return ''
				},
				set(value) {
					if (env.$isSameOrigin$) {
						setter(this, ['cookie'], value)
					} else {
						warnCrossOrigin('set', 'cookie', env)
					}
				}
			},
			createElement: {
				value(tagName) {
					tagName = tagName.toUpperCase()
					if (!IS_TAG_REG.test(tagName)) {
						throw tagName + ' not valid'
					}
					const isIframe = 'IFRAME' === tagName
					const winId = this[WinIdKey]
					const instanceId = (isIframe ? 'f_' : '') + randomId()
					callMethod(this, ['createElement'], [tagName], 2, instanceId)
					const elm = getOrCreateNodeInstance(winId, instanceId, tagName)
					if (isIframe) {
						const env = createEnvironment(
							{
								$winId$: instanceId,
								$parentWinId$: winId,
								$url$: 'about:blank'
							},
							true
						)
						env.$window$.fetch = fetch
						setter(elm, ['srcdoc'], getPartytownScript())
					} else if ('SCRIPT' === tagName) {
						const scriptType = getInstanceStateValue(elm, 5)
						isScriptJsType(scriptType) && setter(elm, ['type'], 'text/partytown')
					}
					return elm
				}
			},
			createElementNS: {
				value(namespace, tagName) {
					const instanceId = randomId()
					const nsElm = getOrCreateNodeInstance(this[WinIdKey], instanceId, tagName, namespace)
					callMethod(this, ['createElementNS'], [namespace, tagName], 2, instanceId)
					return nsElm
				}
			},
			createTextNode: {
				value(text) {
					const winId = this[WinIdKey]
					const instanceId = randomId()
					const textNode = getOrCreateNodeInstance(winId, instanceId, '#text')
					callMethod(this, ['createTextNode'], [text], 2, instanceId)
					return textNode
				}
			},
			createEvent: {
				value: (type) => new Event(type)
			},
			currentScript: {
				get() {
					return env.$currentScriptId$
						? getOrCreateNodeInstance(this[WinIdKey], env.$currentScriptId$, 'SCRIPT')
						: null
				}
			},
			defaultView: {
				get: () => (isDocumentImplementation ? null : env.$window$)
			},
			documentElement: {
				get: () => env.$documentElement$
			},
			getElementsByTagName: {
				value(tagName) {
					tagName = tagName.toUpperCase()
					return 'BODY' === tagName
						? [env.$body$]
						: 'HEAD' === tagName
							? [env.$head$]
							: callMethod(this, ['getElementsByTagName'], [tagName])
				}
			},
			head: {
				get: () => env.$head$
			},
			images: {
				get() {
					return getter(this, ['images'])
				}
			},
			scripts: {
				get() {
					return getter(this, ['scripts'])
				}
			},
			implementation: {
				get() {
					return {
						hasFeature: () => true,
						createHTMLDocument: (title) => {
							const $winId$ = randomId()
							callMethod(this, ['implementation', 'createHTMLDocument'], [title], 1, {
								$winId$: $winId$
							})
							const docEnv = createEnvironment(
								{
									$winId$: $winId$,
									$parentWinId$: $winId$,
									$url$: env.$location$ + '',
									$visibilityState$: 'hidden'
								},
								true,
								true
							)
							return docEnv.$document$
						}
					}
				}
			},
			location: {
				get: () => env.$location$,
				set(url) {
					env.$location$.href = url + ''
				}
			},
			nodeType: {
				value: 9
			},
			parentNode: {
				value: null
			},
			parentElement: {
				value: null
			},
			readyState: {
				value: 'complete'
			},
			visibilityState: {
				get: () => env.$visibilityState$ || 'visible'
			}
		}
		definePrototypePropertyDescriptor(WorkerDocument, DocumentDescriptorMap)
		cachedProps(WorkerDocument, 'compatMode,referrer,forms')
	}
	const patchDocumentElementChild = (WokerDocumentElementChild, env) => {
		const DocumentElementChildDescriptorMap = {
			parentElement: {
				get() {
					return this.parentNode
				}
			},
			parentNode: {
				get: () => env.$documentElement$
			}
		}
		definePrototypePropertyDescriptor(WokerDocumentElementChild, DocumentElementChildDescriptorMap)
	}
	const patchElement = (WorkerElement, WorkerHTMLElement) => {
		const ElementDescriptorMap = {
			localName: {
				get() {
					return this[InstanceDataKey].toLowerCase()
				}
			},
			namespaceURI: {
				get() {
					return this[NamespaceKey] || 'http://www.w3.org/1999/xhtml'
				}
			},
			nodeType: {
				value: 1
			},
			tagName: {
				get() {
					return this[InstanceDataKey]
				}
			}
		}
		definePrototypePropertyDescriptor(WorkerElement, ElementDescriptorMap)
		cachedTreeProps(WorkerElement, elementStructurePropNames)
		cachedProps(WorkerElement, 'id')
		cachedDimensionProps(WorkerHTMLElement)
		cachedDimensionMethods(WorkerHTMLElement, commaSplit('getClientRects,getBoundingClientRect'))
	}
	const patchHTMLAnchorElement = (WorkerHTMLAnchorElement, env) => {
		const HTMLAnchorDescriptorMap = {}
		commaSplit('hash,host,hostname,href,origin,pathname,port,protocol,search').map((anchorProp) => {
			HTMLAnchorDescriptorMap[anchorProp] = {
				get() {
					let value = getInstanceStateValue(this, 4)
					let href
					if ('string' != typeof value) {
						href = getter(this, ['href'])
						if ('' === href) {
							return 'protocol' === anchorProp ? ':' : ''
						}
						setInstanceStateValue(this, 4, href)
						value = new URL(href)[anchorProp]
					}
					return resolveToUrl(env, value, null)[anchorProp]
				},
				set(value) {
					let url
					if ('href' === anchorProp) {
						if (
							((url) => {
								try {
									new URL(url)
									return true
								} catch (_) {
									return false
								}
							})(value)
						) {
							url = new URL(value)
						} else {
							const baseHref = env.$location$.href
							url = resolveToUrl(env, baseHref, null)
							url.href = new URL(value + '', url.href)
						}
					} else {
						url = resolveToUrl(env, this.href, null)
						url[anchorProp] = value
					}
					setInstanceStateValue(this, 4, url.href)
					setter(this, ['href'], url.href)
				}
			}
		})
		definePrototypePropertyDescriptor(WorkerHTMLAnchorElement, HTMLAnchorDescriptorMap)
	}
	const patchHTMLIFrameElement = (WorkerHTMLIFrameElement, env) => {
		const HTMLIFrameDescriptorMap = {
			contentDocument: {
				get() {
					return getIframeEnv(this).$document$
				}
			},
			contentWindow: {
				get() {
					return getIframeEnv(this).$window$
				}
			},
			src: {
				get() {
					let src = getInstanceStateValue(this, 0)
					if (src && src.startsWith('javascript:')) {
						return src
					}
					src = getIframeEnv(this).$location$.href
					return src.startsWith('about:') ? '' : src
				},
				set(src) {
					if (src) {
						if (src.startsWith('javascript:')) {
							setInstanceStateValue(this, 0, src)
						} else if (!src.startsWith('about:')) {
							let xhr = new XMLHttpRequest()
							let xhrStatus
							let env = getIframeEnv(this)
							env.$location$.href = src = resolveUrl(env, src, 'iframe')
							env.$isLoading$ = 1
							setInstanceStateValue(this, 1, void 0)
							xhr.open('GET', src, false)
							xhr.send()
							xhrStatus = xhr.status
							if (xhrStatus > 199 && xhrStatus < 300) {
								setter(
									this,
									['srcdoc'],
									`<base href="${src}">` +
										(function (text) {
											return text.replace(SCRIPT_TAG_REGEXP, (_, attrs) => {
												const parts = []
												let hasType = false
												let match
												while ((match = ATTR_REGEXP.exec(attrs))) {
													let [keyValue] = match
													if (keyValue.startsWith('type=')) {
														hasType = true
														keyValue = keyValue.replace(
															/(application|text)\/javascript/,
															SCRIPT_TYPE
														)
													}
													parts.push(keyValue)
												}
												hasType || parts.push('type="text/partytown"')
												return `<script ${parts.join(' ')}>`
											})
										})(xhr.responseText) +
										getPartytownScript()
								)
								sendToMain(true)
								webWorkerCtx.$postMessage$([7, env.$winId$])
							} else {
								setInstanceStateValue(this, 1, xhrStatus)
								env.$isLoading$ = 0
							}
						}
					}
				}
			},
			...HTMLSrcElementDescriptorMap
		}
		definePrototypePropertyDescriptor(WorkerHTMLIFrameElement, HTMLIFrameDescriptorMap)
	}
	const ATTR_REGEXP_STR = '((?:\\w|-)+(?:=(?:(?:\\w|-)+|\'[^\']*\'|"[^"]*")?)?)'
	const SCRIPT_TAG_REGEXP = new RegExp(`<script\\s*((${ATTR_REGEXP_STR}\\s*)*)>`, 'mg')
	const ATTR_REGEXP = new RegExp(ATTR_REGEXP_STR, 'mg')
	const getIframeEnv = (iframe) => {
		const $winId$ = iframe[InstanceIdKey]
		environments[$winId$] ||
			createEnvironment(
				{
					$winId$: $winId$,
					$parentWinId$: iframe[WinIdKey],
					$url$: getter(iframe, ['src']) || 'about:blank'
				},
				true
			)
		return environments[$winId$]
	}
	const patchSvgElement = (WorkerSVGGraphicsElement) => {
		const getMatrix = (elm, methodName) => {
			const { a: a, b: b, c: c, d: d, e: e, f: f } = callMethod(elm, [methodName], EMPTY_ARRAY)
			return new DOMMatrixReadOnly([a, b, c, d, e, f])
		}
		const SVGGraphicsElementDescriptorMap = {
			...WorkerSVGGraphicsElement,
			getCTM: {
				value: function () {
					return getMatrix(this, 'getCTM')
				}
			},
			getScreenCTM: {
				value: function () {
					return getMatrix(this, 'getScreenCTM')
				}
			}
		}
		definePrototypePropertyDescriptor(WorkerSVGGraphicsElement, SVGGraphicsElementDescriptorMap)
	}
	const createNamedNodeMapCstr = (win, WorkerBase) => {
		win.NamedNodeMap = defineConstructorName(
			class NamedNodeMap extends WorkerBase {
				constructor(winId, instanceId, applyPath) {
					super(winId, instanceId, applyPath)
					return new Proxy(this, {
						get(target, propName) {
							const handler = NAMED_NODE_MAP_HANDLERS[propName]
							return handler ? handler.bind(target, [propName]) : getter(target, [propName])
						},
						set(target, propName, propValue) {
							const handler = NAMED_NODE_MAP_HANDLERS[propName]
							if (handler) {
								throw new Error("Can't set read-only property: " + String(propName))
							}
							setter(target, [propName], propValue)
							return true
						}
					})
				}
			},
			'NamedNodeMap'
		)
	}
	function method(applyPath, ...args) {
		return callMethod(this, applyPath, args, 1)
	}
	const NAMED_NODE_MAP_HANDLERS = {
		getNamedItem: method,
		getNamedItemNS: method,
		item: method,
		removeNamedItem: method,
		removeNamedItemNS: method,
		setNamedItem: method,
		setNamedItemNS: method
	}
	const createWindow = (
		$winId$,
		$parentWinId$,
		url,
		$visibilityState$,
		isIframeWindow,
		isDocumentImplementation
	) => {
		let cstrInstanceId
		let cstrNodeName
		let cstrNamespace
		let cstrPrevInstance
		const WorkerBase = class {
			constructor(winId, instanceId, applyPath, instanceData, namespace) {
				this[WinIdKey] = winId || $winId$
				this[InstanceIdKey] = instanceId || cstrInstanceId || randomId()
				this[ApplyPathKey] = applyPath || []
				this[InstanceDataKey] = instanceData || cstrNodeName
				this[NamespaceKey] = namespace || cstrNamespace
				this[InstanceStateKey] = (cstrPrevInstance && cstrPrevInstance[InstanceStateKey]) || {}
				cstrInstanceId = cstrNodeName = cstrNamespace = void 0
			}
		}
		const WorkerLocation = defineConstructorName(
			class extends URL {
				assign() {
					logWorker('location.assign(), noop')
				}
				reload() {
					logWorker('location.reload(), noop')
				}
				replace() {
					logWorker('location.replace(), noop')
				}
			},
			'Location'
		)
		const $location$ = new WorkerLocation(url)
		const $isSameOrigin$ =
			$location$.origin === webWorkerCtx.$origin$ || 'about:blank' === $location$.origin
		const $isTopWindow$ = $parentWinId$ === $winId$
		const env = {}
		const getChildEnvs = () => {
			let childEnv = []
			let envWinId
			let otherEnv
			for (envWinId in environments) {
				otherEnv = environments[envWinId]
				otherEnv.$parentWinId$ !== $winId$ || otherEnv.$isTopWindow$ || childEnv.push(otherEnv)
			}
			return childEnv
		}
		const WorkerWindow = defineConstructorName(
			class extends WorkerBase {
				constructor() {
					super($winId$, $winId$)
					this.addEventListener = (...args) => {
						'load' === args[0]
							? env.$runWindowLoadEvent$ &&
								setTimeout(() =>
									args[1]({
										type: 'load'
									})
								)
							: callMethod(this, ['addEventListener'], args, 2)
					}
					let win = this
					let value
					let historyState
					let hasInitializedMedia = 0
					let initWindowMedia = () => {
						if (!hasInitializedMedia) {
							;(() => {
								if (!webWorkerCtx.$initWindowMedia$) {
									self.$bridgeToMedia$ = [
										getter,
										setter,
										callMethod,
										constructGlobal,
										definePrototypePropertyDescriptor,
										randomId,
										WinIdKey,
										InstanceIdKey,
										ApplyPathKey
									]
									webWorkerCtx.$importScripts$(partytownLibUrl('partytown-media.js?v=0.10.2'))
									webWorkerCtx.$initWindowMedia$ = self.$bridgeFromMedia$
									delete self.$bridgeFromMedia$
								}
								return webWorkerCtx.$initWindowMedia$
							})()(WorkerBase, WorkerEventTargetProxy, env, win, windowMediaConstructors)
							hasInitializedMedia = 1
						}
					}
					let nodeCstrs = {}
					let $createNode$ = (nodeName, instanceId, namespace, prevInstance) => {
						htmlMedia.includes(nodeName) && initWindowMedia()
						const NodeCstr = nodeCstrs[nodeName]
							? nodeCstrs[nodeName]
							: nodeName.includes('-')
								? nodeCstrs.UNKNOWN
								: nodeCstrs.I
						cstrInstanceId = instanceId
						cstrNodeName = nodeName
						cstrNamespace = namespace
						cstrPrevInstance = prevInstance
						return new NodeCstr()
					}
					win.Window = WorkerWindow
					win.name = name + `${normalizedWinId($winId$)} (${$winId$})`
					createNodeCstr(win, env, WorkerBase)
					;((win) => {
						win.NodeList = defineConstructorName(NodeList, 'NodeList')
					})(win)
					createNamedNodeMapCstr(win, WorkerBase)
					createCSSStyleDeclarationCstr(win, WorkerBase, 'CSSStyleDeclaration')
					;((win, WorkerBase, cstrName) => {
						win[cstrName] = defineConstructorName(
							class extends WorkerBase {
								now() {
									return performance.now()
								}
							},
							cstrName
						)
					})(win, WorkerBase, 'Performance')
					;((win, nodeCstrs) => {
						const registry = new Map()
						win.customElements = {
							define(tagName, Cstr, opts) {
								registry.set(tagName, Cstr)
								nodeCstrs[tagName.toUpperCase()] = Cstr
								const ceData = [Cstr.name, Cstr.observedAttributes]
								callMethod(win, ['customElements', 'define'], [tagName, ceData, opts])
							},
							get: (tagName) =>
								registry.get(tagName) || callMethod(win, ['customElements', 'get'], [tagName]),
							whenDefined: (tagName) =>
								registry.has(tagName)
									? Promise.resolve()
									: callMethod(win, ['customElements', 'whenDefined'], [tagName]),
							upgrade: (elm) => callMethod(win, ['customElements', 'upgrade'], [elm])
						}
					})(win, nodeCstrs)
					webWorkerCtx.$interfaces$.map(
						([cstrName, superCstrName, members, interfaceType, nodeName]) => {
							const SuperCstr = TrapConstructors[cstrName]
								? WorkerTrapProxy
								: 'EventTarget' === superCstrName
									? WorkerEventTargetProxy
									: 'Object' === superCstrName
										? WorkerBase
										: win[superCstrName]
							const Cstr = (win[cstrName] = defineConstructorName(
								12 === interfaceType
									? class extends WorkerBase {
											constructor(...args) {
												super()
												constructGlobal(this, cstrName, args)
											}
										}
									: win[cstrName] || class extends SuperCstr {},
								cstrName
							))
							nodeName && (nodeCstrs[nodeName] = Cstr)
							members.map(([memberName, memberType, staticValue]) => {
								memberName in Cstr.prototype ||
									memberName in SuperCstr.prototype ||
									('string' == typeof memberType
										? definePrototypeProperty(Cstr, memberName, {
												get() {
													if (!hasInstanceStateValue(this, memberName)) {
														const instanceId = this[InstanceIdKey]
														const applyPath = [...this[ApplyPathKey], memberName]
														const PropCstr = win[memberType]
														PropCstr &&
															setInstanceStateValue(
																this,
																memberName,
																new PropCstr($winId$, instanceId, applyPath)
															)
													}
													return getInstanceStateValue(this, memberName)
												},
												set(value) {
													setInstanceStateValue(this, memberName, value)
												}
											})
										: 5 === memberType
											? definePrototypeValue(Cstr, memberName, function (...args) {
													return callMethod(this, [memberName], args)
												})
											: memberType > 0 &&
												(void 0 !== staticValue
													? definePrototypeValue(Cstr, memberName, staticValue)
													: definePrototypeProperty(Cstr, memberName, {
															get() {
																return getter(this, [memberName])
															},
															set(value) {
																return setter(this, [memberName], value)
															}
														})))
							})
						}
					)
					commaSplit(
						'atob,btoa,crypto,indexedDB,setTimeout,setInterval,clearTimeout,clearInterval'
					).map((globalName) => {
						delete WorkerWindow.prototype[globalName]
						if (!(globalName in win)) {
							value = self[globalName]
							null != value &&
								(win[globalName] =
									'function' != typeof value || value.toString().startsWith('class')
										? value
										: value.bind(self))
						}
					})
					Object.getOwnPropertyNames(self).map((globalName) => {
						globalName in win || (win[globalName] = self[globalName])
					})
					windowMediaConstructors.map((cstrName) =>
						defineProperty(win, cstrName, {
							get() {
								initWindowMedia()
								return win[cstrName]
							}
						})
					)
					'trustedTypes' in self && (win.trustedTypes = self.trustedTypes)
					patchElement(win.Element, win.HTMLElement)
					patchDocument(win.Document, env, isDocumentImplementation)
					;((WorkerDocumentFragment) => {
						definePrototypeNodeType(WorkerDocumentFragment, 11)
						cachedTreeProps(WorkerDocumentFragment, elementStructurePropNames)
					})(win.DocumentFragment)
					patchHTMLAnchorElement(win.HTMLAnchorElement, env)
					;((WorkerHTMLFormElement) => {
						definePrototypePropertyDescriptor(WorkerHTMLFormElement, {})
						cachedProps(WorkerHTMLFormElement, 'elements')
					})(win.HTMLFormElement)
					patchHTMLIFrameElement(win.HTMLIFrameElement)
					patchHTMLScriptElement(win.HTMLScriptElement, env)
					patchSvgElement(win.SVGGraphicsElement)
					patchDocumentElementChild(win.HTMLHeadElement, env)
					patchDocumentElementChild(win.HTMLBodyElement, env)
					;((WorkerHTMLHtmlElement, env) => {
						const DocumentElementDescriptorMap = {
							parentElement: {
								value: null
							},
							parentNode: {
								get: () => env.$document$
							}
						}
						definePrototypePropertyDescriptor(WorkerHTMLHtmlElement, DocumentElementDescriptorMap)
					})(win.HTMLHtmlElement, env)
					createCSSStyleSheetConstructor(win, 'CSSStyleSheet')
					definePrototypeNodeType(win.Comment, 8)
					definePrototypeNodeType(win.DocumentType, 10)
					Object.assign(env, {
						$winId$: $winId$,
						$parentWinId$: $parentWinId$,
						$window$: new Proxy(win, {
							get: (win, propName) => {
								var _a
								if ('string' != typeof propName || isNaN(propName)) {
									return (
										null === (_a = webWorkerCtx.$config$.mainWindowAccessors) || void 0 === _a
											? void 0
											: _a.includes(propName)
									)
										? getter(this, [propName])
										: win[propName]
								}
								{
									let frame = getChildEnvs()[propName]
									return frame ? frame.$window$ : void 0
								}
							},
							has: () => true
						}),
						$document$: $createNode$('#document', $winId$ + '.d'),
						$documentElement$: $createNode$('HTML', $winId$ + '.e'),
						$head$: $createNode$('HEAD', $winId$ + '.h'),
						$body$: $createNode$('BODY', $winId$ + '.b'),
						$location$: $location$,
						$visibilityState$: $visibilityState$,
						$isSameOrigin$: $isSameOrigin$,
						$isTopWindow$: $isTopWindow$,
						$createNode$: $createNode$
					})
					win.requestAnimationFrame = (cb) => setTimeout(() => cb(performance.now()), 9)
					win.cancelAnimationFrame = (id) => clearTimeout(id)
					win.requestIdleCallback = (cb, start) => {
						start = Date.now()
						return setTimeout(
							() =>
								cb({
									didTimeout: false,
									timeRemaining: () => Math.max(0, 50 - (Date.now() - start))
								}),
							1
						)
					}
					win.cancelIdleCallback = (id) => clearTimeout(id)
					addStorageApi(win, 'localStorage', $isSameOrigin$, env)
					addStorageApi(win, 'sessionStorage', $isSameOrigin$, env)
					$isSameOrigin$ || (win.indexeddb = void 0)
					if (isIframeWindow) {
						historyState = {}
						win.history = {
							pushState(stateObj) {
								historyState = stateObj
							},
							replaceState(stateObj) {
								historyState = stateObj
							},
							get state() {
								return historyState
							},
							length: 0
						}
						win.indexeddb = void 0
					} else {
						const originalPushState = win.history.pushState.bind(win.history)
						const originalReplaceState = win.history.replaceState.bind(win.history)
						win.history.pushState = (stateObj, _, newUrl) => {
							false !== env.$propagateHistoryChange$ && originalPushState(stateObj, _, newUrl)
						}
						win.history.replaceState = (stateObj, _, newUrl) => {
							false !== env.$propagateHistoryChange$ && originalReplaceState(stateObj, _, newUrl)
						}
					}
					win.Worker = void 0
				}
				get body() {
					return env.$body$
				}
				get document() {
					return env.$document$
				}
				get documentElement() {
					return env.$documentElement$
				}
				fetch(input, init) {
					input = 'string' == typeof input || input instanceof URL ? String(input) : input.url
					return fetch(resolveUrl(env, input, 'fetch'), init)
				}
				get frames() {
					return env.$window$
				}
				get frameElement() {
					return $isTopWindow$ ? null : getOrCreateNodeInstance($parentWinId$, $winId$, 'IFRAME')
				}
				get globalThis() {
					return env.$window$
				}
				get head() {
					return env.$head$
				}
				get length() {
					return getChildEnvs().length
				}
				get location() {
					return $location$
				}
				set location(loc) {
					$location$.href = loc + ''
				}
				get Image() {
					return createImageConstructor(env)
				}
				get navigator() {
					return ((env) => {
						const nav = {
							sendBeacon: (url, body) => {
								if (webWorkerCtx.$config$.logSendBeaconRequests) {
									try {
										logWorker(
											`sendBeacon: ${resolveUrl(env, url, null)}${body ? ', data: ' + JSON.stringify(body) : ''}, resolvedParams: ${JSON.stringify(resolveSendBeaconRequestParameters(env, url))}`
										)
									} catch (e) {
										console.error(e)
									}
								}
								try {
									fetch(resolveUrl(env, url, null), {
										method: 'POST',
										body: body,
										mode: 'no-cors',
										keepalive: true,
										...resolveSendBeaconRequestParameters(env, url)
									})
									return true
								} catch (e) {
									console.error(e)
									return false
								}
							}
						}
						for (let key in navigator) {
							nav[key] = navigator[key]
						}
						return new Proxy(nav, {
							set(_, propName, propValue) {
								navigator[propName] = propValue
								return true
							},
							get(target, prop) {
								if (Object.prototype.hasOwnProperty.call(target, prop)) {
									return target[prop]
								}
								const value = getter(env.$window$, ['navigator', prop])
								return value
							}
						})
					})(env)
				}
				get origin() {
					return $location$.origin
				}
				set origin(_) {}
				get parent() {
					for (let envWinId in environments) {
						if (environments[envWinId].$winId$ === $parentWinId$) {
							return environments[envWinId].$window$
						}
					}
					return env.$window$
				}
				postMessage(...args) {
					if (environments[args[0]]) {
						len(postMessages) > 50 && postMessages.splice(0, 5)
						postMessages.push({
							$winId$: args[0],
							$data$: JSON.stringify(args[1])
						})
						args = args.slice(1)
					}
					callMethod(this, ['postMessage'], args, 3)
				}
				get self() {
					return env.$window$
				}
				get top() {
					for (let envWinId in environments) {
						if (environments[envWinId].$isTopWindow$) {
							return environments[envWinId].$window$
						}
					}
					return env.$window$
				}
				get window() {
					return env.$window$
				}
				get XMLHttpRequest() {
					const Xhr = XMLHttpRequest
					const str = String(Xhr)
					const ExtendedXhr = defineConstructorName(
						class extends Xhr {
							open(...args) {
								args[1] = resolveUrl(env, args[1], 'xhr')
								super.open(...args)
							}
							set withCredentials(_) {
								webWorkerCtx.$config$.allowXhrCredentials && (super.withCredentials = _)
							}
							toString() {
								return str
							}
						},
						getConstructorName(Xhr)
					)
					ExtendedXhr.prototype.constructor.toString = () => str
					return ExtendedXhr
				}
			},
			'Window'
		)
		const WorkerTrapProxy = class extends WorkerBase {
			constructor(winId, instanceId, applyPath, nodeName) {
				super(winId, instanceId, applyPath, nodeName)
				return new Proxy(this, {
					get: (instance, propName) => getter(instance, [propName]),
					set(instance, propName, propValue) {
						setter(instance, [propName], propValue)
						return true
					}
				})
			}
		}
		const WorkerEventTargetProxy = class extends WorkerBase {}
		eventTargetMethods.map(
			(methodName) =>
				(WorkerEventTargetProxy.prototype[methodName] = function (...args) {
					return callMethod(this, [methodName], args, 2)
				})
		)
		cachedProps(WorkerWindow, 'devicePixelRatio')
		cachedDimensionProps(WorkerWindow)
		cachedDimensionMethods(WorkerWindow, ['getComputedStyle'])
		new WorkerWindow()
		return env
	}
	const TrapConstructors = {
		DOMStringMap: 1,
		NamedNodeMap: 1
	}
	const createEnvironment = (
		{
			$winId$: $winId$,
			$parentWinId$: $parentWinId$,
			$url$: $url$,
			$visibilityState$: $visibilityState$
		},
		isIframeWindow,
		isDocumentImplementation
	) => {
		if (!environments[$winId$]) {
			environments[$winId$] = createWindow(
				$winId$,
				$parentWinId$,
				$url$,
				$visibilityState$,
				isIframeWindow,
				isDocumentImplementation
			)
			{
				const winType = $winId$ === $parentWinId$ ? 'top' : 'iframe'
				logWorker(`Created ${winType} window ${normalizedWinId($winId$)} environment`, $winId$)
			}
		}
		webWorkerCtx.$postMessage$([7, $winId$])
		return environments[$winId$]
	}
	const queuedEvents = []
	const receiveMessageFromSandboxToWorker = (ev) => {
		const msg = ev.data
		const msgType = msg[0]
		const msgValue = msg[1]
		if (webWorkerCtx.$isInitialized$) {
			if (7 === msgType) {
				;(async (initScript) => {
					let winId = initScript.$winId$
					let instanceId = initScript.$instanceId$
					let instance = getOrCreateNodeInstance(winId, instanceId, 'SCRIPT')
					let scriptContent = initScript.$content$
					let scriptSrc = initScript.$url$
					let scriptOrgSrc = initScript.$orgUrl$
					let errorMsg = ''
					let env = environments[winId]
					let rsp
					let javascriptContentTypes = [
						'text/jscript',
						'text/javascript',
						'text/x-javascript',
						'application/javascript',
						'application/x-javascript',
						'text/ecmascript',
						'text/x-ecmascript',
						'application/ecmascript'
					]
					if (scriptSrc) {
						try {
							scriptSrc = resolveToUrl(env, scriptSrc, 'script') + ''
							setInstanceStateValue(instance, 4, scriptSrc)
							webWorkerCtx.$config$.logScriptExecution &&
								logWorker(`Execute script src: ${scriptOrgSrc}`, winId)
							rsp = await fetch(scriptSrc)
							if (rsp.ok) {
								let responseContentType = rsp.headers.get('content-type')
								let shouldExecute = javascriptContentTypes.some((ct) => {
									var _a, _b, _c
									return null ===
										(_c =
											null ===
												(_a =
													null == responseContentType ? void 0 : responseContentType.toLowerCase) ||
											void 0 === _a
												? void 0
												: (_b = _a.call(responseContentType)).includes) || void 0 === _c
										? void 0
										: _c.call(_b, ct)
								})
								if (shouldExecute) {
									scriptContent = await rsp.text()
									env.$currentScriptId$ = instanceId
									run(env, scriptContent, scriptOrgSrc || scriptSrc)
								}
								runStateLoadHandlers(instance, 'load')
							} else {
								errorMsg = rsp.statusText
								runStateLoadHandlers(instance, 'error')
							}
						} catch (urlError) {
							console.error(urlError)
							errorMsg = String(urlError.stack || urlError)
							runStateLoadHandlers(instance, 'error')
						}
					} else {
						scriptContent &&
							(errorMsg = runScriptContent(env, instanceId, scriptContent, winId, errorMsg))
					}
					env.$currentScriptId$ = ''
					webWorkerCtx.$postMessage$([6, winId, instanceId, errorMsg])
				})(msgValue)
			} else if (9 === msgType) {
				;(({
					$winId$: $winId$,
					$instanceId$: $instanceId$,
					$refId$: $refId$,
					$thisArg$: $thisArg$,
					$args$: $args$
				}) => {
					if (webWorkerRefsByRefId[$refId$]) {
						try {
							webWorkerRefsByRefId[$refId$].apply(
								deserializeFromMain($winId$, $instanceId$, [], $thisArg$),
								deserializeFromMain($winId$, $instanceId$, [], $args$)
							)
						} catch (e) {
							console.error(e)
						}
					}
				})(msgValue)
			} else if (10 === msgType) {
				;(({ $winId$: $winId$, $forward$: $forward$, $args$: $args$ }) => {
					try {
						let target = environments[$winId$].$window$
						let i = 0
						let l = len($forward$)
						for (; i < l; i++) {
							i + 1 < l
								? (target = target[$forward$[i]])
								: target[$forward$[i]].apply(target, deserializeFromMain(null, $winId$, [], $args$))
						}
					} catch (e) {
						console.error(e)
					}
				})(msgValue)
			} else if (5 === msgType) {
				createEnvironment(msgValue)
			} else if (8 === msgType) {
				if (1 !== environments[msgValue].$isInitialized$) {
					const winId = msgValue
					const env = environments[winId]
					const winType = env.$winId$ === env.$parentWinId$ ? 'top' : 'iframe'
					logWorker(`Initialized ${winType} window ${normalizedWinId(winId)} environment 🎉`, winId)
				}
				environments[msgValue].$isInitialized$ = 1
				environments[msgValue].$isLoading$ = 0
			} else if (14 === msgType) {
				environments[msgValue].$visibilityState$ = msg[2]
			} else if (13 === msgType) {
				const $winId$ = msgValue.$winId$
				const env = environments[$winId$]
				env.$location$.href = msgValue.url
				!(function ($winId$, env, data) {
					const history = env.$window$.history
					switch (data.type) {
						case 0:
							env.$propagateHistoryChange$ = false
							try {
								history.pushState(data.state, '', data.newUrl)
							} catch (e) {}
							env.$propagateHistoryChange$ = true
							break

						case 1:
							env.$propagateHistoryChange$ = false
							try {
								history.replaceState(data.state, '', data.newUrl)
							} catch (e) {}
							env.$propagateHistoryChange$ = true
					}
				})(msgValue.$winId$, env, msgValue)
			} else {
				15 === msgType &&
					((_type, winId, instanceId, callbackName, args) => {
						const elm = getOrCreateNodeInstance(winId, instanceId)
						elm && 'function' == typeof elm[callbackName] && elm[callbackName].apply(elm, args)
					})(...msg)
			}
		} else if (1 === msgType) {
			;((initWebWorkerData) => {
				const config = (webWorkerCtx.$config$ = JSON.parse(initWebWorkerData.$config$))
				const locOrigin = initWebWorkerData.$origin$
				webWorkerCtx.$importScripts$ = importScripts.bind(self)
				webWorkerCtx.$interfaces$ = initWebWorkerData.$interfaces$
				webWorkerCtx.$libPath$ = initWebWorkerData.$libPath$
				webWorkerCtx.$origin$ = locOrigin
				webWorkerCtx.$postMessage$ = postMessage.bind(self)
				webWorkerCtx.$sharedDataBuffer$ = initWebWorkerData.$sharedDataBuffer$
				webWorkerCtx.$tabId$ = initWebWorkerData.$tabId$
				self.importScripts = void 0
				delete self.postMessage
				delete self.WorkerGlobalScope
				commaSplit('resolveUrl,resolveSendBeaconRequestParameters,get,set,apply').map(
					(configName) => {
						config[configName] &&
							(config[configName] = new Function('return ' + config[configName])())
					}
				)
			})(msgValue)
			webWorkerCtx.$postMessage$([2])
		} else if (3 === msgType) {
			webWorkerCtx.$interfaces$ = [...webWorkerCtx.$interfaces$, ...msgValue]
			webWorkerCtx.$isInitialized$ = 1
			logWorker('Initialized web worker')
			webWorkerCtx.$postMessage$([4])
			queuedEvents.length && logWorker(`Queued ready messages: ${queuedEvents.length}`)
			;[...queuedEvents].map(receiveMessageFromSandboxToWorker)
			queuedEvents.length = 0
		} else {
			queuedEvents.push(ev)
		}
	}
	self.onmessage = receiveMessageFromSandboxToWorker
	postMessage([0])
})(self)

================
File: static/~partytown/debug/partytown.js
================
/* Partytown 0.10.2 - MIT builder.io */
const defaultPartytownForwardPropertySettings = {
	preserveBehavior: false
}

const resolvePartytownForwardProperty = (propertyOrPropertyWithSettings) => {
	if ('string' == typeof propertyOrPropertyWithSettings) {
		return [propertyOrPropertyWithSettings, defaultPartytownForwardPropertySettings]
	}
	const [property, settings = defaultPartytownForwardPropertySettings] =
		propertyOrPropertyWithSettings
	return [
		property,
		{
			...defaultPartytownForwardPropertySettings,
			...settings
		}
	]
}

const arrayMethods = Object.freeze(
	((obj) => {
		const properties = new Set()
		let currentObj = obj
		do {
			Object.getOwnPropertyNames(currentObj).forEach((item) => {
				'function' == typeof currentObj[item] && properties.add(item)
			})
		} while ((currentObj = Object.getPrototypeOf(currentObj)) !== Object.prototype)
		return Array.from(properties)
	})([])
)

!(function (
	win,
	doc,
	nav,
	top,
	useAtomics,
	config,
	libPath,
	timeout,
	scripts,
	sandbox,
	mainForwardFn = win,
	isReady
) {
	function ready() {
		if (!isReady) {
			isReady = 1
			libPath = (config.lib || '/~partytown/') + (false !== config.debug ? 'debug/' : '')
			if ('/' == libPath[0]) {
				scripts = doc.querySelectorAll('script[type="text/partytown"]')
				if (top != win) {
					top.dispatchEvent(
						new CustomEvent('pt1', {
							detail: win
						})
					)
				} else {
					timeout = setTimeout(fallback, 1e4)
					doc.addEventListener('pt0', clearFallback)
					useAtomics
						? loadSandbox(1)
						: nav.serviceWorker
							? nav.serviceWorker
									.register(libPath + (config.swPath || 'partytown-sw.js'), {
										scope: libPath
									})
									.then(function (swRegistration) {
										if (swRegistration.active) {
											loadSandbox()
										} else if (swRegistration.installing) {
											swRegistration.installing.addEventListener('statechange', function (ev) {
												'activated' == ev.target.state && loadSandbox()
											})
										} else {
											console.warn(swRegistration)
										}
									}, console.error)
							: fallback()
				}
			} else {
				console.warn('Partytown config.lib url must start with "/"')
			}
		}
	}
	function loadSandbox(isAtomics) {
		sandbox = doc.createElement(isAtomics ? 'script' : 'iframe')
		win._pttab = Date.now()
		if (!isAtomics) {
			sandbox.style.display = 'block'
			sandbox.style.width = '0'
			sandbox.style.height = '0'
			sandbox.style.border = '0'
			sandbox.style.visibility = 'hidden'
			sandbox.setAttribute('aria-hidden', !0)
		}
		sandbox.src =
			libPath + 'partytown-' + (isAtomics ? 'atomics.js?v=0.10.2' : 'sandbox-sw.html?' + win._pttab)
		doc.querySelector(config.sandboxParent || 'body').appendChild(sandbox)
	}
	function fallback(i, script) {
		console.warn('Partytown script fallback')
		clearFallback()
		top == win &&
			(config.forward || []).map(function (forwardProps) {
				const [property] = resolvePartytownForwardProperty(forwardProps)
				delete win[property.split('.')[0]]
			})
		for (i = 0; i < scripts.length; i++) {
			script = doc.createElement('script')
			script.innerHTML = scripts[i].innerHTML
			script.nonce = config.nonce
			doc.head.appendChild(script)
		}
		sandbox && sandbox.parentNode.removeChild(sandbox)
	}
	function clearFallback() {
		clearTimeout(timeout)
	}
	config = win.partytown || {}
	top == win &&
		(config.forward || []).map(function (forwardProps) {
			const [property, { preserveBehavior: preserveBehavior }] =
				resolvePartytownForwardProperty(forwardProps)
			mainForwardFn = win
			property.split('.').map(function (_, i, forwardPropsArr) {
				mainForwardFn = mainForwardFn[forwardPropsArr[i]] =
					i + 1 < forwardPropsArr.length
						? mainForwardFn[forwardPropsArr[i]] ||
							((propertyName) => (arrayMethods.includes(propertyName) ? [] : {}))(
								forwardPropsArr[i + 1]
							)
						: (() => {
								let originalFunction = null
								if (preserveBehavior) {
									const { methodOrProperty: methodOrProperty, thisObject: thisObject } = ((
										window,
										properties
									) => {
										let thisObject = window
										for (let i = 0; i < properties.length - 1; i += 1) {
											thisObject = thisObject[properties[i]]
										}
										return {
											thisObject: thisObject,
											methodOrProperty:
												properties.length > 0
													? thisObject[properties[properties.length - 1]]
													: void 0
										}
									})(win, forwardPropsArr)
									'function' == typeof methodOrProperty &&
										(originalFunction = (...args) => methodOrProperty.apply(thisObject, ...args))
								}
								return function () {
									let returnValue
									originalFunction && (returnValue = originalFunction(arguments))
									;(win._ptf = win._ptf || []).push(forwardPropsArr, arguments)
									return returnValue
								}
							})()
			})
		})
	if ('complete' == doc.readyState) {
		ready()
	} else {
		win.addEventListener('DOMContentLoaded', ready)
		win.addEventListener('load', ready)
	}
})(window, document, navigator, top, window.crossOriginIsolated)

================
File: static/~partytown/partytown-atomics.js
================
/* Partytown 0.10.2 - MIT builder.io */
;((e) => {
	const t = () => {},
		r = (e) => e.length,
		n = (e) => {
			var t, r, n
			try {
				const r =
					null === (t = null == e ? void 0 : e.constructor) || void 0 === t ? void 0 : t.name
				if (r) return r
			} catch (e) {}
			try {
				const t =
					null ===
						(n =
							null === (r = null == e ? void 0 : e.__zone_symbol__originalInstance) || void 0 === r
								? void 0
								: r.constructor) || void 0 === n
						? void 0
						: n.name
				if (t) return t
			} catch (e) {}
			return ''
		},
		i = (e, t) => e.startsWith(t),
		s = (e) =>
			!(i(e, 'webkit') || i(e, 'toJSON') || i(e, 'constructor') || i(e, 'toString') || i(e, '_')),
		o = (e) => (11 === e.nodeType && e.host ? '#s' : e.nodeName),
		a = () => Math.round(Math.random() * Number.MAX_SAFE_INTEGER).toString(36),
		c = {
			Anchor: 'a',
			DList: 'dl',
			Image: 'img',
			OList: 'ol',
			Paragraph: 'p',
			Quote: 'q',
			TableCaption: 'caption',
			TableCell: 'td',
			TableCol: 'colgroup',
			TableRow: 'tr',
			TableSection: 'tbody',
			UList: 'ul'
		},
		l = { Graphics: 'g', SVG: 'svg' },
		u = { preserveBehavior: !1 },
		p = Object.freeze(
			((e) => {
				const t = new Set()
				let r = []
				do {
					Object.getOwnPropertyNames(r).forEach((e) => {
						'function' == typeof r[e] && t.add(e)
					})
				} while ((r = Object.getPrototypeOf(r)) !== Object.prototype)
				return Array.from(t)
			})()
		),
		d = Symbol(),
		h = Symbol(),
		g = new Map(),
		m = new Map(),
		f = {},
		y = new WeakMap(),
		$ = (e, t) => {
			if (e) return (t = y.get(e)) || (t = e[d]) || v(e, (t = a())), t
		},
		w = (e, t, r, n, i) => {
			if ((r = f[e]) && r.U) {
				if (e === t) return r.U
				if (((n = r.U.document), 'd' === (i = t.split('.').pop()))) return n
				if ('e' === i) return n.documentElement
				if ('h' === i) return n.head
				if ('b' === i) return n.body
			}
			return g.get(t)
		},
		v = (e, t, r) => {
			e &&
				(g.set(t, e),
				(e[d] = t),
				(e[h] = r = Date.now()),
				r > b + 5e3 &&
					(g.forEach((e, t) => {
						e[h] < b && e.nodeType && !e.isConnected && g.delete(t)
					}),
					(b = r)))
		}
	let b = 0
	const S = e.parent,
		E = document.implementation.createHTMLDocument(),
		T = S.partytown || {},
		I = (T.lib || '/~partytown/') + '',
		R = (e, t, r) => {
			const n = ((e, t) => {
				return (
					(r = e), (n = { value: t }), Object.defineProperty(r, 'name', { ...n, configurable: !0 })
				)
				var r, n
			})(class extends f[e].U.HTMLElement {}, r[0])
			return (
				'connectedCallback,disconnectedCallback,attributeChangedCallback,adoptedCallback'
					.split(',')
					.map(
						(r) =>
							(n.prototype[r] = function (...n) {
								t.postMessage([15, e, $(this), r, n])
							})
					),
				(n.observedAttributes = r[1]),
				n
			)
		},
		M = (e, t, r, s, a, c) =>
			void 0 !== t && (s = typeof t)
				? 'string' === s || 'number' === s || 'boolean' === s || null == t
					? [0, t]
					: 'function' === s
						? [6]
						: (r = r || new Set()) && Array.isArray(t)
							? r.has(t)
								? [1, []]
								: r.add(t) && [1, t.map((t) => M(e, t, r))]
							: 'object' === s
								? A(t)
									? [14, { name: t.name, message: t.message, stack: t.stack }]
									: '' === (a = n(t))
										? [2, {}]
										: 'Window' === a
											? [3, [e, e]]
											: 'HTMLCollection' === a || 'NodeList' === a
												? [7, Array.from(t).map((t) => M(e, t, r)[1])]
												: a.endsWith('Event')
													? [5, x(e, t, r)]
													: 'CSSRuleList' === a
														? [12, Array.from(t).map(N)]
														: i(a, 'CSS') && a.endsWith('Rule')
															? [11, N(t)]
															: 'CSSStyleDeclaration' === a
																? [13, x(e, t, r)]
																: 'Attr' === a
																	? [10, [t.name, t.value]]
																	: t.nodeType
																		? [3, [e, $(t), o(t), c]]
																		: [2, x(e, t, r, !0, !0)]
								: void 0
				: t,
		x = (e, t, r, i, o, a, c, l) => {
			if (((a = {}), !r.has(t)))
				for (c in (r.add(t), t))
					s(c) &&
						((l = 'path' === c && n(t).endsWith('Event') ? t.composedPath() : t[c]),
						(i || 'function' != typeof l) && (o || '' !== l) && (a[c] = M(e, l, r)))
			return a
		},
		N = (e) => {
			let t,
				r = {}
			for (t in e) U.includes(t) && (r[t] = String(e[t]))
			return r
		}
	let L = null
	const A = (t) => {
			var r
			return (L = (null === (r = e.top) || void 0 === r ? void 0 : r.Error) || L), t instanceof L
		},
		C = (t, r, n, i) =>
			r
				? ((n = r[0]),
					(i = r[1]),
					0 === n
						? i
						: 4 === n
							? O(t, i)
							: 1 === n
								? i.map((e) => C(t, e))
								: 3 === n
									? w(i[0], i[1])
									: 5 === n
										? j(P(t, i))
										: 2 === n
											? P(t, i)
											: 8 === n
												? i
												: 9 === n
													? new e[r[2]](i)
													: void 0)
				: void 0,
		O = (e, { V: t, w: r, L: n }, i) => (
			(i = m.get(n)) ||
				((i = function (...i) {
					e.postMessage([9, { V: t, w: r, L: n, R: M(t, this), b: M(t, i) }])
				}),
				m.set(n, i)),
			i
		),
		j = (e) => new ('detail' in e ? CustomEvent : Event)(e.type, e),
		P = (e, t, r, n) => {
			for (n in ((r = {}), t)) r[n] = C(e, t[n])
			return r
		},
		U = 'cssText,selectorText,href,media,namespaceURI,prefix,name,conditionText'.split(','),
		H = async (e, t) => {
			let n,
				i,
				s,
				o,
				a,
				c,
				l = { F: t.F },
				u = r(t.Q),
				p = 0
			for (; p < u; p++)
				try {
					;(c = p === u - 1),
						(n = t.Q[p]),
						(i = n.V),
						(s = n.a),
						!f[i] &&
							i.startsWith('f_') &&
							(await new Promise((e) => {
								let t = 0,
									r = () => {
										f[i] || t++ > 1e3 ? e() : requestAnimationFrame(r)
									}
								r()
							})),
						1 === s[0] && s[1] in f[i].U
							? v(new f[i].U[s[1]](...C(e, s[2])), n.w)
							: ((o = w(i, n.w)),
								o
									? ((a = _(e, i, o, s, c, n.r)),
										n.d &&
											('string' == typeof n.d
												? v(a, n.d)
												: (f[n.d.V] = { V: n.d.V, U: { document: a } })),
										'object' == typeof (d = a) && d && d.then && ((a = await a), c && (l.z = !0)),
										c && (l.M = M(i, a, void 0, void 0, void 0, n.w)))
									: (l.p = n.w + ' not found'))
				} catch (e) {
					c ? (l.p = String(e.stack || e)) : console.error(e)
				}
			var d
			return l
		},
		_ = (e, t, i, s, o, a) => {
			let c,
				l,
				u,
				p,
				d,
				h = 0,
				g = r(s)
			for (; h < g; h++) {
				;(l = s[h]), (c = s[h + 1]), (u = s[h - 1])
				try {
					if (!Array.isArray(c))
						if ('string' == typeof l || 'number' == typeof l) {
							if (h + 1 === g && a) return (d = {}), a.map((e) => (d[e] = i[e])), d
							i = i[l]
						} else {
							if (0 === c) return void (i[u] = C(e, l))
							if (
								'function' == typeof i[u] &&
								((p = C(e, l)),
								'define' === u && 'CustomElementRegistry' === n(i) && (p[1] = R(t, e, p[1])),
								'insertRule' === u && p[1] > r(i.cssRules) && (p[1] = r(i.cssRules)),
								(i = i[u].apply(i, p)),
								'play' === u)
							)
								return Promise.resolve()
						}
				} catch (e) {
					if (o) throw e
					console.debug(e)
				}
			}
			return i
		},
		B = (e, t) => {
			let n,
				i,
				s,
				o = t.V,
				a = t.U,
				c = a.document,
				l = 'script[type="text/partytown"]:not([data-ptid]):not([data-pterror])',
				d = l + ':not([async]):not([defer])'
			c && c.body
				? ((n = c.querySelector(d)),
					n || (n = c.querySelector(l)),
					n
						? ((n.dataset.ptid = i = $(n, o)),
							(s = { V: o, w: i }),
							n.src ? ((s.S = n.src), (s.H = n.dataset.ptsrc || n.src)) : (s.j = n.innerHTML),
							e.postMessage([7, s]))
						: (t.x ||
								((t.x = 1),
								((e, t, n) => {
									let i,
										s,
										o = n._ptf,
										a = (n.partytown || {}).forward || [],
										c = (r, n) => e.postMessage([10, { V: t, q: r, b: M(t, Array.from(n)) }])
									if (
										((n._ptf = void 0),
										a.map((e) => {
											const [t, { preserveBehavior: i }] = ((e) => {
												if ('string' == typeof e) return [e, u]
												const [t, r = u] = e
												return [t, { ...u, ...r }]
											})(e)
											;(s = n),
												t.split('.').map((e, t, o) => {
													var a
													s = s[o[t]] =
														t + 1 < r(o)
															? s[o[t]] || ((a = o[t + 1]), p.includes(a) ? [] : {})
															: (() => {
																	let e = null
																	if (i) {
																		const { methodOrProperty: t, thisObject: r } = ((e, t) => {
																			let r = e
																			for (let e = 0; e < t.length - 1; e += 1) r = r[t[e]]
																			return {
																				thisObject: r,
																				methodOrProperty: t.length > 0 ? r[t[t.length - 1]] : void 0
																			}
																		})(n, o)
																		'function' == typeof t && (e = (...e) => t.apply(r, ...e))
																	}
																	return (...t) => {
																		let r
																		return e && (r = e(t)), c(o, t), r
																	}
																})()
												})
										}),
										o)
									)
										for (i = 0; i < r(o); i += 2) c(o[i], o[i + 1])
								})(e, o, a),
								c.dispatchEvent(new CustomEvent('pt0'))),
							e.postMessage([8, o])))
				: requestAnimationFrame(() => B(e, t))
		},
		k = (e, t, r) => {
			if (!y.has(r)) {
				y.set(r, t)
				const n = r.document,
					i = r.history,
					s = y.get(r.parent)
				let o = !1
				const a = [],
					c = (e) => {
						o ? e() : a.push(e)
					},
					l = () => {
						e.postMessage([5, { V: t, J: s, S: n.baseURI, T: n.visibilityState }]),
							setTimeout(() => {
								;(o = !0),
									a.forEach((e) => {
										e()
									})
							})
					},
					u = i.pushState.bind(i),
					p = i.replaceState.bind(i),
					d = (r, i, s, o) => () => {
						e.postMessage([13, { V: t, type: r, state: i, url: n.baseURI, newUrl: s, oldUrl: o }])
					}
				;(i.pushState = (e, t, r) => {
					u(e, t, r), c(d(0, e, null == r ? void 0 : r.toString()))
				}),
					(i.replaceState = (e, t, r) => {
						p(e, t, r), c(d(1, e, null == r ? void 0 : r.toString()))
					}),
					r.addEventListener('popstate', (e) => {
						c(d(2, e.state))
					}),
					r.addEventListener('hashchange', (e) => {
						c(d(3, {}, e.newURL, e.oldURL))
					}),
					r.addEventListener('ptupdate', () => {
						B(e, f[t])
					}),
					n.addEventListener('visibilitychange', () => e.postMessage([14, t, n.visibilityState])),
					(f[t] = { V: t, U: r }),
					'complete' === n.readyState ? l() : r.addEventListener('load', l)
			}
		},
		V = () => {
			const e = Object.getOwnPropertyNames(S)
				.map((e) =>
					((e, t, r, n) => {
						if ((r = t.match(/^(HTML|SVG)(.+)Element$/)))
							return (
								(n = r[2]),
								'S' == t[0]
									? e.createElementNS(
											'http://www.w3.org/2000/svg',
											l[n] || n.slice(0, 2).toLowerCase() + n.slice(2)
										)
									: e.createElement(c[n] || n)
							)
					})(E, e)
				)
				.filter((e) => e)
				.map((e) => [e])
			return D(e, [])
		},
		D = (e, t) => {
			const r = new Set(['Object'])
			return (
				e
					.filter((e) => e[0])
					.map((e) => {
						const t = e[0],
							r = e[1],
							i = n(t)
						return [i, S[i].prototype, t, r]
					})
					.map(([e, n, i, s]) => F(r, t, e, n, i, s)),
				t
			)
		},
		W = (e, t, r) => {
			let n = [],
				i = [e, 'Object', n]
			for (r in t) J(n, t, r)
			return i
		},
		F = (e, t, r, i, s, a) => {
			if (!e.has(r)) {
				e.add(r)
				const c = Object.getPrototypeOf(i),
					l = n(c),
					u = [],
					p = Object.getOwnPropertyDescriptors(i)
				F(e, t, l, c, s, a)
				for (const e in p) J(u, s, e)
				t.push([r, l, u, a, o(s)])
			}
		},
		J = (e, t, r, i, o, a) => {
			try {
				s(r) &&
					isNaN(r[0]) &&
					'all' !== r &&
					('function' == (o = typeof (i = t[r]))
						? (String(i).includes('[native') || Object.getPrototypeOf(t)[r]) && e.push([r, 5])
						: 'object' === o && null != i
							? 'Object' !== (a = n(i)) &&
								'Function' !== a &&
								self[a] &&
								e.push([r, i.nodeType || a])
							: 'symbol' !== o && (r.toUpperCase() === r ? e.push([r, 6, i]) : e.push([r, 6])))
			} catch (e) {
				console.warn(e)
			}
		},
		q = (e, r) => (void 0 !== e[r] ? new e[r](t) : 0)
	let G
	;(async (e) => {
		const t = new SharedArrayBuffer(1073741824),
			r = new Int32Array(t)
		return (n, i) => {
			const s = i[0],
				o = i[1]
			if (0 === s) {
				const e = (() => {
					const e = E.createElement('i'),
						t = E.createTextNode(''),
						r = E.createComment(''),
						n = E.createDocumentFragment(),
						i = E.createElement('p').attachShadow({ mode: 'open' }),
						s = q(S, 'IntersectionObserver'),
						o = q(S, 'MutationObserver'),
						a = q(S, 'ResizeObserver'),
						c = S.performance,
						l = S.screen,
						u = [
							[S.history],
							[c],
							[c.navigation],
							[c.timing],
							[l],
							[l.orientation],
							[S.visualViewport],
							[s, 12],
							[o, 12],
							[a, 12],
							[t],
							[r],
							[n],
							[i],
							[e],
							[e.attributes],
							[e.classList],
							[e.dataset],
							[e.style],
							[E],
							[E.doctype]
						],
						p = [W('Window', S), W('Node', t)],
						d = (function (e) {
							return JSON.stringify(
								e,
								(e, t) => (
									'function' == typeof t &&
										(t = String(t)).startsWith(e + '(') &&
										(t = 'function ' + t),
									'loadScriptsOnMainThread' === e &&
										(t = t.map((e) =>
											Array.isArray(e)
												? e
												: [
														'string' == typeof e ? 'string' : 'regexp',
														'string' == typeof e ? e : e.source
													]
										)),
									t
								)
							)
						})(T),
						h = { i: d, v: D(u, p), C: new URL(I, S.location) + '', I: origin, $tabId$: S._pttab }
					return (
						((e, t, r) => {
							void 0 !== t[r] &&
								e.push([r, 'Object', Object.keys(t[r].prototype).map((e) => [e, 6]), 12])
						})(h.v, S, 'IntersectionObserverEntry'),
						h
					)
				})()
				;(e.P = t), n.postMessage([1, e])
			} else
				2 === i[0]
					? n.postMessage([3, V()])
					: 11 === s
						? e(o, (e) => {
								const t = JSON.stringify(e),
									n = t.length
								for (let e = 0; e < n; e++) r[e + 1] = t.charCodeAt(e)
								;(r[0] = n), Atomics.notify(r, 0)
							})
						: ((e, t, r) => {
								4 === t[0]
									? k(e, a(), S)
									: (r = f[t[1]]) &&
										(7 === t[0]
											? requestAnimationFrame(() => B(e, r))
											: 6 === t[0] &&
												((e, t, r, n, i) => {
													;(i = t.U.document.querySelector(`[data-ptid="${r}"]`)) &&
														(n ? (i.dataset.pterror = n) : (i.type += '-x'), delete i.dataset.ptid),
														B(e, t)
												})(e, r, t[2], t[3]))
							})(n, i)
		}
	})((e, t) => H(G, e).then(t)).then((e) => {
		e &&
			((G = new Worker(
				URL.createObjectURL(
					new Blob(
						[
							'/* Partytown 0.10.2 - MIT builder.io */\n(e=>{const t=Symbol(),r=Symbol(),n=Symbol(),i=Symbol(),s=Symbol(),o=Symbol(),a=Symbol(),c=Symbol(),l=new Map,$={},d=new WeakMap,u=[],h={},p={},g=new Map,m=new Map,f="about:blank",w=e=>e.split(","),y=e=>{if(e=h.C+e,new URL(e).origin!=location.origin)throw"Invalid "+e;return e},v=w("clientWidth,clientHeight,clientTop,clientLeft,innerWidth,innerHeight,offsetWidth,offsetHeight,offsetTop,offsetLeft,outerWidth,outerHeight,pageXOffset,pageYOffset,scrollWidth,scrollHeight,scrollTop,scrollLeft"),S=w("childElementCount,children,firstElementChild,lastElementChild,nextElementSibling,previousElementSibling"),b=w("insertBefore,remove,removeChild,replaceChild"),I=w("className,width,height,hidden,innerHTML,innerText,textContent,text"),M=w("setAttribute,setAttributeNS,setProperty"),T=w("addEventListener,dispatchEvent,removeEventListener"),E=T.concat(M,w("add,observe,remove,unobserve")),N=/^[A-Z_]([A-Z0-9-]*[A-Z0-9])?$/,x=()=>{},L=e=>e.length,C=e=>{var t,r,n;try{const r=null===(t=null==e?void 0:e.constructor)||void 0===t?void 0:t.name;if(r)return r}catch(e){}try{const t=null===(n=null===(r=null==e?void 0:e.__zone_symbol__originalInstance)||void 0===r?void 0:r.constructor)||void 0===n?void 0:n.name;if(t)return t}catch(e){}return""},R=[],A=()=>Math.round(Math.random()*Number.MAX_SAFE_INTEGER).toString(36),P="text/partytown",W=(e,t,r)=>Object.defineProperty(e,t,{...r,configurable:!0}),H=(e,t)=>W(e,"name",{value:t}),O=(e,t,r)=>W(e.prototype,t,r),j=(e,t)=>Object.defineProperties(e.prototype,t),k=(e,t,r)=>O(e,t,{value:r,writable:!0});function D(e,t){var r,n;return null!==(n=null===(r=e.loadScriptsOnMainThread)||void 0===r?void 0:r.map((([e,t])=>new RegExp("string"===e?t.replace(/[.*+?^${}()|[\\]\\\\]/g,"\\\\$&"):t))).some((e=>e.test(t))))&&void 0!==n&&n}Object.freeze((e=>{const t=new Set;let r=[];do{Object.getOwnPropertyNames(r).forEach((e=>{"function"==typeof r[e]&&t.add(e)}))}while((r=Object.getPrototypeOf(r))!==Object.prototype);return Array.from(t)})());const U=(e,t)=>t in e[o],_=(e,t)=>e[o][t],B=(e,t,r)=>e[o][t]=r,F=(e,t,r,n,i,s)=>{if(!(i=l.get(t))&&r&&p[e]){const o=l.get(s||"");i=p[e].k(r,t,n,o),l.set(t,i)}return i},z=(e,t)=>k(e,"nodeType",t),q=(e,t)=>t.map((t=>O(e,t,{get(){let e=V(this,t),r=m.get(e);return r||(r=$e(this,[t]),m.set(e,r)),r}}))),V=(e,n,i)=>[e[t],e[r],n,...(i||R).map((e=>String(e&&e[t]?e[r]:e)))].join("."),X=(e,t)=>w(t).map((t=>O(e,t,{get(){return U(this,t)||B(this,t,$e(this,[t])),_(this,t)},set(e){_(this,t)!==e&&de(this,[t],e),B(this,t,e)}}))),Z=e=>v.map((t=>O(e,t,{get(){const e=g.get(V(this,t));if("number"==typeof e)return e;const r=$e(this,[t],v);return r&&"object"==typeof r?(Object.entries(r).map((([e,t])=>g.set(V(this,e),t))),r[t]):r}}))),G=(e,t)=>t.map((t=>{e.prototype[t]=function(...e){let r=V(this,t,e),n=g.get(r);return n||(n=ue(this,[t],e),g.set(r,n)),n}})),J=(e,n,i,s,o)=>{return void 0!==i&&(o=typeof i)?"string"===o||"boolean"===o||"number"===o||null==i?[0,i]:"function"===o?[4,{V:e,w:n,L:(a=i,(c=d.get(a))||(d.set(a,c=A()),$[c]=a),c)}]:(s=s||new Set)&&Array.isArray(i)?s.has(i)?[1,[]]:s.add(i)&&[1,i.map((t=>J(e,n,t,s)))]:"object"===o?i[r]?[3,[i[t],i[r]]]:i instanceof Event?[5,K(e,n,i,!1,s)]:Y&&i instanceof TrustedHTML?[0,i.toString()]:i instanceof ArrayBuffer?[8,i]:ArrayBuffer.isView(i)?[9,i.buffer,C(i)]:[2,K(e,n,i,!0,s)]:void 0:i;var a,c},Y="undefined"!=typeof TrustedHTML,K=(e,t,r,n,i,s,o,a)=>{if(s={},!i.has(r))for(o in i.add(r),r)a=r[o],(n||"function"!=typeof a)&&(s[o]=J(e,t,a,i));return s},Q=(e,n)=>e?J(e[t],e[r],n):[0,n],ee=(e,t,r,n,i,s,o,a)=>{if(n){if(i=n[0],s=n[1],0===i||11===i||12===i)return s;if(4===i)return re(r,s);if(6===i)return e&&r.length>0?(...t)=>ue(p[e].U,r,t,1):x;if(3===i)return te(s);if(7===i)return new ie(s.map(te));if(10===i)return new se(s);if(1===i)return s.map((n=>ee(e,t,r,n)));if(14===i)return new ne(s);for(a in o={},s)o[a]=ee(e,t,[...r,a],s[a]);if(13===i)return new p[e].U.CSSStyleDeclaration(e,t,r,o);if(5===i){if("message"===o.type&&o.origin){let e,t=JSON.stringify(o.data),r=u.find((e=>e.m===t));r&&(e=p[r.V],e&&(o.source=e.U,o.origin=e.E.origin))}return new Proxy(new Event(o.type,o),{get:(e,t)=>t in o?o[t]:"function"==typeof e[String(t)]?x:e[String(t)]})}if(2===i)return o}},te=([e,t,r,n])=>t===e&&p[e]?p[e].U:F(e,t,r,void 0,void 0,n),re=(e,{V:t,w:r,G:n,L:i})=>($[i]||d.set($[i]=function(...i){const s=F(t,r,n);return ue(s,e,i)},i),$[i]);class ne extends Error{constructor(e){super(e.message),this.name=e.name,this.message=e.message,this.stack=e.stack}}class ie{constructor(e){(this._=e).map(((e,t)=>this[t]=e))}entries(){return this._.entries()}forEach(e,t){this._.map(e,t)}item(e){return this[e]}keys(){return this._.keys()}get length(){return L(this._)}values(){return this._.values()}[Symbol.iterator](){return this._[Symbol.iterator]()}}const se=class{constructor(e){this.name=e[0],this.value=e[1]}get nodeName(){return this.name}get nodeType(){return 2}},oe=(e,t,r)=>console.warn(`Partytown unable to ${e} cross-origin ${t}: `+r.E),ae=[],ce=(e,n,i,o,a,c)=>{if(e[s]){if(ae.push({V:e[t],w:e[r],a:[...e[s],...n],d:o,r:a}),3===i)h.K([12,{F:A(),Q:[...ae]}],c?[c instanceof ArrayBuffer?c:c.buffer]:void 0),ae.length=0;else if(1===i)return le(!0);h.c=setTimeout(le,20)}},le=e=>{if(clearTimeout(h.c),L(ae)){const t=ae[L(ae)-1],r={F:`${A()}.${h.$tabId$}`,Q:[...ae]};if(ae.length=0,e){const e=((e,t)=>{const r=e.P,n=new Int32Array(r);Atomics.store(n,0,0),e.K([11,t]),Atomics.wait(n,0,0);let i=Atomics.load(n,0),s="",o=0;for(;o<i;o++)s+=String.fromCharCode(n[o+1]);return JSON.parse(s)})(h,r),n=e.z,i=ee(t.V,t.w,t.a,e.M);if(e.p){if(n)return Promise.reject(e.p);throw new Error(e.p)}return n?Promise.resolve(i):i}h.K([12,r])}},$e=(e,t,r,n)=>h.i.get&&(n=h.i.get(pe(e,t)))!==a?n:n=ce(e,t,1,void 0,r),de=(e,t,r,n)=>{if(h.i.set){if((n=h.i.set({value:r,prevent:c,...pe(e,t)}))===c)return;n!==a&&(r=n)}I.some((e=>t.includes(e)))&&(g.clear(),t[t.length-1]),t=[...t,Q(e,r),0],ce(e,t,2)},ue=(e,t,r,n,i,s,o,c)=>h.i.apply&&(o=h.i.apply({args:r,...pe(e,t)}))!==a?o:(c=t[L(t)-1],t=[...t,Q(e,r)],n=n||(E.includes(c)?2:1),"setAttribute"===c&&U(e,r[0])?B(e,r[0],r[1]):b.includes(c)?(g.clear(),m.clear()):M.includes(c)&&(n=2,g.clear()),o=ce(e,t,n,i,void 0,s)),he=(e,t,r)=>{ce(e,[1,t,Q(e,r)],1)},pe=(e,r)=>({name:r.join("."),continue:a,nodeName:e[n],constructor:C(e),instance:e,window:p[e[t]].U}),ge=(e,t,r,n)=>{let i={getItem(i){if(r)return ue(e,[t,"getItem"],[i],1);oe("get",t,n)},setItem(i,s){r?ue(e,[t,"setItem"],[i,s],1):oe("set",t,n)},removeItem(i){r?ue(e,[t,"removeItem"],[i],1):oe("remove",t,n)},key(i){if(r)return ue(e,[t,"key"],[i],1);oe("key",t,n)},clear(){r?ue(e,[t,"clear"],R,1):oe("clear",t,n)},get length(){if(r)return $e(e,[t,"length"]);oe("length",t,n)}};e[t]=new Proxy(i,{get:(e,t)=>Reflect.has(e,t)?Reflect.get(e,t):e.getItem(t),set:(e,t,r)=>(e.setItem(t,r),!0),has:(e,t)=>!!Reflect.has(e,t)||"string"==typeof t&&null!==e.getItem(t),deleteProperty:(e,t)=>(e.removeItem(t),!0)})},me=(e,t,r)=>{e[r]=H(class extends t{constructor(e,t,r,i){return super(e,t,r,i||{}),new Proxy(this,{get:(e,t)=>e[t]?e[t]:(e[t]||"string"!=typeof t||e[n][t]||(e[n][t]=$e(e,[t])),e[n][t]),set:(e,t,r)=>(e[n][t]=r,de(e,[t],r),g.clear(),!0)})}setProperty(...e){this[n][e[0]]=e[1],ue(this,["setProperty"],e,2),e[0],g.clear()}getPropertyValue(e){return this[e]}removeProperty(e){let t=this[n][e];return ue(this,["removeProperty"],[e],2),g.clear(),this[n][e]=void 0,t}},r)},fe=(e,t)=>{e[t]=H(class{constructor(e){this.ownerNode=e}get cssRules(){const e=this.ownerNode;return new Proxy({},{get(t,r){const n=String(r);return"item"===n?t=>ye(e,t):"length"===n?we(e).length:isNaN(n)?t[r]:ye(e,n)}})}insertRule(e,t){const r=we(this.ownerNode);return(t=void 0===t?0:t)>=0&&t<=r.length&&(ue(this.ownerNode,["sheet","insertRule"],[e,t],2),r.splice(t,0,0)),this.ownerNode,g.clear(),t}deleteRule(e){ue(this.ownerNode,["sheet","deleteRule"],[e],2),we(this.ownerNode).splice(e,1),this.ownerNode,g.clear()}get type(){return"text/css"}},t);const r={sheet:{get(){return new e[t](this)}}};j(e.HTMLStyleElement,r)},we=(e,t)=>((t=_(e,2))||(t=$e(e,["sheet","cssRules"]),B(e,2,t)),t),ye=(e,t,r)=>(0===(r=we(e))[t]&&(r[t]=$e(e,["sheet","cssRules",parseInt(t,10)])),r[t]),ve="0.10.2",Se=(e,t,r,n,i)=>{try{e.l=t,be(e,r)}catch(e){console.error(r,e),i=String(e.stack||e)}return e.l="",i},be=(e,t,r)=>{e.N=1;let n=((e,t)=>e.replace(/([a-zA-Z0-9_$\\.\\\'\\"\\`])?(\\.\\.\\.)?this(?![a-zA-Z0-9_$:])/g,((e,t,r)=>{const n=(t||"")+(r||"");return null!=t?n+"this":n+"(thi$(this)?window:this)"})))(t);t=`with(this){${n.replace(/\\/\\/# so/g,"//Xso")}\\n;function thi$(t){return t===this}};${(h.i.globalFns||[]).filter((e=>/[a-zA-Z_$][0-9a-zA-Z_$]*/.test(e))).map((e=>`(typeof ${e}==\'function\'&&(this.${e}=${e}))`)).join(";")};`+(r?"\\n//# sourceURL="+r:""),e.A||(t=t.replace(/.postMessage\\(/g,`.postMessage(\'${e.V}\',`)),new Function(t).call(e.U),e.N=0},Ie=(e,t,r)=>{(r=_(e,t))&&setTimeout((()=>r.map((e=>e({type:t})))))},Me=(e,t)=>{for(t=e.E;!t.host&&(t=(e=p[e.J]).E,e.V!==e.J););return t},Te=(e,t,r,n,i,s)=>(n=Me(e,n),i=new URL(t||"",n),r&&h.i.resolveUrl&&(s=h.i.resolveUrl(i,n,r))?s:i),Ee=(e,t,r)=>Te(e,t,r)+"",Ne=(e,t)=>{const r=Me(e),n=new URL(t||"",r);if(h.i.resolveSendBeaconRequestParameters){const e=h.i.resolveSendBeaconRequestParameters(n,r);if(e)return e}return{}},xe=()=>`<script src="${y("partytown.js?v="+ve)}"><\\/script>`,Le=e=>class{constructor(){this.s="",this.l=[],this.e=[],this.style={}}get src(){return this.s}set src(t){this.s=t,fetch(Ee(e,t,"image"),{mode:"no-cors",credentials:"include",keepalive:!0}).then((e=>{e.ok||0===e.status?this.l.map((e=>e({type:"load"}))):this.e.map((e=>e({type:"error"})))}),(()=>this.e.forEach((e=>e({type:"error"})))))}addEventListener(e,t){"load"===e&&this.l.push(t),"error"===e&&this.e.push(t)}removeEventListener(e,t){"load"===e&&(this.l=this.l.filter((e=>e!==t))),"error"===e&&(this.e=this.e.filter((e=>e!==t)))}get onload(){return this.l[0]}set onload(e){this.l=[e]}get onerror(){return this.e[0]}set onerror(e){this.e=[e]}},Ce={addEventListener:{value(...e){const t=e[0],r=_(this,t)||[];r.push(e[1]),B(this,t,r)}},async:{get:x,set:x},defer:{get:x,set:x},onload:{get(){let e=_(this,"load");return e&&e[0]||null},set(e){B(this,"load",e?[e]:null)}},onerror:{get(){let e=_(this,"error");return e&&e[0]||null},set(e){B(this,"error",e?[e]:null)}},getAttribute:{value(e){return"src"===e?this.src:ue(this,["getAttribute"],[e])}},setAttribute:{value(e,t){Re.includes(e)?this[e]=t:ue(this,["setAttribute"],[e,t])}}},Re=w("src,type"),Ae=(e,t)=>{const r={innerHTML:Pe,innerText:Pe,src:{get(){return _(this,4)||""},set(e){const r=Ee(t,e,null),n=h.i;e=Ee(t,e,"script"),B(this,4,e),de(this,["src"],e),r!==e&&de(this,["dataset","ptsrc"],r),this.type&&D(n,e)&&de(this,["type"],"text/javascript")}},text:Pe,textContent:Pe,type:{get(){return $e(this,["type"])},set(e){We(e)||(B(this,5,e),de(this,["type"],e))}},...Ce};j(e,r)},Pe={get(){const e=$e(this,["type"]);if(We(e)){const e=_(this,3);if(e)return e}return $e(this,["innerHTML"])||""},set(e){B(this,3,e)}},We=e=>!e||"text/javascript"===e,He=(e,i,s)=>{const o=h.i,a=H(class extends s{appendChild(e){return this.insertBefore(e,null)}get href(){}set href(e){}insertBefore(e,s){const a=e[t]=this[t],c=e[r],l=e[n],$="SCRIPT"===l,d="IFRAME"===l;if($){const t=_(e,3),r=_(e,5);if(t){if(We(r)){const r=e.id;if(r&&D(o,r))de(e,["type"],"text/javascript");else{const r=Se(i,c,t,0,""),n=r?"pterror":"ptid",s=r||c;de(e,["type"],P+"-x"),de(e,["dataset",n],s)}}de(e,["innerHTML"],t)}}if(ue(this,["insertBefore"],[e,s],2),d){const t=_(e,0);if(t&&t.startsWith("javascript:")){const e=t.split("javascript:")[1];Se(i,c,e,0,"")}((e,t)=>{let r,n,i=0,s=()=>{p[e]&&p[e].x&&!p[e].y?(r=_(t,1)?"error":"load",n=_(t,r),n&&n.map((e=>e({type:r})))):i++>2e3?(n=_(t,"error"),n&&n.map((e=>e({type:"error"})))):setTimeout(s,9)};s()})(c,e)}return $&&(le(!0),h.K([7,a])),e}get nodeName(){return"#s"===this[n]?"#document-fragment":this[n]}get nodeType(){return 3}get ownerDocument(){return i.n}},"Node");q(a,w("childNodes,firstChild,isConnected,lastChild,nextSibling,parentElement,parentNode,previousSibling")),e.Node=a},Oe=w("AUDIO,CANVAS,VIDEO"),je=w("Audio,MediaSource"),ke=(e,r,n)=>{j(e,{body:{get:()=>r.e},cookie:{get(){return r.A?$e(this,["cookie"]):(oe("get","cookie",r),"")},set(e){r.A&&de(this,["cookie"],e)}},createElement:{value(e){if(e=e.toUpperCase(),!N.test(e))throw e+" not valid";const r="IFRAME"===e,n=this[t],i=(r?"f_":"")+A();ue(this,["createElement"],[e],2,i);const s=F(n,i,e);if(r)Qe({V:i,J:n,S:f},!0).U.fetch=fetch,de(s,["srcdoc"],xe());else if("SCRIPT"===e){const e=_(s,5);We(e)&&de(s,["type"],P)}return s}},createElementNS:{value(e,r){const n=A(),i=F(this[t],n,r,e);return ue(this,["createElementNS"],[e,r],2,n),i}},createTextNode:{value(e){const r=this[t],n=A(),i=F(r,n,"#text");return ue(this,["createTextNode"],[e],2,n),i}},createEvent:{value:e=>new Event(e)},currentScript:{get(){return r.l?F(this[t],r.l,"SCRIPT"):null}},defaultView:{get:()=>n?null:r.U},documentElement:{get:()=>r.o},getElementsByTagName:{value(e){return"BODY"===(e=e.toUpperCase())?[r.e]:"HEAD"===e?[r.s]:ue(this,["getElementsByTagName"],[e])}},head:{get:()=>r.s},images:{get(){return $e(this,["images"])}},scripts:{get(){return $e(this,["scripts"])}},implementation:{get(){return{hasFeature:()=>!0,createHTMLDocument:e=>{const t=A();return ue(this,["implementation","createHTMLDocument"],[e],1,{V:t}),Qe({V:t,J:t,S:r.E+"",T:"hidden"},!0,!0).n}}}},location:{get:()=>r.E,set(e){r.E.href=e+""}},nodeType:{value:9},parentNode:{value:null},parentElement:{value:null},readyState:{value:"complete"},visibilityState:{get:()=>r.T||"visible"}}),X(e,"compatMode,referrer,forms")},De=(e,t)=>{j(e,{parentElement:{get(){return this.parentNode}},parentNode:{get:()=>t.o}})},Ue=(e,t)=>{j(e,{localName:{get(){return this[n].toLowerCase()}},namespaceURI:{get(){return this[i]||"http://www.w3.org/1999/xhtml"}},nodeType:{value:1},tagName:{get(){return this[n]}}}),q(e,S),X(e,"id"),Z(t),G(t,w("getClientRects,getBoundingClientRect"))},_e=(e,t)=>{const r={};w("hash,host,hostname,href,origin,pathname,port,protocol,search").map((e=>{r[e]={get(){let r,n=_(this,4);if("string"!=typeof n){if(r=$e(this,["href"]),""===r)return"protocol"===e?":":"";B(this,4,r),n=new URL(r)[e]}return Te(t,n,null)[e]},set(r){let n;if("href"===e)if((e=>{try{return new URL(e),!0}catch(e){return!1}})(r))n=new URL(r);else{const e=t.E.href;n=Te(t,e,null),n.href=new URL(r+"",n.href)}else n=Te(t,this.href,null),n[e]=r;B(this,4,n.href),de(this,["href"],n.href)}}})),j(e,r)},Be=(e,t)=>{const r={contentDocument:{get(){return Ve(this).n}},contentWindow:{get(){return Ve(this).U}},src:{get(){let e=_(this,0);return e&&e.startsWith("javascript:")?e:(e=Ve(this).E.href,e.startsWith("about:")?"":e)},set(e){if(e)if(e.startsWith("javascript:"))B(this,0,e);else if(!e.startsWith("about:")){let t,r=new XMLHttpRequest,n=Ve(this);n.E.href=e=Ee(n,e,"iframe"),n.y=1,B(this,1,void 0),r.open("GET",e,!1),r.send(),t=r.status,t>199&&t<300?(de(this,["srcdoc"],`<base href="${e}">`+r.responseText.replace(ze,((e,t)=>{const r=[];let n,i=!1;for(;n=qe.exec(t);){let[e]=n;e.startsWith("type=")&&(i=!0,e=e.replace(/(application|text)\\/javascript/,P)),r.push(e)}return i||r.push(\'type="\'+P+\'"\'),`<script ${r.join(" ")}>`}))+xe()),le(!0),h.K([7,n.V])):(B(this,1,t),n.y=0)}}},...Ce};j(e,r)},Fe="((?:\\\\w|-)+(?:=(?:(?:\\\\w|-)+|\'[^\']*\'|\\"[^\\"]*\\")?)?)",ze=new RegExp(`<script\\\\s*((${Fe}\\\\s*)*)>`,"mg"),qe=new RegExp(Fe,"mg"),Ve=e=>{const n=e[r];return p[n]||Qe({V:n,J:e[t],S:$e(e,["src"])||f},!0),p[n]},Xe=e=>{const t=(e,t)=>{const{a:r,b:n,c:i,d:s,e:o,f:a}=ue(e,[t],R);return new DOMMatrixReadOnly([r,n,i,s,o,a])},r={...e,getCTM:{value:function(){return t(this,"getCTM")}},getScreenCTM:{value:function(){return t(this,"getScreenCTM")}}};j(e,r)},Ze=(e,t)=>{e.NamedNodeMap=H(class extends t{constructor(e,t,r){return super(e,t,r),new Proxy(this,{get(e,t){const r=Je[t];return r?r.bind(e,[t]):$e(e,[t])},set(e,t,r){if(Je[t])throw new Error("Can\'t set read-only property: "+String(t));return de(e,[t],r),!0}})}},"NamedNodeMap")};function Ge(e,...t){return ue(this,e,t,1)}const Je={getNamedItem:Ge,getNamedItemNS:Ge,item:Ge,removeNamedItem:Ge,removeNamedItemNS:Ge,setNamedItem:Ge,setNamedItemNS:Ge},Ye=(a,c,l,$,d,g)=>{let m,v,b,I;const M=class{constructor(e,c,l,$,d){this[t]=e||a,this[r]=c||m||A(),this[s]=l||[],this[n]=$||v,this[i]=d||b,this[o]=I&&I[o]||{},m=v=b=void 0}},E=new(H(class extends URL{assign(){}reload(){}replace(){}},"Location"))(l),N=E.origin===h.I||E.origin===f,x=c===a,R={},P=()=>{let e,t,r=[];for(e in p)t=p[e],t.J!==a||t.B||r.push(t);return r},D=H(class extends M{constructor(){super(a,a),this.addEventListener=(...e)=>{"load"===e[0]?R.N&&setTimeout((()=>e[1]({type:"load"}))):ue(this,["addEventListener"],e,2)};let n,i,o=this,l=0,u=()=>{l||((h.u||(e.g=[$e,de,ue,he,j,A,t,r,s],h.t(y("partytown-media.js?v="+ve)),h.u=e.f,delete e.f),h.u)(M,J,R,o,je),l=1)},p={},f=(e,t,r,n)=>{Oe.includes(e)&&u();const i=p[e]?p[e]:e.includes("-")?p.UNKNOWN:p.I;return m=t,v=e,b=r,I=n,new i};var T,L;if(o.Window=D,o.name=name+a,He(o,R,M),(e=>{e.NodeList=H(ie,"NodeList")})(o),Ze(o,M),me(o,M,"CSSStyleDeclaration"),((e,t,r)=>{e[r]=H(class extends t{now(){return performance.now()}},r)})(o,M,"Performance"),((e,t)=>{const r="customElements",n=new Map;e[r]={define(i,s,o){n.set(i,s),t[i.toUpperCase()]=s;const a=[s.name,s.observedAttributes];ue(e,[r,"define"],[i,a,o])},get:t=>n.get(t)||ue(e,[r,"get"],[t]),whenDefined:t=>n.has(t)?Promise.resolve():ue(e,[r,"whenDefined"],[t]),upgrade:t=>ue(e,[r,"upgrade"],[t])}})(o,p),h.v.map((([e,t,n,i,c])=>{const l=Ke[e]?V:"EventTarget"===t?J:"Object"===t?M:o[t],$=o[e]=H(12===i?class extends M{constructor(...t){super(),he(this,e,t)}}:o[e]||class extends l{},e);c&&(p[c]=$),n.map((([e,t,n])=>{e in $.prototype||e in l.prototype||("string"==typeof t?O($,e,{get(){if(!U(this,e)){const n=this[r],i=[...this[s],e],c=o[t];c&&B(this,e,new c(a,n,i))}return _(this,e)},set(t){B(this,e,t)}}):5===t?k($,e,(function(...t){return ue(this,[e],t)})):t>0&&(void 0!==n?k($,e,n):O($,e,{get(){return $e(this,[e])},set(t){return de(this,[e],t)}})))}))})),w("atob,btoa,crypto,indexedDB,setTimeout,setInterval,clearTimeout,clearInterval").map((t=>{delete D.prototype[t],t in o||(n=e[t],null!=n&&(o[t]="function"!=typeof n||n.toString().startsWith("class")?n:n.bind(e)))})),Object.getOwnPropertyNames(e).map((t=>{t in o||(o[t]=e[t])})),je.map((e=>W(o,e,{get:()=>(u(),o[e])}))),"trustedTypes"in e&&(o.trustedTypes=e.trustedTypes),Ue(o.Element,o.HTMLElement),ke(o.Document,R,g),T=o.DocumentFragment,z(T,11),q(T,S),_e(o.HTMLAnchorElement,R),L=o.HTMLFormElement,j(L,{}),X(L,"elements"),Be(o.HTMLIFrameElement),Ae(o.HTMLScriptElement,R),Xe(o.SVGGraphicsElement),De(o.HTMLHeadElement,R),De(o.HTMLBodyElement,R),((e,t)=>{j(e,{parentElement:{value:null},parentNode:{get:()=>t.n}})})(o.HTMLHtmlElement,R),fe(o,"CSSStyleSheet"),z(o.Comment,8),z(o.DocumentType,10),Object.assign(R,{V:a,J:c,U:new Proxy(o,{get:(e,t)=>{var r;if("string"!=typeof t||isNaN(t))return(null===(r=h.i.mainWindowAccessors)||void 0===r?void 0:r.includes(t))?$e(this,[t]):e[t];{let e=P()[t];return e?e.U:void 0}},has:()=>!0}),n:f("#document",a+".d"),o:f("HTML",a+".e"),s:f("HEAD",a+".h"),e:f("BODY",a+".b"),E:E,T:$,A:N,B:x,k:f}),o.requestAnimationFrame=e=>setTimeout((()=>e(performance.now())),9),o.cancelAnimationFrame=e=>clearTimeout(e),o.requestIdleCallback=(e,t)=>(t=Date.now(),setTimeout((()=>e({didTimeout:!1,timeRemaining:()=>Math.max(0,50-(Date.now()-t))})),1)),o.cancelIdleCallback=e=>clearTimeout(e),ge(o,"localStorage",N,R),ge(o,"sessionStorage",N,R),N||(o.indexeddb=void 0),d)i={},o.history={pushState(e){i=e},replaceState(e){i=e},get state(){return i},length:0},o.indexeddb=void 0;else{const e=o.history.pushState.bind(o.history),t=o.history.replaceState.bind(o.history);o.history.pushState=(t,r,n)=>{!1!==R.$propagateHistoryChange$&&e(t,r,n)},o.history.replaceState=(e,r,n)=>{!1!==R.$propagateHistoryChange$&&t(e,r,n)}}o.Worker=void 0}get body(){return R.e}get document(){return R.n}get documentElement(){return R.o}fetch(e,t){return e="string"==typeof e||e instanceof URL?String(e):e.url,fetch(Ee(R,e,"fetch"),t)}get frames(){return R.U}get frameElement(){return x?null:F(c,a,"IFRAME")}get globalThis(){return R.U}get head(){return R.s}get length(){return P().length}get location(){return E}set location(e){E.href=e+""}get Image(){return Le(R)}get navigator(){return(e=>{const t={sendBeacon:(t,r)=>{try{return fetch(Ee(e,t,null),{method:"POST",body:r,mode:"no-cors",keepalive:!0,...Ne(e,t)}),!0}catch(e){return console.error(e),!1}}};for(let e in navigator)t[e]=navigator[e];return new Proxy(t,{set:(e,t,r)=>(navigator[t]=r,!0),get:(t,r)=>Object.prototype.hasOwnProperty.call(t,r)?t[r]:$e(e.U,["navigator",r])})})(R)}get origin(){return E.origin}set origin(e){}get parent(){for(let e in p)if(p[e].V===c)return p[e].U;return R.U}postMessage(...e){p[e[0]]&&(L(u)>50&&u.splice(0,5),u.push({V:e[0],m:JSON.stringify(e[1])}),e=e.slice(1)),ue(this,["postMessage"],e,3)}get self(){return R.U}get top(){for(let e in p)if(p[e].B)return p[e].U;return R.U}get window(){return R.U}get XMLHttpRequest(){const e=XMLHttpRequest,t=String(e),r=H(class extends e{open(...e){e[1]=Ee(R,e[1],"xhr"),super.open(...e)}set withCredentials(e){h.i.allowXhrCredentials&&(super.withCredentials=e)}toString(){return t}},C(e));return r.prototype.constructor.toString=()=>t,r}},"Window"),V=class extends M{constructor(e,t,r,n){return super(e,t,r,n),new Proxy(this,{get:(e,t)=>$e(e,[t]),set:(e,t,r)=>(de(e,[t],r),!0)})}},J=class extends M{};return T.map((e=>J.prototype[e]=function(...t){return ue(this,[e],t,2)})),X(D,"devicePixelRatio"),Z(D),G(D,["getComputedStyle"]),new D,R},Ke={DOMStringMap:1,NamedNodeMap:1},Qe=({V:e,J:t,S:r,T:n},i,s)=>(p[e]||(p[e]=Ye(e,t,r,n,i,s)),h.K([7,e]),p[e]),et=[],tt=t=>{const r=t.data,n=r[0],i=r[1];if(h.x)if(7===n)(async e=>{let t,r=e.V,n=e.w,i=F(r,n,"SCRIPT"),s=e.j,o=e.S,a=e.H,c="",l=p[r],$=["text/jscript","text/javascript","text/x-javascript","application/javascript","application/x-javascript","text/ecmascript","text/x-ecmascript","application/ecmascript"];if(o)try{if(o=Te(l,o,"script")+"",B(i,4,o),t=await fetch(o),t.ok){let e=t.headers.get("content-type");$.some((t=>{var r,n,i;return null===(i=null===(r=null==e?void 0:e.toLowerCase)||void 0===r?void 0:(n=r.call(e)).includes)||void 0===i?void 0:i.call(n,t)}))&&(s=await t.text(),l.l=n,be(l,s,a||o)),Ie(i,"load")}else c=t.statusText,Ie(i,"error")}catch(e){console.error(e),c=String(e.stack||e),Ie(i,"error")}else s&&(c=Se(l,n,s,0,c));l.l="",h.K([6,r,n,c])})(i);else if(9===n)(({V:e,w:t,L:r,R:n,b:i})=>{if($[r])try{$[r].apply(ee(e,t,[],n),ee(e,t,[],i))}catch(e){console.error(e)}})(i);else if(10===n)(({V:e,q:t,b:r})=>{try{let n=p[e].U,i=0,s=L(t);for(;i<s;i++)i+1<s?n=n[t[i]]:n[t[i]].apply(n,ee(null,e,[],r))}catch(e){console.error(e)}})(i);else if(5===n)Qe(i);else if(8===n)p[i].x=1,p[i].y=0;else if(14===n)p[i].T=r[2];else if(13===n){const e=i.V,t=p[e];t.E.href=i.url,function(e,t,r){const n=t.U.history;switch(r.type){case 0:t.$propagateHistoryChange$=!1;try{n.pushState(r.state,"",r.newUrl)}catch(e){}t.$propagateHistoryChange$=!0;break;case 1:t.$propagateHistoryChange$=!1;try{n.replaceState(r.state,"",r.newUrl)}catch(e){}t.$propagateHistoryChange$=!0}}(i.V,t,i)}else 15===n&&((e,t,r,n,i)=>{const s=F(t,r);s&&"function"==typeof s[n]&&s[n].apply(s,i)})(...r);else 1===n?((t=>{const r=h.i=JSON.parse(t.i),n=t.I;h.t=importScripts.bind(e),h.v=t.v,h.C=t.C,h.I=n,h.K=postMessage.bind(e),h.P=t.P,h.$tabId$=t.$tabId$,e.importScripts=void 0,delete e.postMessage,delete e.WorkerGlobalScope,w("resolveUrl,resolveSendBeaconRequestParameters,get,set,apply").map((e=>{r[e]&&(r[e]=new Function("return "+r[e])())}))})(i),h.K([2])):3===n?(h.v=[...h.v,...i],h.x=1,h.K([4]),[...et].map(tt),et.length=0):et.push(t)};e.onmessage=tt,postMessage([0])})(self);\n'
						],
						{ type: 'text/javascript' }
					)
				),
				{ name: 'Partytown 🎉' }
			)),
			(G.onmessage = (t) => {
				const r = t.data
				12 === r[0] ? H(G, r[1]) : e(G, r)
			}),
			S.addEventListener('pt1', (e) => k(G, $(e.detail.frameElement), e.detail)))
	})
})(window)

================
File: static/~partytown/partytown-media.js
================
/* Partytown 0.10.2 - MIT builder.io */
;((e) => {
	const [t, s, n, r, i, a, o, d, u] = e.g
	delete e.g
	const c = Symbol(),
		h = Symbol(),
		f = Symbol(),
		p = Symbol(),
		g = Symbol(),
		l = Symbol(),
		m = [],
		v = (e, t, s) => (e[t] = S(t, s)),
		S = (e, t) => Object.defineProperty(t, 'name', { value: e }),
		b = (e, t) => {
			const r = {
					getContext: {
						value(e, t) {
							return this[c] || (this[c] = (e.includes('webgl') ? g : p)(this, e, t)), this[c]
						}
					}
				},
				h = v(
					t,
					'CanvasGradient',
					class extends e {
						addColorStop(...e) {
							n(this, ['addColorStop'], e, 2)
						}
					}
				),
				f = v(
					t,
					'CanvasPattern',
					class extends e {
						setTransform(...e) {
							n(this, ['setTransform'], e, 2)
						}
					}
				),
				p = (e, t, r) => {
					const i = e[o],
						c = a(),
						f = { [o]: i, [d]: c, [u]: [] },
						p = n(e, ['getContext'], [t, r], 1, c),
						g =
							'getContextAttributes,getImageData,getLineDash,getTransform,isPointInPath,isPointInStroke,measureText'.split(
								','
							),
						l = {
							get: (e, t) =>
								'string' == typeof t && t in p
									? 'function' == typeof p[t]
										? (...e) => {
												if (t.startsWith('create')) {
													const r = a()
													return (
														n(f, [t], e, 2, r),
														'createImageData' === t || 'createPattern' === t
															? ((s = `${t}()`),
																console.warn(`${s} not implemented`),
																{ setTransform: () => {} })
															: new h(i, r)
													)
												}
												var s
												const r = g.includes(t) ? 1 : 2
												return n(f, [t], e, r)
											}
										: p[t]
									: e[t],
							set: (e, t, n) => (
								'string' == typeof t && t in p
									? (p[t] !== n && 'function' != typeof n && s(f, [t], n), (p[t] = n))
									: (e[t] = n),
								!0
							)
						}
					return new Proxy(p, l)
				},
				g = (e, t, r) => {
					const i = e[o],
						c = a(),
						h = { [o]: i, [d]: c, [u]: [] },
						f = n(e, ['getContext'], [t, r], 1, c),
						p = {
							get: (e, t) =>
								'string' == typeof t
									? 'function' != typeof f[t]
										? f[t]
										: (...e) => n(h, [t], e, m(t))
									: e[t],
							set: (e, t, n) => (
								'string' == typeof t && t in f
									? (f[t] !== n && 'function' != typeof n && s(h, [t], n), (f[t] = n))
									: (e[t] = n),
								!0
							)
						}
					return new Proxy(f, p)
				},
				l = 'checkFramebufferStatus,makeXRCompatible'.split(','),
				m = (e) =>
					e.startsWith('create') || e.startsWith('get') || e.startsWith('is') || l.includes(e)
						? 1
						: 2
			v(t, 'CanvasGradient', h), v(t, 'CanvasPattern', f), i(t.HTMLCanvasElement, r)
		},
		y = (e, u, c, b) => {
			var y, T
			b.Audio = S(
				'HTMLAudioElement',
				class {
					constructor(e) {
						const t = c.k('audio', a())
						return (t.src = e), t
					}
				}
			)
			const w = class extends e {
					get enabled() {
						return t(this, ['enabled'])
					}
					set enabled(e) {
						s(this, ['enabled'], e)
					}
					get id() {
						return t(this, ['id'])
					}
					get kind() {
						return t(this, ['kind'])
					}
					get label() {
						return t(this, ['label'])
					}
					get language() {
						return t(this, ['language'])
					}
					get sourceBuffer() {
						return new x(this)
					}
				},
				E = class {
					constructor(e) {
						const s = 'audioTracks',
							r = e[o],
							i = e[d]
						return new Proxy(
							{
								addEventListener(...t) {
									n(e, [s, 'addEventListener'], t, 3)
								},
								getTrackById: (...t) => n(e, [s, 'getTrackById'], t),
								get length() {
									return t(e, [s, 'length'])
								},
								removeEventListener(...t) {
									n(e, [s, 'removeEventListener'], t, 3)
								}
							},
							{ get: (e, t) => ('number' == typeof t ? new w(r, i, [s, t]) : e[t]) }
						)
					}
				},
				k = v(
					b,
					'SourceBufferList',
					class extends Array {
						constructor(e) {
							super(), (this[h] = e)
						}
						addEventListener(...e) {
							n(this[h], ['sourceBuffers', 'addEventListener'], e, 3)
						}
						removeEventListener(...e) {
							n(this[h], ['sourceBuffers', 'removeEventListener'], e, 3)
						}
					}
				),
				x = v(
					b,
					'SourceBuffer',
					((T = class extends u {
						constructor(e) {
							super(e[o], e[d], ['sourceBuffers']), (this[y] = []), (this[h] = e)
						}
						abort() {
							const e = R(this)
							n(this, [e, 'appendWindowStart'], m, 1)
						}
						addEventListener(...e) {
							const t = R(this)
							n(this, [t, 'addEventListener'], e, 3)
						}
						appendBuffer(e) {
							this[g].push(['appendBuffer', [e], e]), M(this)
						}
						get appendWindowStart() {
							const e = R(this)
							return t(this, [e, 'appendWindowStart'])
						}
						set appendWindowStart(e) {
							const t = R(this)
							s(this, [t, 'appendWindowStart'], e)
						}
						get appendWindowEnd() {
							const e = R(this)
							return t(this, [e, 'appendWindowEnd'])
						}
						set appendWindowEnd(e) {
							const t = R(this)
							s(this, [t, 'appendWindowEnd'], e)
						}
						get buffered() {
							const e = this[h],
								t = R(this)
							return new B(e[o], e[d], ['sourceBuffers', t, 'buffered'])
						}
						changeType(e) {
							const t = R(this)
							n(this, [t, 'changeType'], [e], 2)
						}
						get mode() {
							const e = R(this)
							return t(this, [e, 'mode'])
						}
						set mode(e) {
							const t = R(this)
							s(this, [t, 'mode'], e)
						}
						remove(e, t) {
							this[g].push(['remove', [e, t]]), M(this)
						}
						removeEventListener(...e) {
							const t = R(this)
							n(this, [t, 'removeEventListener'], e, 3)
						}
						get timestampOffset() {
							const e = R(this)
							return t(this, [e, 'timestampOffset'])
						}
						set timestampOffset(e) {
							const t = R(this)
							s(this, [t, 'timestampOffset'], e)
						}
						get updating() {
							const e = R(this)
							return t(this, [e, 'updating'])
						}
					}),
					(y = g),
					T)
				),
				B = v(
					b,
					'TimeRanges',
					class extends e {
						start(...e) {
							return n(this, ['start'], e)
						}
						end(...e) {
							return n(this, ['end'], e)
						}
						get length() {
							return t(this, ['length'])
						}
					}
				),
				R = (e) => (e ? e[h][p].indexOf(e) : -1),
				M = (e) => {
					if (e[g].length) {
						if (!e.updating) {
							const t = e[g].shift()
							if (t) {
								const s = R(e)
								n(e, [s, t[0]], t[1], 3, void 0, t[2])
							}
						}
						setTimeout(() => M(e), 50)
					}
				},
				W = {
					buffered: {
						get() {
							return (
								this[l] ||
									((this[l] = new B(this[o], this[d], ['buffered'])),
									setTimeout(() => {
										this[l] = void 0
									}, 5e3)),
								this[l]
							)
						}
					},
					readyState: {
						get() {
							return 4 === this[f]
								? 4
								: ('number' != typeof this[f] &&
										((this[f] = t(this, ['readyState'])),
										setTimeout(() => {
											this[f] = void 0
										}, 1e3)),
									this[f])
						}
					}
				}
			v(
				b,
				'MediaSource',
				class extends u {
					constructor() {
						super(c.V), (this[p] = new k(this)), r(this, 'MediaSource', m)
					}
					get activeSourceBuffers() {
						return []
					}
					addSourceBuffer(e) {
						const t = new x(this)
						return this[p].push(t), n(this, ['addSourceBuffer'], [e]), t
					}
					clearLiveSeekableRange() {
						n(this, ['clearLiveSeekableRange'], m, 2)
					}
					get duration() {
						return t(this, ['duration'])
					}
					set duration(e) {
						s(this, ['duration'], e)
					}
					endOfStream(e) {
						n(this, ['endOfStream'], [e], 3)
					}
					get readyState() {
						return t(this, ['readyState'])
					}
					removeSourceBuffer(e) {
						const t = R(e)
						t > -1 && (this[p].splice(t, 1), n(this, ['removeSourceBuffer'], [t], 1))
					}
					setLiveSeekableRange(e, t) {
						n(this, ['setLiveSeekableRange'], [e, t], 2)
					}
					get sourceBuffers() {
						return this[p]
					}
					static isTypeSupported(e) {
						if (!L.has(e)) {
							const t = n(b, ['MediaSource', 'isTypeSupported'], [e])
							L.set(e, t)
						}
						return L.get(e)
					}
				}
			)
			const C = (b.URL = S('URL', class extends URL {}))
			'audioTracks' in b.HTMLMediaElement.prototype &&
				(v(b, 'AudioTrackList', E),
				v(b, 'AudioTrack', w),
				(W.audioTracks = {
					get() {
						return new E(this)
					}
				})),
				i(b.HTMLMediaElement, W),
				(C.createObjectURL = (e) => n(b, ['URL', 'createObjectURL'], [e])),
				(C.revokeObjectURL = (e) => n(b, ['URL', 'revokeObjectURL'], [e]))
		},
		L = new Map()
	e.f = (e, t, s, n, r) => {
		r.map((e) => {
			delete n[e]
		}),
			b(e, n),
			y(e, t, s, n)
	}
})(self)

================
File: static/~partytown/partytown-sw.js
================
/* Partytown 0.10.2 - MIT builder.io */
Object.freeze(
	((e) => {
		const t = new Set()
		let r = []
		do {
			Object.getOwnPropertyNames(r).forEach((e) => {
				'function' == typeof r[e] && t.add(e)
			})
		} while ((r = Object.getPrototypeOf(r)) !== Object.prototype)
		return Array.from(t)
	})()
)
const e = new Map(),
	t = (e, t) => ({ F: e.F, p: t }),
	r = (e, t) =>
		new Response(e, { headers: { 'content-type': t || 'text/html', 'Cache-Control': 'no-store' } })
;(self.oninstall = () => self.skipWaiting()),
	(self.onactivate = () => self.clients.claim()),
	(self.onmessage = (t) => {
		const r = t.data,
			n = e.get(r.F)
		n && (e.delete(r.F), clearTimeout(n[1]), n[0](r))
	}),
	(self.onfetch = (n) => {
		const i = n.request,
			s = new URL(i.url).pathname
		s.endsWith('sw.html')
			? n.respondWith(
					r(
						'<!DOCTYPE html><html><head><meta charset="utf-8"><script type="module">/* Partytown 0.10.2 - MIT builder.io */\n(e=>{const t=()=>{},r=e=>e.length,n=e=>{var t,r,n;try{const r=null===(t=null==e?void 0:e.constructor)||void 0===t?void 0:t.name;if(r)return r}catch(e){}try{const t=null===(n=null===(r=null==e?void 0:e.__zone_symbol__originalInstance)||void 0===r?void 0:r.constructor)||void 0===n?void 0:n.name;if(t)return t}catch(e){}return""},i=(e,t)=>e.startsWith(t),s=e=>!(i(e,"webkit")||i(e,"toJSON")||i(e,"constructor")||i(e,"toString")||i(e,"_")),o=e=>11===e.nodeType&&e.host?"#s":e.nodeName,a=()=>Math.round(Math.random()*Number.MAX_SAFE_INTEGER).toString(36),c={Anchor:"a",DList:"dl",Image:"img",OList:"ol",Paragraph:"p",Quote:"q",TableCaption:"caption",TableCell:"td",TableCol:"colgroup",TableRow:"tr",TableSection:"tbody",UList:"ul"},l={Graphics:"g",SVG:"svg"},u={preserveBehavior:!1},p=Object.freeze((e=>{const t=new Set;let r=[];do{Object.getOwnPropertyNames(r).forEach((e=>{"function"==typeof r[e]&&t.add(e)}))}while((r=Object.getPrototypeOf(r))!==Object.prototype);return Array.from(t)})()),d=Symbol(),h=Symbol(),g=new Map,m=new Map,f={},y=new WeakMap,$=(e,t)=>{if(e)return(t=y.get(e))||(t=e[d])||w(e,t=a()),t},v=(e,t,r,n,i)=>{if((r=f[e])&&r.U){if(e===t)return r.U;if(n=r.U.document,"d"===(i=t.split(".").pop()))return n;if("e"===i)return n.documentElement;if("h"===i)return n.head;if("b"===i)return n.body}return g.get(t)},w=(e,t,r)=>{e&&(g.set(t,e),e[d]=t,e[h]=r=Date.now(),r>b+5e3&&(g.forEach(((e,t)=>{e[h]<b&&e.nodeType&&!e.isConnected&&g.delete(t)})),b=r))};let b=0;const S=e.parent,E=document.implementation.createHTMLDocument(),T=S.partytown||{},C=(T.lib||"/~partytown/")+"",I=(e,t,r)=>{const n=((e,t)=>{return r=e,n={value:t},Object.defineProperty(r,"name",{...n,configurable:!0});var r,n})(class extends f[e].U.HTMLElement{},r[0]);return"connectedCallback,disconnectedCallback,attributeChangedCallback,adoptedCallback".split(",").map((r=>n.prototype[r]=function(...n){t.postMessage([15,e,$(this),r,n])})),n.observedAttributes=r[1],n},M=(e,t,r,s,a,c)=>void 0!==t&&(s=typeof t)?"string"===s||"number"===s||"boolean"===s||null==t?[0,t]:"function"===s?[6]:(r=r||new Set)&&Array.isArray(t)?r.has(t)?[1,[]]:r.add(t)&&[1,t.map((t=>M(e,t,r)))]:"object"===s?O(t)?[14,{name:t.name,message:t.message,stack:t.stack}]:""===(a=n(t))?[2,{}]:"Window"===a?[3,[e,e]]:"HTMLCollection"===a||"NodeList"===a?[7,Array.from(t).map((t=>M(e,t,r)[1]))]:a.endsWith("Event")?[5,x(e,t,r)]:"CSSRuleList"===a?[12,Array.from(t).map(N)]:i(a,"CSS")&&a.endsWith("Rule")?[11,N(t)]:"CSSStyleDeclaration"===a?[13,x(e,t,r)]:"Attr"===a?[10,[t.name,t.value]]:t.nodeType?[3,[e,$(t),o(t),c]]:[2,x(e,t,r,!0,!0)]:void 0:t,x=(e,t,r,i,o,a,c,l)=>{if(a={},!r.has(t))for(c in r.add(t),t)s(c)&&(l="path"===c&&n(t).endsWith("Event")?t.composedPath():t[c],(i||"function"!=typeof l)&&(o||""!==l)&&(a[c]=M(e,l,r)));return a},N=e=>{let t,r={};for(t in e)U.includes(t)&&(r[t]=String(e[t]));return r};let L=null;const O=t=>{var r;return L=(null===(r=e.top)||void 0===r?void 0:r.Error)||L,t instanceof L},j=(t,r,n,i)=>r?(n=r[0],i=r[1],0===n?i:4===n?R(t,i):1===n?i.map((e=>j(t,e))):3===n?v(i[0],i[1]):5===n?A(P(t,i)):2===n?P(t,i):8===n?i:9===n?new e[r[2]](i):void 0):void 0,R=(e,{V:t,w:r,L:n},i)=>((i=m.get(n))||(i=function(...i){e.postMessage([9,{V:t,w:r,L:n,R:M(t,this),b:M(t,i)}])},m.set(n,i)),i),A=e=>new("detail"in e?CustomEvent:Event)(e.type,e),P=(e,t,r,n)=>{for(n in r={},t)r[n]=j(e,t[n]);return r},U="cssText,selectorText,href,media,namespaceURI,prefix,name,conditionText".split(","),H=async(e,t)=>{let n,i,s,o,a,c,l={F:t.F},u=r(t.Q),p=0;for(;p<u;p++)try{c=p===u-1,n=t.Q[p],i=n.V,s=n.a,!f[i]&&i.startsWith("f_")&&await new Promise((e=>{let t=0,r=()=>{f[i]||t++>1e3?e():requestAnimationFrame(r)};r()})),1===s[0]&&s[1]in f[i].U?w(new f[i].U[s[1]](...j(e,s[2])),n.w):(o=v(i,n.w),o?(a=_(e,i,o,s,c,n.r),n.d&&("string"==typeof n.d?w(a,n.d):f[n.d.V]={V:n.d.V,U:{document:a}}),"object"==typeof(d=a)&&d&&d.then&&(a=await a,c&&(l.z=!0)),c&&(l.M=M(i,a,void 0,void 0,void 0,n.w))):l.p=n.w+" not found")}catch(e){c?l.p=String(e.stack||e):console.error(e)}var d;return l},_=(e,t,i,s,o,a)=>{let c,l,u,p,d,h=0,g=r(s);for(;h<g;h++){l=s[h],c=s[h+1],u=s[h-1];try{if(!Array.isArray(c))if("string"==typeof l||"number"==typeof l){if(h+1===g&&a)return d={},a.map((e=>d[e]=i[e])),d;i=i[l]}else{if(0===c)return void(i[u]=j(e,l));if("function"==typeof i[u]&&(p=j(e,l),"define"===u&&"CustomElementRegistry"===n(i)&&(p[1]=I(t,e,p[1])),"insertRule"===u&&p[1]>r(i.cssRules)&&(p[1]=r(i.cssRules)),i=i[u].apply(i,p),"play"===u))return Promise.resolve()}}catch(e){if(o)throw e;console.debug(e)}}return i},k=(e,t)=>{let n,i,s,o=t.V,a=t.U,c=a.document,l=\'script[type="text/partytown"]:not([data-ptid]):not([data-pterror])\',d=l+":not([async]):not([defer])";c&&c.body?(n=c.querySelector(d),n||(n=c.querySelector(l)),n?(n.dataset.ptid=i=$(n,o),s={V:o,w:i},n.src?(s.S=n.src,s.H=n.dataset.ptsrc||n.src):s.j=n.innerHTML,e.postMessage([7,s])):(t.x||(t.x=1,((e,t,n)=>{let i,s,o=n._ptf,a=(n.partytown||{}).forward||[],c=(r,n)=>e.postMessage([10,{V:t,q:r,b:M(t,Array.from(n))}]);if(n._ptf=void 0,a.map((e=>{const[t,{preserveBehavior:i}]=(e=>{if("string"==typeof e)return[e,u];const[t,r=u]=e;return[t,{...u,...r}]})(e);s=n,t.split(".").map(((e,t,o)=>{var a;s=s[o[t]]=t+1<r(o)?s[o[t]]||(a=o[t+1],p.includes(a)?[]:{}):(()=>{let e=null;if(i){const{methodOrProperty:t,thisObject:r}=((e,t)=>{let r=e;for(let e=0;e<t.length-1;e+=1)r=r[t[e]];return{thisObject:r,methodOrProperty:t.length>0?r[t[t.length-1]]:void 0}})(n,o);"function"==typeof t&&(e=(...e)=>t.apply(r,...e))}return(...t)=>{let r;return e&&(r=e(t)),c(o,t),r}})()}))})),o)for(i=0;i<r(o);i+=2)c(o[i],o[i+1])})(e,o,a),c.dispatchEvent(new CustomEvent("pt0"))),e.postMessage([8,o]))):requestAnimationFrame((()=>k(e,t)))},B=(e,t,r)=>{if(!y.has(r)){y.set(r,t);const n=r.document,i=r.history,s=y.get(r.parent);let o=!1;const a=[],c=e=>{o?e():a.push(e)},l=()=>{e.postMessage([5,{V:t,J:s,S:n.baseURI,T:n.visibilityState}]),setTimeout((()=>{o=!0,a.forEach((e=>{e()}))}))},u=i.pushState.bind(i),p=i.replaceState.bind(i),d=(r,i,s,o)=>()=>{e.postMessage([13,{V:t,type:r,state:i,url:n.baseURI,newUrl:s,oldUrl:o}])};i.pushState=(e,t,r)=>{u(e,t,r),c(d(0,e,null==r?void 0:r.toString()))},i.replaceState=(e,t,r)=>{p(e,t,r),c(d(1,e,null==r?void 0:r.toString()))},r.addEventListener("popstate",(e=>{c(d(2,e.state))})),r.addEventListener("hashchange",(e=>{c(d(3,{},e.newURL,e.oldURL))})),r.addEventListener("ptupdate",(()=>{k(e,f[t])})),n.addEventListener("visibilitychange",(()=>e.postMessage([14,t,n.visibilityState]))),f[t]={V:t,U:r},"complete"===n.readyState?l():r.addEventListener("load",l)}},V=()=>{const e=E.createElement("i"),t=E.createTextNode(""),r=E.createComment(""),n=E.createDocumentFragment(),i=E.createElement("p").attachShadow({mode:"open"}),s=G(S,"IntersectionObserver"),o=G(S,"MutationObserver"),a=G(S,"ResizeObserver"),c=S.performance,l=S.screen,u=[[S.history],[c],[c.navigation],[c.timing],[l],[l.orientation],[S.visualViewport],[s,12],[o,12],[a,12],[t],[r],[n],[i],[e],[e.attributes],[e.classList],[e.dataset],[e.style],[E],[E.doctype]],p=[F("Window",S),F("Node",t)],d=function(e){return JSON.stringify(e,((e,t)=>("function"==typeof t&&(t=String(t)).startsWith(e+"(")&&(t="function "+t),"loadScriptsOnMainThread"===e&&(t=t.map((e=>Array.isArray(e)?e:["string"==typeof e?"string":"regexp","string"==typeof e?e:e.source]))),t)))}(T),h={i:d,v:W(u,p),C:new URL(C,S.location)+"",I:origin,$tabId$:S._pttab};return z(h.v,S,"IntersectionObserverEntry"),h},D=()=>{const e=Object.getOwnPropertyNames(S).map((e=>((e,t,r,n)=>{if(r=t.match(/^(HTML|SVG)(.+)Element$/))return n=r[2],"S"==t[0]?e.createElementNS("http://www.w3.org/2000/svg",l[n]||n.slice(0,2).toLowerCase()+n.slice(2)):e.createElement(c[n]||n)})(E,e))).filter((e=>e)).map((e=>[e]));return W(e,[])},W=(e,t)=>{const r=new Set(["Object"]);return e.filter((e=>e[0])).map((e=>{const t=e[0],r=e[1],i=n(t);return[i,S[i].prototype,t,r]})).map((([e,n,i,s])=>J(r,t,e,n,i,s))),t},F=(e,t,r)=>{let n=[],i=[e,"Object",n];for(r in t)q(n,t,r);return i},J=(e,t,r,i,s,a)=>{if(!e.has(r)){e.add(r);const c=Object.getPrototypeOf(i),l=n(c),u=[],p=Object.getOwnPropertyDescriptors(i);J(e,t,l,c,s,a);for(const e in p)q(u,s,e);t.push([r,l,u,a,o(s)])}},q=(e,t,r,i,o,a)=>{try{s(r)&&isNaN(r[0])&&"all"!==r&&("function"==(o=typeof(i=t[r]))?(String(i).includes("[native")||Object.getPrototypeOf(t)[r])&&e.push([r,5]):"object"===o&&null!=i?"Object"!==(a=n(i))&&"Function"!==a&&self[a]&&e.push([r,i.nodeType||a]):"symbol"!==o&&(r.toUpperCase()===r?e.push([r,6,i]):e.push([r,6])))}catch(e){console.warn(e)}},G=(e,r)=>void 0!==e[r]?new e[r](t):0,z=(e,t,r)=>{void 0!==t[r]&&e.push([r,"Object",Object.keys(t[r].prototype).map((e=>[e,6])),12])};let X;(t=>{const r=e.navigator.serviceWorker;return r.getRegistration().then((e=>(r.addEventListener("message",(t=>{return r=t.data,n=t=>e.active&&e.active.postMessage(t),H(X,r).then(n);var r,n})),(e,t)=>{0===t[0]?e.postMessage([1,V()]):2===t[0]?e.postMessage([3,D()]):((e,t,r)=>{4===t[0]?B(e,a(),S):(r=f[t[1]])&&(7===t[0]?requestAnimationFrame((()=>k(e,r))):6===t[0]&&((e,t,r,n,i)=>{(i=t.U.document.querySelector(`[data-ptid="${r}"]`))&&(n?i.dataset.pterror=n:i.type+="-x",delete i.dataset.ptid),k(e,t)})(e,r,t[2],t[3]))})(e,t)})))})().then((e=>{e&&(X=new Worker(URL.createObjectURL(new Blob([\'/* Partytown 0.10.2 - MIT builder.io */\\n(e=>{const t=Symbol(),r=Symbol(),n=Symbol(),i=Symbol(),s=Symbol(),o=Symbol(),a=Symbol(),c=Symbol(),l=new Map,$={},d=new WeakMap,u=[],h={},p={},g=new Map,m=new Map,f="about:blank",w=e=>e.split(","),y=e=>{if(e=h.C+e,new URL(e).origin!=location.origin)throw"Invalid "+e;return e},v=w("clientWidth,clientHeight,clientTop,clientLeft,innerWidth,innerHeight,offsetWidth,offsetHeight,offsetTop,offsetLeft,outerWidth,outerHeight,pageXOffset,pageYOffset,scrollWidth,scrollHeight,scrollTop,scrollLeft"),S=w("childElementCount,children,firstElementChild,lastElementChild,nextElementSibling,previousElementSibling"),b=w("insertBefore,remove,removeChild,replaceChild"),I=w("className,width,height,hidden,innerHTML,innerText,textContent,text"),T=w("setAttribute,setAttributeNS,setProperty"),M=w("addEventListener,dispatchEvent,removeEventListener"),E=M.concat(T,w("add,observe,remove,unobserve")),N=/^[A-Z_]([A-Z0-9-]*[A-Z0-9])?$/,x=()=>{},L=e=>e.length,R=e=>{var t,r,n;try{const r=null===(t=null==e?void 0:e.constructor)||void 0===t?void 0:t.name;if(r)return r}catch(e){}try{const t=null===(n=null===(r=null==e?void 0:e.__zone_symbol__originalInstance)||void 0===r?void 0:r.constructor)||void 0===n?void 0:n.name;if(t)return t}catch(e){}return""},C=[],P=()=>Math.round(Math.random()*Number.MAX_SAFE_INTEGER).toString(36),O="text/partytown",A=(e,t,r)=>Object.defineProperty(e,t,{...r,configurable:!0}),H=(e,t)=>A(e,"name",{value:t}),W=(e,t,r)=>A(e.prototype,t,r),j=(e,t)=>Object.defineProperties(e.prototype,t),k=(e,t,r)=>W(e,t,{value:r,writable:!0});function D(e,t){var r,n;return null!==(n=null===(r=e.loadScriptsOnMainThread)||void 0===r?void 0:r.map((([e,t])=>new RegExp("string"===e?t.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g,"\\\\\\\\$&"):t))).some((e=>e.test(t))))&&void 0!==n&&n}Object.freeze((e=>{const t=new Set;let r=[];do{Object.getOwnPropertyNames(r).forEach((e=>{"function"==typeof r[e]&&t.add(e)}))}while((r=Object.getPrototypeOf(r))!==Object.prototype);return Array.from(t)})());const U=(e,t)=>t in e[o],_=(e,t)=>e[o][t],B=(e,t,r)=>e[o][t]=r,F=(e,t,r,n,i,s)=>{if(!(i=l.get(t))&&r&&p[e]){const o=l.get(s||"");i=p[e].k(r,t,n,o),l.set(t,i)}return i},z=(e,t)=>k(e,"nodeType",t),q=(e,t)=>t.map((t=>W(e,t,{get(){let e=V(this,t),r=m.get(e);return r||(r=$e(this,[t]),m.set(e,r)),r}}))),V=(e,n,i)=>[e[t],e[r],n,...(i||C).map((e=>String(e&&e[t]?e[r]:e)))].join("."),X=(e,t)=>w(t).map((t=>W(e,t,{get(){return U(this,t)||B(this,t,$e(this,[t])),_(this,t)},set(e){_(this,t)!==e&&de(this,[t],e),B(this,t,e)}}))),Z=e=>v.map((t=>W(e,t,{get(){const e=g.get(V(this,t));if("number"==typeof e)return e;const r=$e(this,[t],v);return r&&"object"==typeof r?(Object.entries(r).map((([e,t])=>g.set(V(this,e),t))),r[t]):r}}))),G=(e,t)=>t.map((t=>{e.prototype[t]=function(...e){let r=V(this,t,e),n=g.get(r);return n||(n=ue(this,[t],e),g.set(r,n)),n}})),J=(e,n,i,s,o)=>{return void 0!==i&&(o=typeof i)?"string"===o||"boolean"===o||"number"===o||null==i?[0,i]:"function"===o?[4,{V:e,w:n,L:(a=i,(c=d.get(a))||(d.set(a,c=P()),$[c]=a),c)}]:(s=s||new Set)&&Array.isArray(i)?s.has(i)?[1,[]]:s.add(i)&&[1,i.map((t=>J(e,n,t,s)))]:"object"===o?i[r]?[3,[i[t],i[r]]]:i instanceof Event?[5,K(e,n,i,!1,s)]:Y&&i instanceof TrustedHTML?[0,i.toString()]:i instanceof ArrayBuffer?[8,i]:ArrayBuffer.isView(i)?[9,i.buffer,R(i)]:[2,K(e,n,i,!0,s)]:void 0:i;var a,c},Y="undefined"!=typeof TrustedHTML,K=(e,t,r,n,i,s,o,a)=>{if(s={},!i.has(r))for(o in i.add(r),r)a=r[o],(n||"function"!=typeof a)&&(s[o]=J(e,t,a,i));return s},Q=(e,n)=>e?J(e[t],e[r],n):[0,n],ee=(e,t,r,n,i,s,o,a)=>{if(n){if(i=n[0],s=n[1],0===i||11===i||12===i)return s;if(4===i)return re(r,s);if(6===i)return e&&r.length>0?(...t)=>ue(p[e].U,r,t,1):x;if(3===i)return te(s);if(7===i)return new ie(s.map(te));if(10===i)return new se(s);if(1===i)return s.map((n=>ee(e,t,r,n)));if(14===i)return new ne(s);for(a in o={},s)o[a]=ee(e,t,[...r,a],s[a]);if(13===i)return new p[e].U.CSSStyleDeclaration(e,t,r,o);if(5===i){if("message"===o.type&&o.origin){let e,t=JSON.stringify(o.data),r=u.find((e=>e.m===t));r&&(e=p[r.V],e&&(o.source=e.U,o.origin=e.E.origin))}return new Proxy(new Event(o.type,o),{get:(e,t)=>t in o?o[t]:"function"==typeof e[String(t)]?x:e[String(t)]})}if(2===i)return o}},te=([e,t,r,n])=>t===e&&p[e]?p[e].U:F(e,t,r,void 0,void 0,n),re=(e,{V:t,w:r,G:n,L:i})=>($[i]||d.set($[i]=function(...i){const s=F(t,r,n);return ue(s,e,i)},i),$[i]);class ne extends Error{constructor(e){super(e.message),this.name=e.name,this.message=e.message,this.stack=e.stack}}class ie{constructor(e){(this._=e).map(((e,t)=>this[t]=e))}entries(){return this._.entries()}forEach(e,t){this._.map(e,t)}item(e){return this[e]}keys(){return this._.keys()}get length(){return L(this._)}values(){return this._.values()}[Symbol.iterator](){return this._[Symbol.iterator]()}}const se=class{constructor(e){this.name=e[0],this.value=e[1]}get nodeName(){return this.name}get nodeType(){return 2}},oe=(e,t,r)=>console.warn(`Partytown unable to ${e} cross-origin ${t}: `+r.E),ae=[],ce=(e,n,i,o,a,c)=>{if(e[s]){if(ae.push({V:e[t],w:e[r],a:[...e[s],...n],d:o,r:a}),3===i)h.K([12,{F:P(),Q:[...ae]}],c?[c instanceof ArrayBuffer?c:c.buffer]:void 0),ae.length=0;else if(1===i)return le(!0);h.c=setTimeout(le,20)}},le=e=>{if(clearTimeout(h.c),L(ae)){const t=ae[L(ae)-1],r={F:`${P()}.${h.$tabId$}`,Q:[...ae]};if(ae.length=0,e){const e=((e,t)=>{const r=new XMLHttpRequest;return r.open("POST",y("proxytown"),!1),r.send(JSON.stringify(t)),JSON.parse(r.responseText)})(0,r),n=e.z,i=ee(t.V,t.w,t.a,e.M);if(e.p){if(n)return Promise.reject(e.p);throw new Error(e.p)}return n?Promise.resolve(i):i}h.K([12,r])}},$e=(e,t,r,n)=>h.i.get&&(n=h.i.get(pe(e,t)))!==a?n:n=ce(e,t,1,void 0,r),de=(e,t,r,n)=>{if(h.i.set){if((n=h.i.set({value:r,prevent:c,...pe(e,t)}))===c)return;n!==a&&(r=n)}I.some((e=>t.includes(e)))&&(g.clear(),t[t.length-1]),t=[...t,Q(e,r),0],ce(e,t,2)},ue=(e,t,r,n,i,s,o,c)=>h.i.apply&&(o=h.i.apply({args:r,...pe(e,t)}))!==a?o:(c=t[L(t)-1],t=[...t,Q(e,r)],n=n||(E.includes(c)?2:1),"setAttribute"===c&&U(e,r[0])?B(e,r[0],r[1]):b.includes(c)?(g.clear(),m.clear()):T.includes(c)&&(n=2,g.clear()),o=ce(e,t,n,i,void 0,s)),he=(e,t,r)=>{ce(e,[1,t,Q(e,r)],1)},pe=(e,r)=>({name:r.join("."),continue:a,nodeName:e[n],constructor:R(e),instance:e,window:p[e[t]].U}),ge=(e,t,r,n)=>{let i={getItem(i){if(r)return ue(e,[t,"getItem"],[i],1);oe("get",t,n)},setItem(i,s){r?ue(e,[t,"setItem"],[i,s],1):oe("set",t,n)},removeItem(i){r?ue(e,[t,"removeItem"],[i],1):oe("remove",t,n)},key(i){if(r)return ue(e,[t,"key"],[i],1);oe("key",t,n)},clear(){r?ue(e,[t,"clear"],C,1):oe("clear",t,n)},get length(){if(r)return $e(e,[t,"length"]);oe("length",t,n)}};e[t]=new Proxy(i,{get:(e,t)=>Reflect.has(e,t)?Reflect.get(e,t):e.getItem(t),set:(e,t,r)=>(e.setItem(t,r),!0),has:(e,t)=>!!Reflect.has(e,t)||"string"==typeof t&&null!==e.getItem(t),deleteProperty:(e,t)=>(e.removeItem(t),!0)})},me=(e,t,r)=>{e[r]=H(class extends t{constructor(e,t,r,i){return super(e,t,r,i||{}),new Proxy(this,{get:(e,t)=>e[t]?e[t]:(e[t]||"string"!=typeof t||e[n][t]||(e[n][t]=$e(e,[t])),e[n][t]),set:(e,t,r)=>(e[n][t]=r,de(e,[t],r),g.clear(),!0)})}setProperty(...e){this[n][e[0]]=e[1],ue(this,["setProperty"],e,2),e[0],g.clear()}getPropertyValue(e){return this[e]}removeProperty(e){let t=this[n][e];return ue(this,["removeProperty"],[e],2),g.clear(),this[n][e]=void 0,t}},r)},fe=(e,t)=>{e[t]=H(class{constructor(e){this.ownerNode=e}get cssRules(){const e=this.ownerNode;return new Proxy({},{get(t,r){const n=String(r);return"item"===n?t=>ye(e,t):"length"===n?we(e).length:isNaN(n)?t[r]:ye(e,n)}})}insertRule(e,t){const r=we(this.ownerNode);return(t=void 0===t?0:t)>=0&&t<=r.length&&(ue(this.ownerNode,["sheet","insertRule"],[e,t],2),r.splice(t,0,0)),this.ownerNode,g.clear(),t}deleteRule(e){ue(this.ownerNode,["sheet","deleteRule"],[e],2),we(this.ownerNode).splice(e,1),this.ownerNode,g.clear()}get type(){return"text/css"}},t);const r={sheet:{get(){return new e[t](this)}}};j(e.HTMLStyleElement,r)},we=(e,t)=>((t=_(e,2))||(t=$e(e,["sheet","cssRules"]),B(e,2,t)),t),ye=(e,t,r)=>(0===(r=we(e))[t]&&(r[t]=$e(e,["sheet","cssRules",parseInt(t,10)])),r[t]),ve="0.10.2",Se=(e,t,r,n,i)=>{try{e.l=t,be(e,r)}catch(e){console.error(r,e),i=String(e.stack||e)}return e.l="",i},be=(e,t,r)=>{e.N=1;let n=((e,t)=>e.replace(/([a-zA-Z0-9_$\\\\.\\\\\\\'\\\\"\\\\`])?(\\\\.\\\\.\\\\.)?this(?![a-zA-Z0-9_$:])/g,((e,t,r)=>{const n=(t||"")+(r||"");return null!=t?n+"this":n+"(thi$(this)?window:this)"})))(t);t=`with(this){${n.replace(/\\\\/\\\\/# so/g,"//Xso")}\\\\n;function thi$(t){return t===this}};${(h.i.globalFns||[]).filter((e=>/[a-zA-Z_$][0-9a-zA-Z_$]*/.test(e))).map((e=>`(typeof ${e}==\\\'function\\\'&&(this.${e}=${e}))`)).join(";")};`+(r?"\\\\n//# sourceURL="+r:""),e.A||(t=t.replace(/.postMessage\\\\(/g,`.postMessage(\\\'${e.V}\\\',`)),new Function(t).call(e.U),e.N=0},Ie=(e,t,r)=>{(r=_(e,t))&&setTimeout((()=>r.map((e=>e({type:t})))))},Te=(e,t)=>{for(t=e.E;!t.host&&(t=(e=p[e.J]).E,e.V!==e.J););return t},Me=(e,t,r,n,i,s)=>(n=Te(e,n),i=new URL(t||"",n),r&&h.i.resolveUrl&&(s=h.i.resolveUrl(i,n,r))?s:i),Ee=(e,t,r)=>Me(e,t,r)+"",Ne=(e,t)=>{const r=Te(e),n=new URL(t||"",r);if(h.i.resolveSendBeaconRequestParameters){const e=h.i.resolveSendBeaconRequestParameters(n,r);if(e)return e}return{}},xe=()=>`<script src="${y("partytown.js?v="+ve)}"><\\\\/script>`,Le=e=>class{constructor(){this.s="",this.l=[],this.e=[],this.style={}}get src(){return this.s}set src(t){this.s=t,fetch(Ee(e,t,"image"),{mode:"no-cors",credentials:"include",keepalive:!0}).then((e=>{e.ok||0===e.status?this.l.map((e=>e({type:"load"}))):this.e.map((e=>e({type:"error"})))}),(()=>this.e.forEach((e=>e({type:"error"})))))}addEventListener(e,t){"load"===e&&this.l.push(t),"error"===e&&this.e.push(t)}removeEventListener(e,t){"load"===e&&(this.l=this.l.filter((e=>e!==t))),"error"===e&&(this.e=this.e.filter((e=>e!==t)))}get onload(){return this.l[0]}set onload(e){this.l=[e]}get onerror(){return this.e[0]}set onerror(e){this.e=[e]}},Re={addEventListener:{value(...e){const t=e[0],r=_(this,t)||[];r.push(e[1]),B(this,t,r)}},async:{get:x,set:x},defer:{get:x,set:x},onload:{get(){let e=_(this,"load");return e&&e[0]||null},set(e){B(this,"load",e?[e]:null)}},onerror:{get(){let e=_(this,"error");return e&&e[0]||null},set(e){B(this,"error",e?[e]:null)}},getAttribute:{value(e){return"src"===e?this.src:ue(this,["getAttribute"],[e])}},setAttribute:{value(e,t){Ce.includes(e)?this[e]=t:ue(this,["setAttribute"],[e,t])}}},Ce=w("src,type"),Pe=(e,t)=>{const r={innerHTML:Oe,innerText:Oe,src:{get(){return _(this,4)||""},set(e){const r=Ee(t,e,null),n=h.i;e=Ee(t,e,"script"),B(this,4,e),de(this,["src"],e),r!==e&&de(this,["dataset","ptsrc"],r),this.type&&D(n,e)&&de(this,["type"],"text/javascript")}},text:Oe,textContent:Oe,type:{get(){return $e(this,["type"])},set(e){Ae(e)||(B(this,5,e),de(this,["type"],e))}},...Re};j(e,r)},Oe={get(){const e=$e(this,["type"]);if(Ae(e)){const e=_(this,3);if(e)return e}return $e(this,["innerHTML"])||""},set(e){B(this,3,e)}},Ae=e=>!e||"text/javascript"===e,He=(e,i,s)=>{const o=h.i,a=H(class extends s{appendChild(e){return this.insertBefore(e,null)}get href(){}set href(e){}insertBefore(e,s){const a=e[t]=this[t],c=e[r],l=e[n],$="SCRIPT"===l,d="IFRAME"===l;if($){const t=_(e,3),r=_(e,5);if(t){if(Ae(r)){const r=e.id;if(r&&D(o,r))de(e,["type"],"text/javascript");else{const r=Se(i,c,t,0,""),n=r?"pterror":"ptid",s=r||c;de(e,["type"],O+"-x"),de(e,["dataset",n],s)}}de(e,["innerHTML"],t)}}if(ue(this,["insertBefore"],[e,s],2),d){const t=_(e,0);if(t&&t.startsWith("javascript:")){const e=t.split("javascript:")[1];Se(i,c,e,0,"")}((e,t)=>{let r,n,i=0,s=()=>{p[e]&&p[e].x&&!p[e].y?(r=_(t,1)?"error":"load",n=_(t,r),n&&n.map((e=>e({type:r})))):i++>2e3?(n=_(t,"error"),n&&n.map((e=>e({type:"error"})))):setTimeout(s,9)};s()})(c,e)}return $&&(le(!0),h.K([7,a])),e}get nodeName(){return"#s"===this[n]?"#document-fragment":this[n]}get nodeType(){return 3}get ownerDocument(){return i.n}},"Node");q(a,w("childNodes,firstChild,isConnected,lastChild,nextSibling,parentElement,parentNode,previousSibling")),e.Node=a},We=w("AUDIO,CANVAS,VIDEO"),je=w("Audio,MediaSource"),ke=(e,r,n)=>{j(e,{body:{get:()=>r.e},cookie:{get(){return r.A?$e(this,["cookie"]):(oe("get","cookie",r),"")},set(e){r.A&&de(this,["cookie"],e)}},createElement:{value(e){if(e=e.toUpperCase(),!N.test(e))throw e+" not valid";const r="IFRAME"===e,n=this[t],i=(r?"f_":"")+P();ue(this,["createElement"],[e],2,i);const s=F(n,i,e);if(r)Qe({V:i,J:n,S:f},!0).U.fetch=fetch,de(s,["srcdoc"],xe());else if("SCRIPT"===e){const e=_(s,5);Ae(e)&&de(s,["type"],O)}return s}},createElementNS:{value(e,r){const n=P(),i=F(this[t],n,r,e);return ue(this,["createElementNS"],[e,r],2,n),i}},createTextNode:{value(e){const r=this[t],n=P(),i=F(r,n,"#text");return ue(this,["createTextNode"],[e],2,n),i}},createEvent:{value:e=>new Event(e)},currentScript:{get(){return r.l?F(this[t],r.l,"SCRIPT"):null}},defaultView:{get:()=>n?null:r.U},documentElement:{get:()=>r.o},getElementsByTagName:{value(e){return"BODY"===(e=e.toUpperCase())?[r.e]:"HEAD"===e?[r.s]:ue(this,["getElementsByTagName"],[e])}},head:{get:()=>r.s},images:{get(){return $e(this,["images"])}},scripts:{get(){return $e(this,["scripts"])}},implementation:{get(){return{hasFeature:()=>!0,createHTMLDocument:e=>{const t=P();return ue(this,["implementation","createHTMLDocument"],[e],1,{V:t}),Qe({V:t,J:t,S:r.E+"",T:"hidden"},!0,!0).n}}}},location:{get:()=>r.E,set(e){r.E.href=e+""}},nodeType:{value:9},parentNode:{value:null},parentElement:{value:null},readyState:{value:"complete"},visibilityState:{get:()=>r.T||"visible"}}),X(e,"compatMode,referrer,forms")},De=(e,t)=>{j(e,{parentElement:{get(){return this.parentNode}},parentNode:{get:()=>t.o}})},Ue=(e,t)=>{j(e,{localName:{get(){return this[n].toLowerCase()}},namespaceURI:{get(){return this[i]||"http://www.w3.org/1999/xhtml"}},nodeType:{value:1},tagName:{get(){return this[n]}}}),q(e,S),X(e,"id"),Z(t),G(t,w("getClientRects,getBoundingClientRect"))},_e=(e,t)=>{const r={};w("hash,host,hostname,href,origin,pathname,port,protocol,search").map((e=>{r[e]={get(){let r,n=_(this,4);if("string"!=typeof n){if(r=$e(this,["href"]),""===r)return"protocol"===e?":":"";B(this,4,r),n=new URL(r)[e]}return Me(t,n,null)[e]},set(r){let n;if("href"===e)if((e=>{try{return new URL(e),!0}catch(e){return!1}})(r))n=new URL(r);else{const e=t.E.href;n=Me(t,e,null),n.href=new URL(r+"",n.href)}else n=Me(t,this.href,null),n[e]=r;B(this,4,n.href),de(this,["href"],n.href)}}})),j(e,r)},Be=(e,t)=>{const r={contentDocument:{get(){return Ve(this).n}},contentWindow:{get(){return Ve(this).U}},src:{get(){let e=_(this,0);return e&&e.startsWith("javascript:")?e:(e=Ve(this).E.href,e.startsWith("about:")?"":e)},set(e){if(e)if(e.startsWith("javascript:"))B(this,0,e);else if(!e.startsWith("about:")){let t,r=new XMLHttpRequest,n=Ve(this);n.E.href=e=Ee(n,e,"iframe"),n.y=1,B(this,1,void 0),r.open("GET",e,!1),r.send(),t=r.status,t>199&&t<300?(de(this,["srcdoc"],`<base href="${e}">`+r.responseText.replace(ze,((e,t)=>{const r=[];let n,i=!1;for(;n=qe.exec(t);){let[e]=n;e.startsWith("type=")&&(i=!0,e=e.replace(/(application|text)\\\\/javascript/,O)),r.push(e)}return i||r.push(\\\'type="\\\'+O+\\\'"\\\'),`<script ${r.join(" ")}>`}))+xe()),le(!0),h.K([7,n.V])):(B(this,1,t),n.y=0)}}},...Re};j(e,r)},Fe="((?:\\\\\\\\w|-)+(?:=(?:(?:\\\\\\\\w|-)+|\\\'[^\\\']*\\\'|\\\\"[^\\\\"]*\\\\")?)?)",ze=new RegExp(`<script\\\\\\\\s*((${Fe}\\\\\\\\s*)*)>`,"mg"),qe=new RegExp(Fe,"mg"),Ve=e=>{const n=e[r];return p[n]||Qe({V:n,J:e[t],S:$e(e,["src"])||f},!0),p[n]},Xe=e=>{const t=(e,t)=>{const{a:r,b:n,c:i,d:s,e:o,f:a}=ue(e,[t],C);return new DOMMatrixReadOnly([r,n,i,s,o,a])},r={...e,getCTM:{value:function(){return t(this,"getCTM")}},getScreenCTM:{value:function(){return t(this,"getScreenCTM")}}};j(e,r)},Ze=(e,t)=>{e.NamedNodeMap=H(class extends t{constructor(e,t,r){return super(e,t,r),new Proxy(this,{get(e,t){const r=Je[t];return r?r.bind(e,[t]):$e(e,[t])},set(e,t,r){if(Je[t])throw new Error("Can\\\'t set read-only property: "+String(t));return de(e,[t],r),!0}})}},"NamedNodeMap")};function Ge(e,...t){return ue(this,e,t,1)}const Je={getNamedItem:Ge,getNamedItemNS:Ge,item:Ge,removeNamedItem:Ge,removeNamedItemNS:Ge,setNamedItem:Ge,setNamedItemNS:Ge},Ye=(a,c,l,$,d,g)=>{let m,v,b,I;const T=class{constructor(e,c,l,$,d){this[t]=e||a,this[r]=c||m||P(),this[s]=l||[],this[n]=$||v,this[i]=d||b,this[o]=I&&I[o]||{},m=v=b=void 0}},E=new(H(class extends URL{assign(){}reload(){}replace(){}},"Location"))(l),N=E.origin===h.I||E.origin===f,x=c===a,C={},O=()=>{let e,t,r=[];for(e in p)t=p[e],t.J!==a||t.B||r.push(t);return r},D=H(class extends T{constructor(){super(a,a),this.addEventListener=(...e)=>{"load"===e[0]?C.N&&setTimeout((()=>e[1]({type:"load"}))):ue(this,["addEventListener"],e,2)};let n,i,o=this,l=0,u=()=>{l||((h.u||(e.g=[$e,de,ue,he,j,P,t,r,s],h.t(y("partytown-media.js?v="+ve)),h.u=e.f,delete e.f),h.u)(T,J,C,o,je),l=1)},p={},f=(e,t,r,n)=>{We.includes(e)&&u();const i=p[e]?p[e]:e.includes("-")?p.UNKNOWN:p.I;return m=t,v=e,b=r,I=n,new i};var M,L;if(o.Window=D,o.name=name+a,He(o,C,T),(e=>{e.NodeList=H(ie,"NodeList")})(o),Ze(o,T),me(o,T,"CSSStyleDeclaration"),((e,t,r)=>{e[r]=H(class extends t{now(){return performance.now()}},r)})(o,T,"Performance"),((e,t)=>{const r="customElements",n=new Map;e[r]={define(i,s,o){n.set(i,s),t[i.toUpperCase()]=s;const a=[s.name,s.observedAttributes];ue(e,[r,"define"],[i,a,o])},get:t=>n.get(t)||ue(e,[r,"get"],[t]),whenDefined:t=>n.has(t)?Promise.resolve():ue(e,[r,"whenDefined"],[t]),upgrade:t=>ue(e,[r,"upgrade"],[t])}})(o,p),h.v.map((([e,t,n,i,c])=>{const l=Ke[e]?V:"EventTarget"===t?J:"Object"===t?T:o[t],$=o[e]=H(12===i?class extends T{constructor(...t){super(),he(this,e,t)}}:o[e]||class extends l{},e);c&&(p[c]=$),n.map((([e,t,n])=>{e in $.prototype||e in l.prototype||("string"==typeof t?W($,e,{get(){if(!U(this,e)){const n=this[r],i=[...this[s],e],c=o[t];c&&B(this,e,new c(a,n,i))}return _(this,e)},set(t){B(this,e,t)}}):5===t?k($,e,(function(...t){return ue(this,[e],t)})):t>0&&(void 0!==n?k($,e,n):W($,e,{get(){return $e(this,[e])},set(t){return de(this,[e],t)}})))}))})),w("atob,btoa,crypto,indexedDB,setTimeout,setInterval,clearTimeout,clearInterval").map((t=>{delete D.prototype[t],t in o||(n=e[t],null!=n&&(o[t]="function"!=typeof n||n.toString().startsWith("class")?n:n.bind(e)))})),Object.getOwnPropertyNames(e).map((t=>{t in o||(o[t]=e[t])})),je.map((e=>A(o,e,{get:()=>(u(),o[e])}))),"trustedTypes"in e&&(o.trustedTypes=e.trustedTypes),Ue(o.Element,o.HTMLElement),ke(o.Document,C,g),M=o.DocumentFragment,z(M,11),q(M,S),_e(o.HTMLAnchorElement,C),L=o.HTMLFormElement,j(L,{}),X(L,"elements"),Be(o.HTMLIFrameElement),Pe(o.HTMLScriptElement,C),Xe(o.SVGGraphicsElement),De(o.HTMLHeadElement,C),De(o.HTMLBodyElement,C),((e,t)=>{j(e,{parentElement:{value:null},parentNode:{get:()=>t.n}})})(o.HTMLHtmlElement,C),fe(o,"CSSStyleSheet"),z(o.Comment,8),z(o.DocumentType,10),Object.assign(C,{V:a,J:c,U:new Proxy(o,{get:(e,t)=>{var r;if("string"!=typeof t||isNaN(t))return(null===(r=h.i.mainWindowAccessors)||void 0===r?void 0:r.includes(t))?$e(this,[t]):e[t];{let e=O()[t];return e?e.U:void 0}},has:()=>!0}),n:f("#document",a+".d"),o:f("HTML",a+".e"),s:f("HEAD",a+".h"),e:f("BODY",a+".b"),E:E,T:$,A:N,B:x,k:f}),o.requestAnimationFrame=e=>setTimeout((()=>e(performance.now())),9),o.cancelAnimationFrame=e=>clearTimeout(e),o.requestIdleCallback=(e,t)=>(t=Date.now(),setTimeout((()=>e({didTimeout:!1,timeRemaining:()=>Math.max(0,50-(Date.now()-t))})),1)),o.cancelIdleCallback=e=>clearTimeout(e),ge(o,"localStorage",N,C),ge(o,"sessionStorage",N,C),N||(o.indexeddb=void 0),d)i={},o.history={pushState(e){i=e},replaceState(e){i=e},get state(){return i},length:0},o.indexeddb=void 0;else{const e=o.history.pushState.bind(o.history),t=o.history.replaceState.bind(o.history);o.history.pushState=(t,r,n)=>{!1!==C.$propagateHistoryChange$&&e(t,r,n)},o.history.replaceState=(e,r,n)=>{!1!==C.$propagateHistoryChange$&&t(e,r,n)}}o.Worker=void 0}get body(){return C.e}get document(){return C.n}get documentElement(){return C.o}fetch(e,t){return e="string"==typeof e||e instanceof URL?String(e):e.url,fetch(Ee(C,e,"fetch"),t)}get frames(){return C.U}get frameElement(){return x?null:F(c,a,"IFRAME")}get globalThis(){return C.U}get head(){return C.s}get length(){return O().length}get location(){return E}set location(e){E.href=e+""}get Image(){return Le(C)}get navigator(){return(e=>{const t={sendBeacon:(t,r)=>{try{return fetch(Ee(e,t,null),{method:"POST",body:r,mode:"no-cors",keepalive:!0,...Ne(e,t)}),!0}catch(e){return console.error(e),!1}}};for(let e in navigator)t[e]=navigator[e];return new Proxy(t,{set:(e,t,r)=>(navigator[t]=r,!0),get:(t,r)=>Object.prototype.hasOwnProperty.call(t,r)?t[r]:$e(e.U,["navigator",r])})})(C)}get origin(){return E.origin}set origin(e){}get parent(){for(let e in p)if(p[e].V===c)return p[e].U;return C.U}postMessage(...e){p[e[0]]&&(L(u)>50&&u.splice(0,5),u.push({V:e[0],m:JSON.stringify(e[1])}),e=e.slice(1)),ue(this,["postMessage"],e,3)}get self(){return C.U}get top(){for(let e in p)if(p[e].B)return p[e].U;return C.U}get window(){return C.U}get XMLHttpRequest(){const e=XMLHttpRequest,t=String(e),r=H(class extends e{open(...e){e[1]=Ee(C,e[1],"xhr"),super.open(...e)}set withCredentials(e){h.i.allowXhrCredentials&&(super.withCredentials=e)}toString(){return t}},R(e));return r.prototype.constructor.toString=()=>t,r}},"Window"),V=class extends T{constructor(e,t,r,n){return super(e,t,r,n),new Proxy(this,{get:(e,t)=>$e(e,[t]),set:(e,t,r)=>(de(e,[t],r),!0)})}},J=class extends T{};return M.map((e=>J.prototype[e]=function(...t){return ue(this,[e],t,2)})),X(D,"devicePixelRatio"),Z(D),G(D,["getComputedStyle"]),new D,C},Ke={DOMStringMap:1,NamedNodeMap:1},Qe=({V:e,J:t,S:r,T:n},i,s)=>(p[e]||(p[e]=Ye(e,t,r,n,i,s)),h.K([7,e]),p[e]),et=[],tt=t=>{const r=t.data,n=r[0],i=r[1];if(h.x)if(7===n)(async e=>{let t,r=e.V,n=e.w,i=F(r,n,"SCRIPT"),s=e.j,o=e.S,a=e.H,c="",l=p[r],$=["text/jscript","text/javascript","text/x-javascript","application/javascript","application/x-javascript","text/ecmascript","text/x-ecmascript","application/ecmascript"];if(o)try{if(o=Me(l,o,"script")+"",B(i,4,o),t=await fetch(o),t.ok){let e=t.headers.get("content-type");$.some((t=>{var r,n,i;return null===(i=null===(r=null==e?void 0:e.toLowerCase)||void 0===r?void 0:(n=r.call(e)).includes)||void 0===i?void 0:i.call(n,t)}))&&(s=await t.text(),l.l=n,be(l,s,a||o)),Ie(i,"load")}else c=t.statusText,Ie(i,"error")}catch(e){console.error(e),c=String(e.stack||e),Ie(i,"error")}else s&&(c=Se(l,n,s,0,c));l.l="",h.K([6,r,n,c])})(i);else if(9===n)(({V:e,w:t,L:r,R:n,b:i})=>{if($[r])try{$[r].apply(ee(e,t,[],n),ee(e,t,[],i))}catch(e){console.error(e)}})(i);else if(10===n)(({V:e,q:t,b:r})=>{try{let n=p[e].U,i=0,s=L(t);for(;i<s;i++)i+1<s?n=n[t[i]]:n[t[i]].apply(n,ee(null,e,[],r))}catch(e){console.error(e)}})(i);else if(5===n)Qe(i);else if(8===n)p[i].x=1,p[i].y=0;else if(14===n)p[i].T=r[2];else if(13===n){const e=i.V,t=p[e];t.E.href=i.url,function(e,t,r){const n=t.U.history;switch(r.type){case 0:t.$propagateHistoryChange$=!1;try{n.pushState(r.state,"",r.newUrl)}catch(e){}t.$propagateHistoryChange$=!0;break;case 1:t.$propagateHistoryChange$=!1;try{n.replaceState(r.state,"",r.newUrl)}catch(e){}t.$propagateHistoryChange$=!0}}(i.V,t,i)}else 15===n&&((e,t,r,n,i)=>{const s=F(t,r);s&&"function"==typeof s[n]&&s[n].apply(s,i)})(...r);else 1===n?((t=>{const r=h.i=JSON.parse(t.i),n=t.I;h.t=importScripts.bind(e),h.v=t.v,h.C=t.C,h.I=n,h.K=postMessage.bind(e),h.P=t.P,h.$tabId$=t.$tabId$,e.importScripts=void 0,delete e.postMessage,delete e.WorkerGlobalScope,w("resolveUrl,resolveSendBeaconRequestParameters,get,set,apply").map((e=>{r[e]&&(r[e]=new Function("return "+r[e])())}))})(i),h.K([2])):3===n?(h.v=[...h.v,...i],h.x=1,h.K([4]),[...et].map(tt),et.length=0):et.push(t)};e.onmessage=tt,postMessage([0])})(self);\\n\'],{type:"text/javascript"})),{name:"Partytown 🎉"}),X.onmessage=t=>{const r=t.data;12===r[0]?H(X,r[1]):e(X,r)},S.addEventListener("pt1",(e=>B(X,$(e.detail.frameElement),e.detail))))}))})(window);\n</script></head></html>'
					)
				)
			: s.endsWith('proxytown') &&
				n.respondWith(
					((n) =>
						new Promise(async (i) => {
							const s = await n.clone().json(),
								o = await ((r) =>
									new Promise(async (n) => {
										const i = ((e, t) => {
											const r = t.split('.').pop()
											let n = e.find((e) => e.url.endsWith(`?${r}`))
											return (
												n ||
													(n = [...e].sort((e, t) =>
														e.url > t.url ? -1 : e.url < t.url ? 1 : 0
													)[0]),
												n
											)
										})([...(await self.clients.matchAll())], r.F)
										if (i) {
											const s = [
												n,
												setTimeout(() => {
													e.delete(r.F), n(t(r, 'Timeout'))
												}, 1e4)
											]
											e.set(r.F, s), i.postMessage(r)
										} else n(t(r, 'NoParty'))
									}))(s)
							i(r(JSON.stringify(o), 'application/json'))
						}))(i)
				)
	})

================
File: static/~partytown/partytown.js
================
/* Partytown 0.10.2 - MIT builder.io */
const t = { preserveBehavior: !1 },
	e = (e) => {
		if ('string' == typeof e) return [e, t]
		const [n, r = t] = e
		return [n, { ...t, ...r }]
	},
	n = Object.freeze(
		((t) => {
			const e = new Set()
			let n = []
			do {
				Object.getOwnPropertyNames(n).forEach((t) => {
					'function' == typeof n[t] && e.add(t)
				})
			} while ((n = Object.getPrototypeOf(n)) !== Object.prototype)
			return Array.from(e)
		})()
	)
!(function (t, r, o, i, a, s, c, d, l, p, u = t, f) {
	function h() {
		f ||
			((f = 1),
			'/' == (c = (s.lib || '/~partytown/') + (s.debug ? 'debug/' : ''))[0] &&
				((l = r.querySelectorAll('script[type="text/partytown"]')),
				i != t
					? i.dispatchEvent(new CustomEvent('pt1', { detail: t }))
					: ((d = setTimeout(v, 1e4)),
						r.addEventListener('pt0', w),
						a
							? y(1)
							: o.serviceWorker
								? o.serviceWorker
										.register(c + (s.swPath || 'partytown-sw.js'), { scope: c })
										.then(function (t) {
											t.active
												? y()
												: t.installing &&
													t.installing.addEventListener('statechange', function (t) {
														'activated' == t.target.state && y()
													})
										}, console.error)
								: v())))
	}
	function y(e) {
		;(p = r.createElement(e ? 'script' : 'iframe')),
			(t._pttab = Date.now()),
			e ||
				((p.style.display = 'block'),
				(p.style.width = '0'),
				(p.style.height = '0'),
				(p.style.border = '0'),
				(p.style.visibility = 'hidden'),
				p.setAttribute('aria-hidden', !0)),
			(p.src = c + 'partytown-' + (e ? 'atomics.js?v=0.10.2' : 'sandbox-sw.html?' + t._pttab)),
			r.querySelector(s.sandboxParent || 'body').appendChild(p)
	}
	function v(n, o) {
		for (
			w(),
				i == t &&
					(s.forward || []).map(function (n) {
						const [r] = e(n)
						delete t[r.split('.')[0]]
					}),
				n = 0;
			n < l.length;
			n++
		)
			((o = r.createElement('script')).innerHTML = l[n].innerHTML),
				(o.nonce = s.nonce),
				r.head.appendChild(o)
		p && p.parentNode.removeChild(p)
	}
	function w() {
		clearTimeout(d)
	}
	;(s = t.partytown || {}),
		i == t &&
			(s.forward || []).map(function (r) {
				const [o, { preserveBehavior: i }] = e(r)
				;(u = t),
					o.split('.').map(function (e, r, o) {
						var a
						u = u[o[r]] =
							r + 1 < o.length
								? u[o[r]] || ((a = o[r + 1]), n.includes(a) ? [] : {})
								: (() => {
										let e = null
										if (i) {
											const { methodOrProperty: n, thisObject: r } = ((t, e) => {
												let n = t
												for (let t = 0; t < e.length - 1; t += 1) n = n[e[t]]
												return {
													thisObject: n,
													methodOrProperty: e.length > 0 ? n[e[e.length - 1]] : void 0
												}
											})(t, o)
											'function' == typeof n && (e = (...t) => n.apply(r, ...t))
										}
										return function () {
											let n
											return e && (n = e(arguments)), (t._ptf = t._ptf || []).push(o, arguments), n
										}
									})()
					})
			}),
		'complete' == r.readyState
			? h()
			: (t.addEventListener('DOMContentLoaded', h), t.addEventListener('load', h))
})(window, document, navigator, top, window.crossOriginIsolated)

================
File: static/css/banner.css
================
cookie-consent-banner::part(toggle),
.cookieConsentToggle {
	width: 40px;
	height: 40px;
	position: fixed;
	will-change: transform;
	padding: 9px;
	border: 0;
	box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
	background: white;
	border-radius: 50%;
	bottom: 20px;
	right: 20px;
	transition: 200ms;
	opacity: 1;
	z-index: 99980;
}

cookie-consent-banner::part(toggle):hover,
.cookieConsentToggle:hover {
	color: white;
	background: black;
}

cookie-consent-banner::part(wrapper),
.cookieConsentWrapper {
	z-index: 99990;
	position: fixed;
	left: 0;
	right: 0;
	bottom: 0;
	background: black;
	color: white;
	padding: 20px;
	transition: 200ms;
}

cookie-consent-banner::part(consent),
.cookieConsent {
	margin: 0 auto;
	display: flex;
	justify-content: space-between;
}

cookie-consent-banner::part(consent--content),
.cookieConsent__Content {
	margin-right: 40px;
}

cookie-consent-banner::part(consent--title),
.cookieConsent__Title {
	margin: 0;
	font-weight: bold;
}

cookie-consent-banner::part(consent--description),
.cookieConsent__Description {
	margin: 10px 0 0;
}

cookie-consent-banner::part(consent--description-link),
.cookieConsent__Description a {
	color: white;
	text-decoration: underline;
}

cookie-consent-banner::part(consent--description-link):hover,
.cookieConsent__Description a:hover {
	text-decoration: none;
}

cookie-consent-banner::part(consent--right),
.cookieConsent__Right {
	display: flex;
	align-items: flex-end;
}

cookie-consent-banner::part(operations),
.cookieConsentOperations {
	position: fixed;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	background: rgba(0, 0, 0, 0.8);
	display: flex;
	transition: 300ms;
	will-change: transform;
	z-index: 99999;
}

cookie-consent-banner::part(operations--list),
.cookieConsentOperations .cookieConsentOperations__List {
	transform: scale(1);
}

cookie-consent-banner::part(operations--list),
.cookieConsentOperations__List {
	background: white;
	color: black;
	max-width: 500px;
	padding: 40px;
	margin: auto;
	overflow-y: auto;
	box-sizing: border-box;
	max-height: 100vh;
	transition: 200ms transform;
	will-change: transform;
	transform: scale(0.95);
}

cookie-consent-banner::part(operations--list-item),
.cookieConsentOperations__Item {
	display: block;
	padding-left: 60px;
	margin-bottom: 20px;
}

cookie-consent-banner::part(operations--list-item--disabled),
.cookieConsentOperations__Item.disabled {
	color: #999;
}

cookie-consent-banner::part(operations--list-item--disabled)
	cookie-consent-banner::part(operations--list-item-label)::after,
.cookieConsentOperations__Item.disabled label::after {
	opacity: 0.3;
}

cookie-consent-banner::part(operations--list-item-input),
.cookieConsentOperations__Item input {
	display: none;
}

cookie-consent-banner::part(operations--list-item-label),
.cookieConsentOperations__Item label {
	align-items: center;
	font-size: 22px;
	font-weight: bold;
	display: block;
	position: relative;
}

cookie-consent-banner::part(operations--list-item-label)::before,
.cookieConsentOperations__Item label::before {
	content: '';
	display: block;
	left: -60px;
	background: #dedede;
	height: 20px;
	border-radius: 20px;
	width: 40px;
	position: absolute;
	top: 50%;
	transform: translateY(-50%);
}

cookie-consent-banner::part(operations--list-item-label)::after,
.cookieConsentOperations__Item label::after {
	content: '';
	display: block;
	width: 16px;
	height: 16px;
	border-radius: 50%;
	background: black;
	position: absolute;
	top: 50%;
	transform: translateY(-50%);
	left: -58px;
	transition: 200ms;
}

cookie-consent-banner::part(operations--list-item-label--checked)::after,
.cookieConsentOperations__Item input:checked + label::after {
	transform: translate(20px, -50%);
}

cookie-consent-banner::part(button),
.cookieConsent__Button {
	padding: 15px 40px;
	display: block;
	background: white;
	color: black;
	white-space: nowrap;
	border: 0;
	font-size: 16px;
	margin-left: 10px;
	cursor: pointer;
	transition: 200ms;
}

cookie-consent-banner::part(button--close),
.cookieConsent__Button--Close {
	background: black;
	color: white;
	margin: 40px 0 0 60px;
	padding: 15px 60px;
}

cookie-consent-banner::part(button):hover,
.cookieConsent__Button:hover {
	opacity: 0.6;
}

@media only screen and (max-width: 900px) {
	cookie-consent-banner::part(consent),
	.cookieConsent {
		display: block;
	}

	cookie-consent-banner::part(consent--right),
	.cookieConsent__Right {
		margin-top: 20px;
	}

	cookie-consent-banner::part(button),
	.cookieConsent__Button {
		margin: 0 10px 10px 0;
	}

	cookie-consent-banner::part(button--close),
	.cookieConsent__Button--Close {
		margin: 40px 0 0;
	}
}

================
File: static/css/consent.css
================
.cc--elegant-black {
	color-scheme: dark;

	--cc-bg: #000;
	--cc-primary-color: rgb(239, 244, 246);
	--cc-secondary-color: #b1bdc3;

	--cc-btn-primary-bg: #ffffff;
	--cc-btn-primary-color: #000;
	--cc-btn-primary-hover-bg: #ccd4d8;
	--cc-btn-primary-hover-color: #000;

	--cc-btn-secondary-bg: rgba(255, 255, 255, 0.039);
	--cc-btn-secondary-color: var(--cc-primary-color);
	--cc-btn-secondary-border-color: #252729;
	--cc-btn-secondary-hover-bg: #252729;
	--cc-btn-secondary-hover-color: #fff;
	--cc-btn-secondary-hover-border-color: #252729;

	--cc-cookie-category-block-bg: #101111;
	--cc-cookie-category-block-border: #1d1e1f;
	--cc-cookie-category-block-hover-bg: #151516;
	--cc-cookie-category-block-hover-border: #1d1e1f;
	--cc-cookie-category-expanded-block-hover-bg: #1d1e1f;
	--cc-cookie-category-expanded-block-bg: #101111;
	--cc-toggle-readonly-bg: #2f3132;
	--cc-overlay-bg: rgba(0, 0, 0, 0.9) !important;

	--cc-toggle-on-knob-bg: var(--cc-bg);
	--cc-toggle-readonly-knob-bg: var(--cc-cookie-category-block-bg);

	--cc-separator-border-color: #252729;

	--cc-footer-border-color: #212529;
	--cc-footer-bg: #000;
}

.cc--elegant-black #cc-main .cm,
.cc--elegant-black #cc-main .pm {
	border: 1px solid var(--cc-separator-border-color);
}

================
File: static/css/main.css
================
@import url('./typograpy.css');
@import url('./consent.css');
@import url('./banner.css');

:root {
	view-transition-name: root;

	/* Primarey Theme Colors */
	--color-surface-light: #5d91fa;
	--color-surface-dark: rgb(3, 57, 166);
	--color-text-light: #070f26;
	--color-text-dark: #f2f2f2;
	--color-accent-light: rgb(224, 7, 7);
	--color-accent-dark: #e00707;
	--color-success-light: #00c700;
	--color-success-dark: #008b00;
	--color-error-light: #e24000;
	--color-error-dark: #8c2800;
	--color-warning-light: #c4bd00;
	--color-warning-dark: #8a8600;
	--color-toggle-dark: #f2f2f2;
	--color-toggle-light: #070f26;

	--color-surface: var(--color-surface-dark);
	--color-surface-op: var(--color-surface-light);
	--color-text: var(--color-text-dark);
	--color-text-op: var(--color-text-light);
	--color-accent: var(--color-accent-dark);
	--color-success: var(--color-success-dark);
	--color-error: var(--color-error-dark);
	--color-warning: var(--color-warning-dark);
	--color-toggle: var(--color-toggle-dark);
	--color-selected: var(--color-accent-light);

	--color-red: var(--color-accent-light);
	--color-blue: var(--color-surface-light);
	--color-shadow: var(--color-accent);

	--shadow-light: 0px 1px 0px var(--color-surface);
	--shadow-light-footer: 0px 0.5px 0px var(--color-surface);
	--shadow-dark: 0px 1px 0px var(--color-surface-op);
	--shadow-dark-footer: 0px 0.5px 0px var(--color-surface-op);

	--shadow: var(--shadow-dark);
	--op-shadow: var(--shadow-light);

	--text-toggle: '☀️';
}

[data-theme='light'] {
	--color-surface: var(--color-surface-light);
	--color-surface-op: var(--color-surface-dark);
	--color-text: var(--color-text-light);
	--color-text-op: var(--color-text-dark);
	--color-accent: var(--color-accent-light);
	--color-success: var(--color-success-light);
	--color-error: var(--color-error-light);
	--color-warning: var(--color-warning-light);
	--color-toggle: var(--color-toggle-light);
	--color-selected: var(--color-accent-dark);

	--color-red: var(--color-accent-dark);
	--color-blue: var(--color-surface-dark);
	--color-shadow: var(--color-accent);

	--shadow: var(--shadow-light);
	--op-shadow: var(--shadow-dark);

	--text-toggle: '🌙';
}

[data-theme='dark'] {
	--color-surface: var(--color-surface-dark);
	--color-surface-op: var(--color-surface-light);
	--color-text: var(--color-text-dark);
	--color-text-op: var(--color-text-light);
	--color-accent: var(--color-accent-dark);
	--color-success: var(--color-success-dark);
	--color-error: var(--color-error-dark);
	--color-warning: var(--color-warning-dark);
	--color-toggle: var(--color-toggle-dark);
	--color-selected: var(--color-accent-light);

	--color-red: var(--color-accent-light);
	--color-blue: var(--color-surface-light);
	--color-shadow: var(--color-accent);

	--shadow: var(--shadow-dark);
	--op-shadow: var(--shadow-light);

	--text-toggle: '☀️';
}

* {
	box-sizing: border-box;
}

@view-transition {
	navigation: auto;
	types: slide, forwards;
}

/* Determine what gets captured when the type is forwards or backwards */
html:active-view-transition-type(forwards, backwards) {
	:root {
		view-transition-name: none;
	}
	article {
		view-transition-name: content;
	}
	.pagination {
		view-transition-name: pagination;
	}
}

/* Animation styles for forwards type only */
html:active-view-transition-type(forwards) {
	&::view-transition-old(content) {
		animation-name: slide-out-to-left;
	}
	&::view-transition-new(content) {
		animation-name: slide-in-from-right;
	}
}

/* Animation styles for backwards type only */
html:active-view-transition-type(backwards) {
	&::view-transition-old(content) {
		animation-name: slide-out-to-right;
	}
	&::view-transition-new(content) {
		animation-name: slide-in-from-left;
	}
}

/* Animation styles for reload type only */
html:active-view-transition-type(reload) {
	&::view-transition-old(root) {
		animation-name: fade-out, scale-down;
	}
	&::view-transition-new(root) {
		animation-delay: 0.25s;
		animation-name: fade-in, scale-up;
	}
}

@keyframes move-out {
	from {
		transform: translateY(0%);
	}

	to {
		transform: translateY(-100%);
	}
}

@keyframes move-in {
	from {
		transform: translateY(100%);
	}

	to {
		transform: translateY(0%);
	}
}

/* Apply the custom animation to the old and new page states */

::view-transition-old(root) {
	animation: 0.2s ease-in both move-out;
}

::view-transition-new(root) {
	animation: 0.2s ease-in both move-in;
}

body {
	background: var(--color-surface);
	color: var(--color-text);
}

ul {
	list-style: none;
	padding: 0;
}

.side-by-side:has(img) {
	img {
		border: none;
	}
}

.side-by-side > img:first-child {
	/* border-radius: var(--radius-3) 0 0 var(--radius-3); */
}

.side-by-side > img:last-child {
	/* border-radius: 0 var(--radius-3) var(--radius-3) 0; */
}

.logo-span {
	font-size: 2.5rem;
	text-shadow: var(--shadow);
}

footer .logo-span {
	font-size: 1.5rem;
	text-shadow: var(--op-shadow-footer);
}

.red {
	color: var(--color-red);
}

.blue {
	color: var(--color-blue);
}

.bold {
	font-weight: bold;
}

.op-shadow {
	text-shadow: var(--op-shadow);
}

strong {
	color: var(--color-text);
	text-shadow: var(--op-shadow);
}

.mono {
	font-family: var(--font-mono);
}

.flow-text {
	float: left;
	shape-outside: margin-box;
}

hr {
	border: 0;
	height: 6px;
	margin: 2rem 0;
	background: linear-gradient(
		to right,
		var(--color-accent),
		var(--color-text-dark),
		var(--color-surface-op)
	);
}

@media (max-width: 1000px) {
	.logo {
		max-width: 100% !important;
		height: auto !important;
	}
}

.bmc-btn-container {
	/* pin it to the bottom of the page NOT the bottom of the screen */
	position: fixed;
	bottom: 0;
	left: 0;
	z-index: 9999;
}

================
File: static/css/typograpy.css
================
@import url('https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,100..900;1,100..900&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap');

:root {
	--font-body: 'Poppins', sans-serif;
	--font-header: 'Bitter', serif;
	--font-mono: monospace;
}

html {
	font-size: 16px;
}

body {
	font-family: var(--font-body);
}

h1,
h2,
h3,
h4,
h5,
h6,
.header-font {
	font-family: var(--font-header);
	font-weight: bold;
}

h2,
h3,
h4,
h5,
h6 {
	padding: 0;
	padding: 0.75rem 0;
	text-shadow: var(--op-shadow);
	color: var(--color-surface-op);
	word-break: break-words;
}

h1 {
	margin: 0;
	font-size: clamp(2rem, 6vw, 5.5rem);
	padding-bottom: 10px;
}

h2 {
	margin: 0.5rem 0;
	font-size: clamp(1.5rem, 4vw, 3rem);
	font-weight: bold;
}

h3 {
	font-size: clamp(1.5rem, 3vw, 2.5rem);
	margin: 0.5rem 0;
}

h4 {
	font-size: clamp(1.5rem, 2.5vw, 2rem);
	margin: 0.25rem 0;
}

h5 {
	font-size: clamp(1.5rem, 2vw, 1.5rem);
	margin: 0.25rem 0;
}

h6 {
	font-size: clamp(1.5rem, 1.5vw, 1rem);
	margin: 0.15rem 0;
}

a {
	color: var(--color-text);
	text-decoration: none;
	font-weight: bold;

	&:hover {
		color: var(--color-accent);
		text-decoration: underline;
	}

	&:visited {
		color: var(--color-text);
	}
}

p {
	font-size: clamp(1rem, 1.5vw, 1.25rem);
	line-height: 1.5;
	margin: 0;
	margin-bottom: 1rem;
}

p::selection {
	color: var(--color-selected-text);
	background-color: var(--color-selected);
}

================
File: static/favicon/browserconfig.xml
================
<?xml version="1.0" encoding="utf-8"?>
<browserconfig>
    <msapplication>
        <tile>
            <square150x150logo src="/mstile-150x150.png"/>
            <TileColor>#e00707</TileColor>
        </tile>
    </msapplication>
</browserconfig>

================
File: static/favicon/manifest.json
================
{
	"short_name": "Trump Talk 45/47",
	"name": "Trump Talk 45/47",
	"start_url": "/",
	"id": "/",
	"orientation": "any",
	"screenshots": [
		{
			"src": "screenshot-desktop.webp",
			"sizes": "1280x709",
			"type": "image/webp",
			"form_factor": "wide",
			"label": "Homescreen of Awesome App"
		},
		{
			"src": "screenshot-mobile.webp",
			"sizes": "374x665",
			"type": "image/webp",
			"label": "List of Awesome Resources available in Awesome App"
		}
	],
	"icons": [
		{
			"purpose": "any",
			"sizes": "144x144",
			"src": "icon_144.png",
			"type": "image/png"
		},
		{
			"purpose": "maskable",
			"sizes": "1001x1001",
			"src": "maskable_icon.png",
			"type": "image/png"
		},
		{
			"purpose": "maskable",
			"sizes": "48x48",
			"src": "maskable_icon_x48.png",
			"type": "image/png"
		},
		{
			"purpose": "maskable",
			"sizes": "72x72",
			"src": "maskable_icon_x72.png",
			"type": "image/png"
		},
		{
			"purpose": "maskable",
			"sizes": "96x96",
			"src": "maskable_icon_x96.png",
			"type": "image/png"
		},
		{
			"purpose": "maskable",
			"sizes": "128x128",
			"src": "maskable_icon_x128.png",
			"type": "image/png"
		},
		{
			"purpose": "maskable",
			"sizes": "192x192",
			"src": "maskable_icon_x192.png",
			"type": "image/png"
		},
		{
			"purpose": "maskable",
			"sizes": "384x384",
			"src": "maskable_icon_x384.png",
			"type": "image/png"
		},
		{
			"purpose": "maskable",
			"sizes": "512x512",
			"src": "maskable_icon_x512.png",
			"type": "image/png"
		}
	],
	"background_color": "#0339A6",
	"display": "standalone",
	"scope": "/",
	"theme_color": "#0339A6",
	"description": "President Trump's 47th News, Analysis, and Speeches"
}

================
File: static/favicon/safari-pinned-tab.svg
================
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
 "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
 width="512.000000pt" height="512.000000pt" viewBox="0 0 512.000000 512.000000"
 preserveAspectRatio="xMidYMid meet">
<metadata>
Created by potrace 1.14, written by Peter Selinger 2001-2017
</metadata>
<g transform="translate(0.000000,512.000000) scale(0.100000,-0.100000)"
fill="#000000" stroke="none">
<path d="M2188 5113 c7 -3 16 -2 19 1 4 3 -2 6 -13 5 -11 0 -14 -3 -6 -6z"/>
<path d="M2193 5100 c-235 -36 -433 -93 -641 -182 -63 -26 -119 -45 -124 -41
-6 3 -8 1 -5 -4 8 -13 -17 -25 -36 -17 -7 2 -21 -2 -32 -11 -20 -15 -20 -15 0
-9 11 3 2 -6 -20 -20 -44 -28 -60 -33 -49 -14 5 7 -8 3 -27 -9 -18 -12 -34
-27 -34 -33 0 -11 -24 -30 -38 -30 -5 0 -5 6 -1 13 4 7 3 9 -2 4 -5 -5 -9 -14
-9 -20 0 -5 -6 -12 -14 -15 -9 -3 -11 0 -6 9 5 8 4 11 -1 6 -5 -5 -9 -14 -9
-20 0 -7 -8 -11 -17 -11 -10 1 -16 -3 -15 -8 1 -6 -4 -13 -12 -16 -10 -3 -11
0 -5 9 7 12 5 12 -9 1 -9 -8 -15 -19 -14 -24 1 -6 -4 -13 -12 -16 -9 -3 -11 0
-6 9 5 8 4 11 -1 6 -5 -5 -9 -14 -9 -20 0 -7 -8 -12 -17 -12 -20 0 -82 -44
-74 -52 7 -8 -13 -33 -26 -33 -6 0 -4 8 3 18 7 9 1 6 -14 -7 -15 -14 -25 -27
-22 -29 7 -7 -15 -32 -27 -32 -6 0 -5 8 3 18 7 9 -13 -8 -44 -38 -57 -55 -67
-67 -44 -54 6 4 -10 -16 -38 -45 -50 -52 -62 -61 -49 -38 4 6 -16 -10 -45 -38
-48 -47 -69 -72 -36 -45 8 7 15 8 15 2 0 -12 -25 -34 -32 -27 -3 3 -13 -5 -24
-17 -10 -12 -13 -18 -6 -14 6 4 12 3 12 -2 0 -12 -25 -33 -32 -27 -3 3 -11 -2
-19 -12 -9 -11 -10 -14 -1 -9 6 4 12 3 12 -2 0 -13 -25 -33 -32 -26 -3 3 -16
-9 -29 -27 -13 -18 -17 -29 -10 -24 9 5 12 3 9 -6 -3 -8 -11 -14 -19 -14 -8 0
-13 -8 -11 -19 2 -10 -1 -15 -6 -12 -5 3 -16 -2 -23 -11 -12 -14 -12 -16 0 -9
9 6 12 5 9 -5 -3 -8 -10 -13 -16 -12 -5 1 -9 -5 -8 -15 0 -9 -5 -16 -12 -14
-8 1 -11 -2 -8 -7 9 -14 -95 -192 -107 -184 -5 3 -7 1 -4 -5 9 -13 -2 -44 -14
-37 -4 3 -13 -3 -18 -14 -14 -25 -14 -41 0 -21 8 11 9 9 3 -10 -10 -37 -33
-78 -34 -60 0 8 -9 -1 -20 -20 -22 -40 -27 -68 -5 -30 24 42 17 9 -15 -69 -70
-170 -131 -410 -156 -611 -19 -154 -18 -495 1 -647 27 -203 88 -440 155 -603
32 -76 39 -112 15 -70 -20 35 -19 18 2 -25 9 -19 20 -30 23 -24 4 5 19 -17 34
-51 14 -34 23 -66 20 -72 -4 -7 -2 -8 4 -4 14 8 66 -90 56 -106 -4 -7 -3 -8 4
-4 6 3 16 -2 21 -13 14 -26 14 -34 -1 -25 -7 4 -8 3 -4 -5 4 -6 11 -9 16 -6
11 7 33 -32 25 -45 -3 -5 0 -12 6 -16 8 -5 9 -3 4 6 -6 9 -4 11 4 6 7 -5 10
-14 7 -22 -3 -8 0 -13 6 -11 6 1 13 -4 16 -12 3 -10 0 -11 -9 -5 -12 6 -12 5
0 -9 8 -10 16 -15 19 -13 5 6 42 -37 42 -49 0 -3 -6 -3 -13 1 -8 6 -8 3 1 -9
8 -9 19 -15 24 -14 6 1 13 -4 16 -12 3 -10 0 -11 -9 -5 -12 7 -12 5 -1 -9 8
-9 19 -15 24 -14 6 1 13 -4 16 -12 3 -9 0 -11 -9 -6 -8 5 -6 -1 5 -13 10 -12
23 -20 28 -19 6 1 13 -4 16 -12 3 -9 0 -11 -9 -6 -8 5 -3 -4 10 -18 13 -15 27
-24 31 -22 4 3 16 -7 25 -21 11 -18 13 -24 4 -19 -8 5 -3 -4 10 -18 26 -29 37
-35 25 -14 -4 6 7 -1 24 -17 37 -34 43 -49 9 -20 l-22 19 19 -22 c10 -13 22
-20 26 -18 4 2 15 -4 25 -15 10 -11 14 -20 9 -20 -4 0 11 -20 35 -44 24 -24
49 -42 55 -40 7 3 21 -5 32 -17 12 -14 13 -19 4 -14 -9 5 -8 0 4 -13 20 -23
32 -29 20 -11 -4 8 0 7 15 -1 12 -6 19 -15 17 -19 -3 -5 4 -17 16 -27 12 -11
18 -13 14 -7 -4 7 -3 13 2 13 13 0 33 -25 26 -32 -3 -3 3 -5 13 -5 9 1 18 -5
18 -13 0 -8 7 -15 15 -15 8 0 29 -10 45 -23 17 -13 23 -20 15 -16 -9 4 -12 3
-7 -2 5 -5 16 -9 25 -9 9 0 16 -6 14 -13 -1 -8 2 -11 8 -7 5 3 22 -2 38 -13
117 -82 375 -205 558 -267 282 -95 477 -125 815 -125 353 0 537 29 829 131
174 60 191 65 170 50 -25 -18 2 -12 40 9 19 11 28 19 20 20 -13 0 173 100 186
100 3 0 2 -5 -2 -11 -4 -8 0 -7 15 1 12 6 19 15 16 20 -3 4 21 23 52 42 72 41
78 44 68 28 -5 -9 -4 -11 4 -6 6 4 9 11 6 16 -3 4 6 15 20 24 35 23 45 19 15
-5 l-25 -21 25 14 c14 9 25 22 25 29 0 8 10 15 23 15 25 1 62 31 59 46 -1 6 4
13 12 16 9 3 11 0 6 -9 -10 -16 47 24 65 46 7 8 9 15 5 15 -4 0 -2 7 5 15 18
21 35 19 19 -2 -26 -33 125 105 196 178 39 40 60 65 48 55 -32 -27 -29 -5 4
25 14 13 23 17 18 9 -4 -8 6 -2 23 14 32 30 41 43 22 31 -5 -3 -10 -2 -10 3 0
12 25 33 32 27 3 -3 13 5 24 17 10 12 13 18 5 13 -9 -5 -12 -3 -9 6 3 8 10 13
16 12 5 -1 16 5 24 14 11 14 11 16 -1 9 -9 -6 -12 -5 -9 5 3 8 10 13 16 12 5
-1 16 5 24 14 11 14 11 16 -1 9 -9 -6 -12 -4 -9 5 3 8 11 14 19 14 8 0 13 8
11 19 -2 10 1 15 7 12 5 -3 19 8 31 26 21 31 21 32 1 9 -25 -28 -27 -20 -5 14
9 14 20 22 25 19 5 -3 6 2 3 11 -4 10 -2 15 6 13 6 -2 19 8 28 22 12 17 13 22
3 16 -9 -6 -12 -5 -9 5 3 8 10 13 16 12 6 -2 9 3 6 10 -2 7 3 21 11 32 15 19
16 19 5 -5 -11 -24 -11 -24 5 -5 9 11 23 34 31 50 14 27 14 28 -1 11 -25 -33
-17 -12 36 91 28 54 48 90 45 81 -9 -28 2 -21 19 13 9 17 14 33 11 37 -3 3 -6
-1 -6 -8 0 -7 -2 -11 -5 -8 -9 9 17 68 28 61 5 -3 7 -1 4 4 -4 6 15 77 42 159
27 82 52 166 56 186 4 21 10 36 14 34 3 -2 6 10 6 27 1 18 10 77 20 132 17 86
20 143 20 405 0 274 -2 318 -23 431 -12 69 -20 134 -16 145 4 13 3 15 -3 6 -7
-9 -13 3 -21 39 -14 58 -15 83 -2 54 14 -33 10 6 -5 45 -10 25 -14 29 -15 15
-1 -17 -3 -17 -11 5 -6 13 -7 36 -4 50 3 16 2 20 -3 12 -6 -9 -12 -1 -20 26
-16 52 -14 66 3 22 7 -19 14 -28 14 -20 1 21 -37 99 -39 80 0 -8 -12 12 -25
44 -26 62 -34 103 -10 51 8 -16 14 -23 14 -15 0 21 -48 109 -49 90 -1 -13 -2
-13 -9 0 -5 8 -12 26 -15 40 -6 19 -5 21 3 10 14 -20 14 -4 0 21 -5 11 -14 17
-19 14 -5 -3 -18 12 -30 34 -23 45 -25 55 -9 45 6 -3 3 8 -5 25 -18 34 -29 42
-19 14 10 -28 -1 -13 -46 60 -22 38 -38 73 -35 78 3 5 0 8 -7 7 -6 -2 -14 3
-17 11 -3 9 0 11 8 6 9 -5 11 -4 6 4 -4 6 -11 9 -16 6 -10 -6 -35 33 -35 55 0
8 -6 15 -14 15 -8 0 -16 6 -19 14 -3 9 0 11 9 5 12 -7 12 -5 1 9 -8 9 -19 15
-24 14 -6 -1 -13 4 -16 12 -3 10 0 11 9 5 8 -4 -3 12 -23 37 -20 24 -41 43
-47 42 -6 -2 -15 7 -21 20 -11 21 -10 21 4 3 9 -11 16 -15 16 -10 0 5 -19 28
-41 49 -23 22 -38 33 -34 25 6 -10 1 -8 -13 4 -24 21 -30 42 -9 30 6 -4 -22
28 -63 70 -71 73 -110 105 -59 49 13 -14 17 -23 9 -18 -26 14 -60 48 -55 55 2
4 -7 18 -22 31 -14 13 -23 18 -19 12 4 -7 3 -13 -2 -13 -12 0 -33 25 -27 32 3
3 -5 13 -17 24 -12 10 -18 13 -13 5 5 -9 3 -12 -6 -9 -8 3 -14 10 -14 18 0 7
-16 24 -34 39 -19 14 -31 20 -27 13 7 -11 4 -12 -13 -3 -11 7 -20 17 -18 23 1
7 -5 12 -13 13 -25 0 -91 46 -84 57 4 6 2 8 -4 4 -13 -8 -84 33 -77 44 3 4 -1
7 -8 7 -20 -2 -337 160 -329 168 4 5 1 5 -6 1 -17 -10 -54 3 -46 16 4 7 2 8
-5 4 -16 -10 -112 25 -104 37 3 6 1 7 -5 3 -6 -4 -69 9 -139 28 -238 66 -326
77 -638 82 -238 3 -298 1 -402 -16z m-918 -320 c-3 -5 -11 -10 -16 -10 -6 0
-7 5 -4 10 3 6 11 10 16 10 6 0 7 -4 4 -10z m-280 -190 c-3 -5 -11 -10 -16
-10 -6 0 -7 5 -4 10 3 6 11 10 16 10 6 0 7 -4 4 -10z m3575 -431 c0 -6 -4 -7
-10 -4 -5 3 -10 11 -10 16 0 6 5 7 10 4 6 -3 10 -11 10 -16z m-3765 -3469 c10
-11 16 -20 13 -20 -3 0 -13 9 -23 20 -10 11 -16 20 -13 20 3 0 13 -9 23 -20z
m3505 -26 c-8 -8 -23 -20 -34 -26 -19 -10 -18 -8 3 16 26 27 53 37 31 10z
m-145 -124 c-3 -5 -11 -10 -16 -10 -6 0 -7 5 -4 10 3 6 11 10 16 10 6 0 7 -4
4 -10z m-80 -60 c-3 -5 -11 -10 -16 -10 -6 0 -7 5 -4 10 3 6 11 10 16 10 6 0
7 -4 4 -10z"/>
<path d="M2008 5083 c7 -3 16 -2 19 1 4 3 -2 6 -13 5 -11 0 -14 -3 -6 -6z"/>
<path d="M1968 5073 c7 -3 16 -2 19 1 4 3 -2 6 -13 5 -11 0 -14 -3 -6 -6z"/>
<path d="M1740 5010 c-8 -5 -10 -10 -5 -10 6 0 17 5 25 10 8 5 11 10 5 10 -5
0 -17 -5 -25 -10z"/>
<path d="M1600 4960 c-8 -5 -10 -10 -5 -10 6 0 17 5 25 10 8 5 11 10 5 10 -5
0 -17 -5 -25 -10z"/>
<path d="M1474 4904 c-18 -14 -18 -14 6 -3 31 14 36 19 24 19 -6 0 -19 -7 -30
-16z"/>
<path d="M4660 4036 c0 -2 8 -10 18 -17 15 -13 16 -12 3 4 -13 16 -21 21 -21
13z"/>
<path d="M4751 3905 c12 -22 26 -44 32 -50 15 -16 -20 48 -38 70 -9 11 -7 2 6
-20z"/>
<path d="M363 3918 c-15 -20 -25 -38 -20 -38 3 0 12 11 21 25 17 26 16 35 -1
13z"/>
<path d="M310 3830 c-6 -11 -8 -20 -6 -20 3 0 10 9 16 20 6 11 8 20 6 20 -3 0
-10 -9 -16 -20z"/>
<path d="M146 3485 c-9 -26 -7 -32 5 -12 6 10 9 21 6 23 -2 3 -7 -2 -11 -11z"/>
<path d="M126 3435 c-9 -26 -7 -32 5 -12 6 10 9 21 6 23 -2 3 -7 -2 -11 -11z"/>
<path d="M61 3224 c0 -11 3 -14 6 -6 3 7 2 16 -1 19 -3 4 -6 -2 -5 -13z"/>
<path d="M5081 3074 c0 -11 3 -14 6 -6 3 7 2 16 -1 19 -3 4 -6 -2 -5 -13z"/>
<path d="M21 3044 c0 -11 3 -14 6 -6 3 7 2 16 -1 19 -3 4 -6 -2 -5 -13z"/>
<path d="M5092 3035 c0 -11 4 -33 8 -50 7 -27 8 -27 8 -5 0 14 -4 36 -8 50 -6
20 -8 21 -8 5z"/>
<path d="M12 2995 c0 -16 2 -22 5 -12 2 9 2 23 0 30 -3 6 -5 -1 -5 -18z"/>
<path d="M2 2940 c0 -14 2 -19 5 -12 2 6 2 18 0 25 -3 6 -5 1 -5 -13z"/>
<path d="M5112 2925 c0 -16 2 -22 5 -12 2 9 2 23 0 30 -3 6 -5 -1 -5 -18z"/>
<path d="M2 2190 c0 -14 2 -19 5 -12 2 6 2 18 0 25 -3 6 -5 1 -5 -13z"/>
<path d="M5112 2165 c0 -16 2 -22 5 -12 2 9 2 23 0 30 -3 6 -5 -1 -5 -18z"/>
<path d="M12 2125 c0 -16 2 -22 5 -12 2 9 2 23 0 30 -3 6 -5 -1 -5 -18z"/>
<path d="M5096 2089 c-4 -23 -5 -44 -2 -46 2 -2 7 14 11 37 4 23 5 43 2 46 -2
3 -7 -14 -11 -37z"/>
<path d="M21 2074 c0 -11 3 -14 6 -6 3 7 2 16 -1 19 -3 4 -6 -2 -5 -13z"/>
<path d="M5081 2014 c0 -11 3 -14 6 -6 3 7 2 16 -1 19 -3 4 -6 -2 -5 -13z"/>
<path d="M61 1900 c0 -8 4 -24 9 -35 5 -13 9 -14 9 -5 0 8 -4 24 -9 35 -5 13
-9 14 -9 5z"/>
<path d="M5051 1884 c0 -11 3 -14 6 -6 3 7 2 16 -1 19 -3 4 -6 -2 -5 -13z"/>
<path d="M120 1705 c0 -5 5 -17 10 -25 5 -8 10 -10 10 -5 0 6 -5 17 -10 25 -5
8 -10 11 -10 5z"/>
<path d="M4986 1685 c-9 -26 -7 -32 5 -12 6 10 9 21 6 23 -2 3 -7 -2 -11 -11z"/>
<path d="M140 1655 c0 -5 5 -17 10 -25 5 -8 10 -10 10 -5 0 6 -5 17 -10 25 -5
8 -10 11 -10 5z"/>
<path d="M4876 1423 c-6 -14 -5 -15 5 -6 7 7 10 15 7 18 -3 3 -9 -2 -12 -12z"/>
<path d="M240 1421 c0 -6 4 -13 10 -16 6 -3 7 1 4 9 -7 18 -14 21 -14 7z"/>
<path d="M4855 1389 c-4 -6 -5 -12 -2 -15 2 -3 7 2 10 11 7 17 1 20 -8 4z"/>
<path d="M3905 360 c-16 -11 -25 -20 -20 -20 10 0 64 39 55 40 -3 0 -18 -9
-35 -20z"/>
<path d="M3700 245 c-14 -8 -20 -14 -14 -15 5 0 19 7 30 15 24 18 16 19 -16 0z"/>
<path d="M3430 130 c-8 -5 -10 -10 -5 -10 6 0 17 5 25 10 8 5 11 10 5 10 -5 0
-17 -5 -25 -10z"/>
<path d="M3275 80 c-13 -6 -15 -9 -5 -9 8 0 22 4 30 9 18 12 2 12 -25 0z"/>
<path d="M3058 23 c7 -3 16 -2 19 1 4 3 -2 6 -13 5 -11 0 -14 -3 -6 -6z"/>
<path d="M3008 13 c6 -2 18 -2 25 0 6 3 1 5 -13 5 -14 0 -19 -2 -12 -5z"/>
<path d="M2958 3 c7 -3 16 -2 19 1 4 3 -2 6 -13 5 -11 0 -14 -3 -6 -6z"/>
</g>
</svg>

================
File: static/js/cookieconsent-config.js
================
import 'https://cdn.jsdelivr.net/gh/orestbida/cookieconsent@3.0.1/dist/cookieconsent.umd.js'

CookieConsent.run({
	guiOptions: {
		consentModal: {
			layout: 'box',
			position: 'bottom left',
			equalWeightButtons: true,
			flipButtons: false
		},
		preferencesModal: {
			layout: 'box',
			position: 'right',
			equalWeightButtons: true,
			flipButtons: false
		}
	},
	categories: {
		necessary: {
			readOnly: true
		},
		analytics: {}
	},
	language: {
		default: 'en',
		autoDetect: 'browser',
		translations: {
			en: {
				consentModal: {
					title: "Hello traveller, it's cookie time!",
					description:
						'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip.',
					acceptAllBtn: 'Accept all',
					acceptNecessaryBtn: 'Reject all',
					showPreferencesBtn: 'Manage preferences',
					footer: '<a href="#link">Privacy Policy</a>\n<a href="#link">Terms and conditions</a>'
				},
				preferencesModal: {
					title: 'Consent Preferences Center',
					acceptAllBtn: 'Accept all',
					acceptNecessaryBtn: 'Reject all',
					savePreferencesBtn: 'Save preferences',
					closeIconLabel: 'Close modal',
					serviceCounterLabel: 'Service|Services',
					sections: [
						{
							title: 'Cookie Usage',
							description:
								'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.'
						},
						{
							title: 'Strictly Necessary Cookies <span class="pm__badge">Always Enabled</span>',
							description:
								'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.',
							linkedCategory: 'necessary'
						},
						{
							title: 'Analytics Cookies',
							description:
								'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.',
							linkedCategory: 'analytics'
						},
						{
							title: 'More information',
							description:
								'For any query in relation to my policy on cookies and your choices, please <a class="cc__link" href="#yourdomain.com">contact me</a>.'
						}
					]
				}
			}
		}
	}
})

================
File: static/ads.txt
================
google.com, pub-2145750142271743, DIRECT, f08c47fec0942fa0

================
File: static/robots.txt
================
################################# ROBOTS.TXT ###################################
#                                                                              #
# Alphabetically ordered whitelisting of legitimate web robots, which obey the #
# Robots Exclusion Standard (robots.txt). Each bot is shortly described in a   #
# comment above the (list of) user-agent(s). Comment out or delete lines which #
# contain User-agents you do not wish to allow on your website.                #
# Important: Blank lines are not allowed in the final robots.txt file!         #
# Updates can be retrieved from:                                               #
# https://www.ditig.com/publications/robots-txt-template                       #
#                                                                              #
# This document is licensed with a CC BY-NC-SA 4.0 license.                    #
#                                                                              #
# Last update: 2020-12-17                                                      #
#                                                                              #
################################################################################
# so.com chinese search engine
User-agent: 360Spider
User-agent: 360Spider-Image
User-agent: 360Spider-Video
# google.com landing page quality checks
User-agent: AdsBot-Google
User-agent: AdsBot-Google-Mobile
# google.com app resource fetcher
User-agent: AdsBot-Google-Mobile-Apps
# bing ads bot
User-agent: adidxbot
# apple.com search engine
User-agent: Applebot
user-agent: AppleNewsBot
# baidu.com chinese search engine
User-agent: Baiduspider
User-agent: Baiduspider-image
User-agent: Baiduspider-news
User-agent: Baiduspider-video
# bing.com international search engine
User-agent: bingbot
User-agent: BingPreview
# bublup.com suggestion/search engine
User-agent: BublupBot
# commoncrawl.org open repository of web crawl data
User-agent: CCBot
# cliqz.com german in-product search engine
User-agent: Cliqzbot
# coccoc.com vietnamese search engine
User-agent: coccoc
User-agent: coccocbot-image
User-agent: coccocbot-web
# daum.net korean search engine
User-agent: Daumoa
# dazoo.fr french search engine
User-agent: Dazoobot
# deusu.de german search engine
User-agent: DeuSu
# duckduckgo.com international privacy search engine
User-agent: DuckDuckBot
User-agent: DuckDuckGo-Favicons-Bot
# eurip.com european search engine
User-agent: EuripBot
# exploratodo.com latin search engine
User-agent: Exploratodo
# facebook.com social network
User-agent: Facebot
# feedly.com feed fetcher
User-agent: Feedly
# findx.com european search engine
User-agent: Findxbot
# goo.ne.jp japanese search engine
User-agent: gooblog
# google.com international search engine
User-agent: Googlebot
User-agent: Googlebot-Image
User-agent: Googlebot-Mobile
User-agent: Googlebot-News
User-agent: Googlebot-Video
# so.com chinese search engine
User-agent: HaoSouSpider
# goo.ne.jp japanese search engine
User-agent: ichiro
# istella.it italian search engine
User-agent: istellabot
# jike.com / chinaso.com chinese search engine
User-agent: JikeSpider
# lycos.com & hotbot.com international search engine
User-agent: Lycos
# mail.ru russian search engine
User-agent: Mail.Ru
# google.com adsense bot
User-agent: Mediapartners-Google
# mojeek.com search engine
User-agent: MojeekBot
# bing.com international search engine
User-agent: msnbot
User-agent: msnbot-media
# orange.com international search engine
User-agent: OrangeBot
# pinterest.com social networtk
User-agent: Pinterest
# botje.nl dutch search engine
User-agent: Plukkie
# qwant.com french search engine
User-agent: Qwantify
# rambler.ru russian search engine
User-agent: Rambler
# seznam.cz czech search engine
User-agent: SeznamBot
# soso.com chinese search engine
User-agent: Sosospider
# yahoo.com international search engine
User-agent: Slurp
# sogou.com chinese search engine
User-agent: Sogou blog
User-agent: Sogou inst spider
User-agent: Sogou News Spider
User-agent: Sogou Orion spider
User-agent: Sogou spider2
User-agent: Sogou web spider
# sputnik.ru russian search engine
User-agent: SputnikBot
# ask.com international search engine
User-agent: Teoma
# twitter.com bot
User-agent: Twitterbot
# wotbox.com international search engine
User-agent: wotbox
# yacy.net p2p search software
User-agent: yacybot
# yandex.com russian search engine
User-agent: Yandex
User-agent: YandexMobileBot
# search.naver.com south korean search engine
user-agent: Yeti
# yioop.com international search engine
User-agent: YioopBot
# yooz.ir iranian search engine
User-agent: yoozBot
# youdao.com chinese search engine
User-agent: YoudaoBot
# crawling rule(s) for above bots
Disallow:
# disallow all other bots
User-agent: *
Disallow: /

================
File: .gitattributes
================
*.mp4 filter=lfs diff=lfs merge=lfs -text
static/vids/flag-bg-2.mp4 filter=lfs diff=lfs merge=lfs -text

================
File: .gitignore
================
node_modules

# Output
.output
.vercel
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*

================
File: .npmrc
================
engine-strict=true

================
File: .prettierignore
================
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock

================
File: .prettierrc
================
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"tabWidth": 2,
	"semi": false,
	"plugins": ["prettier-plugin-svelte"],
	"overrides": [{ "files": "*.svelte", "options": { "parser": "svelte" } }]
}

================
File: eslint.config.js
================
import js from '@eslint/js'
import ts from 'typescript-eslint'
import svelte from 'eslint-plugin-svelte'
import prettier from 'eslint-config-prettier'
import globals from 'globals'

/** @type {import('eslint').Linter.Config[]} */
export default [
	js.configs.recommended,
	...ts.configs.recommended,
	...svelte.configs['flat/recommended'],
	prettier,
	...svelte.configs['flat/prettier'],
	{
		languageOptions: {
			globals: {
				...globals.browser,
				...globals.node
			}
		}
	},
	{
		files: ['**/*.svelte'],
		languageOptions: {
			parserOptions: {
				parser: ts.parser
			}
		}
	},
	{
		ignores: ['build/', '.svelte-kit/', 'dist/']
	}
]

================
File: main.py
================
#!/usr/bin/env python3

import argparse
import datetime
import json
import logging
import os
import subprocess
from datetime import datetime
from pathlib import Path


class Colors:
    RESET = "\033[0m"
    BOLD = "\033[1m"
    UNDERLINE = "\033[4m"

    BLACK = "\033[30m"
    RED = "\033[31m"
    GREEN = "\033[32m"
    YELLOW = "\033[33m"
    BLUE = "\033[34m"
    MAGENTA = "\033[35m"
    CYAN = "\033[36m"
    WHITE = "\033[37m"
    GREY = "\033[90m"

    @staticmethod
    def Background(color: str) -> str:
        return color.replace("[3", "[4", 1)


class CustomFormatter(logging.Formatter):
    time_format = f"{Colors.GREY}%(asctime)s{Colors.RESET}"
    FORMATS = {
        logging.DEBUG: f"{time_format} {Colors.BOLD}{Colors.CYAN}DEBG{Colors.RESET} %(message)s",
        logging.INFO: f"{time_format} {Colors.BOLD}{Colors.GREEN}INFO{Colors.RESET} %(message)s",
        logging.WARNING: f"{time_format} {Colors.BOLD}{Colors.YELLOW}WARN{Colors.RESET} %(message)s",
        logging.ERROR: f"{time_format} {Colors.BOLD}{Colors.RED}ERRR{Colors.RESET} %(message)s",
        logging.CRITICAL: f"{time_format} {Colors.BOLD}{Colors.Background(Colors.RED)}CRIT{Colors.RESET} %(message)s",
    }

    def format(self, record: any) -> str:
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt, datefmt="%H:%M")
        return formatter.format(record)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="reads Arc Browser JSON data, converts it to HTML, and writes the output to a specified file."
    )
    parser.add_argument("-s", "--silent", action="store_true", help="silence output")
    parser.add_argument(
        "-o", "--output", type=Path, required=False, help="specify the output file path"
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        default=False,
        help="enable verbose output",
    )
    parser.add_argument(
        "--version",
        action="store_true",
        help="print the git short hash and commit time",
    )

    args = parser.parse_args()

    if args.silent:
        logging.disable(logging.CRITICAL)
    else:
        setup_logging(args.verbose)

    if args.version:
        commit_hash, commit_time = get_version()
        if commit_hash is None or commit_time is None:
            logging.critical("Could not fetch Git metadata.")
            return
        print(
            f"{Colors.BOLD}GIT TIME{Colors.RESET} | {Colors.GREEN}{commit_time.strftime('%Y-%m-%d')}{Colors.RESET} [{Colors.YELLOW}{int(commit_time.timestamp())}{Colors.RESET}]"
        )
        print(
            f"{Colors.BOLD}GIT HASH{Colors.RESET} | {Colors.MAGENTA}{commit_hash}{Colors.RESET}"
        )
        return

    data: dict = read_json()
    html: str = convert_json_to_html(data)
    write_html(html, args.output)
    logging.info("Done!")


def setup_logging(is_verbose: bool) -> None:
    handler = logging.StreamHandler()
    handler.setFormatter(CustomFormatter())
    logging.basicConfig(level=logging.DEBUG, handlers=[handler])

    if is_verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    else:
        logging.getLogger().setLevel(logging.INFO)


def get_version() -> tuple[str, datetime]:
    try:
        commit_hash: str = (
            subprocess.check_output(["git", "rev-parse", "--short", "HEAD"])
            .decode("utf-8")
            .strip()
        )
        commit_time_str: str = (
            subprocess.check_output(["git", "log", "-1", "--format=%ct"])
            .decode("utf-8")
            .strip()
        )
        commit_time = datetime.fromtimestamp(int(commit_time_str))
    except Exception:
        commit_hash = None
        commit_time = None

    return commit_hash, commit_time


def read_json() -> dict:
    logging.info("Reading JSON...")

    filename: Path = Path("StorableSidebar.json")
    if os.name == "nt":
        arc_root_parent_path: Path = Path(
            os.path.expanduser(r"~\AppData\Local\Packages")
        )
        arc_root_paths: list[Path] = [
            f
            for f in arc_root_parent_path.glob("*")
            if f.name.startswith("TheBrowserCompany.Arc")
        ]
        if len(arc_root_paths) != 1:
            raise FileNotFoundError

        library_path: Path = Path(
            arc_root_paths[0].joinpath(r"LocalCache\Local\Arc")
        ).joinpath(filename)

    else:
        library_path: Path = Path(
            os.path.expanduser("~/Library/Application Support/Arc/")
        ).joinpath(filename)

    data: dict = {}

    if filename.exists():
        with filename.open("r", encoding="utf-8") as f:
            logging.debug(f"Found {filename} in current directory.")
            data = json.load(f)

    elif library_path.exists():
        with library_path.open("r", encoding="utf-8") as f:
            logging.debug(f"Found {filename} in Library directory.")
            data = json.load(f)

    else:
        logging.critical(
            '> File not found. Look for the "StorableSidebar.json" '
            '  file within the "~/Library/Application Support/Arc/" folder.'
        )
        raise FileNotFoundError

    return data


def convert_json_to_html(json_data: dict) -> str:
    containers: list = json_data["sidebar"]["containers"]
    target: int = sum([1 for i in containers if "global" in i])

    spaces: dict = get_spaces(json_data["sidebar"]["containers"][target]["spaces"])
    items: list = json_data["sidebar"]["containers"][target]["items"]

    bookmarks: dict = convert_to_bookmarks(spaces, items)
    html_content: str = convert_bookmarks_to_html(bookmarks)

    return html_content


def get_spaces(spaces: list) -> dict:
    logging.info("Getting spaces...")

    spaces_names: dict = {"pinned": {}, "unpinned": {}}
    spaces_count: int = 0
    n: int = 1

    for space in spaces:
        if "title" in space:
            title: str = space["title"]
        else:
            title: str = "Space " + str(n)
            n += 1

        # TODO: Find a better way to determine if a space is pinned or not
        if isinstance(space, dict):
            containers: list = space["newContainerIDs"]

            for i in range(len(containers)):
                if isinstance(containers[i], dict):
                    if "pinned" in containers[i]:
                        spaces_names["pinned"][str(containers[i + 1])]: str = title
                    elif "unpinned" in containers[i]:
                        spaces_names["unpinned"][str(containers[i + 1])]: str = title

            spaces_count += 1

    logging.debug(f"Found {spaces_count} spaces.")

    return spaces_names


def convert_to_bookmarks(spaces: dict, items: list) -> dict:
    logging.info("Converting to bookmarks...")

    bookmarks: dict = {"bookmarks": []}
    bookmarks_count: int = 0
    item_dict: dict = {item["id"]: item for item in items if isinstance(item, dict)}

    def recurse_into_children(parent_id: str) -> list:
        nonlocal bookmarks_count
        children: list = []
        for item_id, item in item_dict.items():
            if item.get("parentID") == parent_id:
                if "data" in item and "tab" in item["data"]:
                    children.append(
                        {
                            "title": item.get("title", None)
                            or item["data"]["tab"].get("savedTitle", ""),
                            "type": "bookmark",
                            "url": item["data"]["tab"].get("savedURL", ""),
                        }
                    )
                    bookmarks_count += 1
                elif "title" in item:
                    child_folder: dict = {
                        "title": item["title"],
                        "type": "folder",
                        "children": recurse_into_children(item_id),
                    }
                    children.append(child_folder)
        return children

    for space_id, space_name in spaces["pinned"].items():
        space_folder: dict = {
            "title": space_name,
            "type": "folder",
            "children": recurse_into_children(space_id),
        }
        bookmarks["bookmarks"].append(space_folder)

    logging.debug(f"Found {bookmarks_count} bookmarks.")

    return bookmarks


def convert_bookmarks_to_html(bookmarks: dict) -> str:
    logging.info("Converting bookmarks to HTML...")

    html_str: str = """<!DOCTYPE NETSCAPE-Bookmark-file-1>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>"""

    def traverse_dict(d: dict, html_str: str, level: int) -> str:
        indent: str = "\t" * level
        for item in d:
            if item["type"] == "folder":
                html_str += f'\n{indent}<DT><H3>{item["title"]}</H3>'
                html_str += f"\n{indent}<DL><p>"
                html_str = traverse_dict(item["children"], html_str, level + 1)
                html_str += f"\n{indent}</DL><p>"
            elif item["type"] == "bookmark":
                html_str += f'\n{indent}<DT><A HREF="{item["url"]}">{item["title"]}</A>'
        return html_str

    html_str = traverse_dict(bookmarks["bookmarks"], html_str, 1)
    html_str += "\n</DL><p>"

    logging.debug("HTML converted.")

    return html_str


def write_html(html_content: str, output: Path = None) -> None:
    logging.info("Writing HTML...")

    if output is not None:
        output_file: Path = output
    else:
        current_date: str = datetime.now().strftime("%Y_%m_%d")
        output_file: Path = Path("arc_bookmarks_" + current_date).with_suffix(".html")

    with output_file.open("w", encoding="utf-8") as f:
        f.write(html_content)

    logging.debug(f"HTML written to {output_file}.")


if __name__ == "__main__":
    main()

================
File: package.json
================
{
	"name": "site-template",
	"version": "0.0.1",
	"private": true,
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"test": "vitest",
		"lint": "prettier --check . && eslint .",
		"format": "prettier --write ."
	},
	"devDependencies": {
		"@beyonk/gdpr-cookie-consent-banner": "^12.1.4",
		"@codewithshin/svelte-utterances": "^0.2.4",
		"@sveltejs/adapter-auto": "^3.2.5",
		"@sveltejs/kit": "^2.7.1",
		"@sveltejs/vite-plugin-svelte": "4.0.0-next.7",
		"@types/eslint": "^9.6.1",
		"eslint": "^9.12.0",
		"eslint-config-prettier": "^9.1.0",
		"eslint-plugin-svelte": "^2.45.1",
		"globals": "^15.11.0",
		"mdsvex": "^0.12.3",
		"partytown-sveltekit": "^0.0.3",
		"prettier": "^3.3.3",
		"prettier-plugin-svelte": "^3.2.7",
		"svelte": "5.0.0-next.260",
		"svelte-check": "^4.0.5",
		"svelte-cloudinary": "^2.1.1",
		"typescript": "5.7.0-beta",
		"typescript-eslint": "^8.10.0",
		"vercel": "^37.9.0",
		"vite": "^5.4.9",
		"vitest": "^2.1.3"
	},
	"type": "module",
	"dependencies": {
		"@builder.io/partytown": "^0.10.2",
		"@sveltejs/adapter-vercel": "^5.4.5",
		"@vercel/analytics": "^1.3.1",
		"@vercel/speed-insights": "^1.0.12",
		"iconify-icon": "^2.1.0",
		"lucide-svelte": "^0.439.0",
		"nodemailer": "^6.9.15",
		"open-props": "^1.7.7",
		"path": "^0.12.7",
		"rehype-slug": "^6.0.0",
		"remark-toc": "^9.0.0",
		"remark-unwrap-images": "^4.0.1",
		"shiki": "^1.22.0"
	}
}

================
File: README.md
================
# create-svelte

Everything you need to build a Svelte project, powered by [`create-svelte`](https://github.com/sveltejs/kit/tree/main/packages/create-svelte).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```bash
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```bash
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```bash
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://kit.svelte.dev/docs/adapters) for your target environment.

================
File: SECURITY.md
================
# Security Policy

## Supported Versions

Use this section to tell people about which versions of your project are
currently being supported with security updates.

| Version | Supported          |
| ------- | ------------------ |
| 5.1.x   | :white_check_mark: |
| 5.0.x   | :x:                |
| 4.0.x   | :white_check_mark: |
| < 4.0   | :x:                |

## Reporting a Vulnerability

Use this section to tell people how to report a vulnerability.

Tell them where to go, how often they can expect to get an update on a
reported vulnerability, what to expect if the vulnerability is accepted or
declined, etc.

================
File: svelte.config.js
================
import { join } from 'path'
import { getHighlighter } from 'shiki'
import { mdsvex, escapeSvelte } from 'mdsvex'
import adapter from '@sveltejs/adapter-vercel'
import { partytownVite } from '@builder.io/partytown/utils'
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

import remarkUnwrapImages from 'remark-unwrap-images'
import remarkToc from 'remark-toc'
import rehypeSlug from 'rehype-slug'

/** @type {import('mdsvex').MdsvexOptions} */
const mdsvexOptions = {
	extensions: ['.md', '.svx'],
	remarkPlugins: [remarkUnwrapImages, [remarkToc, { tight: true }]],
	rehypePlugins: [rehypeSlug],
	highlight: {
		highlighter: async (code, lang = 'text') => {
			const highlighter = await getHighlighter({
				themes: ['poimandres'],
				langs: ['javascript', 'typescript']
			})
			await highlighter.loadLanguage('javascript', 'typescript')
			const html = escapeSvelte(highlighter.codeToHtml(code, { lang, theme: 'poimandres' }))
			return `{@html \`${html}\` }`
		}
	}
}

/** @type {import('@sveltejs/kit').Config} */
const config = {
	extensions: ['.svelte', '.md', '.svx'],
	preprocess: [vitePreprocess(), mdsvex(mdsvexOptions)],
	kit: {
		adapter: adapter(),
		prerender: {
			handleHttpError: ({ status, path, referrer, referenceType }) => {
				// Handle the error based on status code or other parameters
				if (status === 500) {
					console.error(`Error 500 encountered at ${path}`)
					return { status: 200, body: 'Custom error message or handling logic' }
				}
			}
		}
	}
}

export default config

================
File: tsconfig.json
================
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler"
	}
	// Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
	// except $lib which is handled by https://kit.svelte.dev/docs/configuration#files
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}

================
File: vite.config.ts
================
import { sveltekit } from '@sveltejs/kit/vite'
import { defineConfig } from 'vitest/config'

export default defineConfig({
	plugins: [sveltekit()],
	test: {
		include: ['src/**/*.{test,spec}.{js,ts}']
	}
})
